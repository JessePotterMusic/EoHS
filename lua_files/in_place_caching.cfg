this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- in_place_caching.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

local caching_set
local invalidate_cache = function(domain, cache_name, counter)
  local cache_counter_idx = cache_name.."__EoHSInPlaceCacheCounter"
  if tonumber(domain[cache_counter_idx]) == tonumber(counter) then
    caching_set(domain, cache_name.."__EoHSInPlaceCache", nil) -- does need to be caching_set: other caches may be referring to the cache, and it's not valid now.
  end
end

caching_set = function(domain, k, v)
  EoHS.assert(not domain["_EoHSInPlaceCache_InFunction_"], "Setting a variable during a caching function")
  if domain[k] ~= v then
    domain[k] = v
    local reliance_idx = k.."__ReliantEoHSInPlaceCaches"
    local k_reliant_caches = domain[reliance_idx]
    if k_reliant_caches then
      for cache_name,counter in string.gmatch(k_reliant_caches, "_EoHSInPlaceCacheName_(.-)_EoHSInPlaceCacheNumber_(.-)_EoHSInPlaceCacheEnd_") do
        invalidate_cache(domain, cache_name, counter)
      end
      domain[reliance_idx] = nil
    end
  end
end

-- Produce a value, possibly by relying on current values,
-- and store it in a cache.
local next_caching_func_id = 1
EoHS.caching_func = function(func)
  local id = next_caching_func_id
  next_caching_func_id = next_caching_func_id + 1
  return function(domain, ...)
    local cache_name = id
    for i,argument in EoHS.vararg(...) do
      local common_bad_char_translations = {[","]="COMMA",["/"]="SOLIDUS",["."]="PERIOD",["-"]="HYPHEN"}
      local argstring = type(argument)..string.gsub(tostring(argument), "[^%a%d_]", function(bad_char) return common_bad_char_translations[bad_char] or "BADCHAR" end)
      cache_name = cache_name.."_EoHSInPlaceCacheArg_"..argstring
    end
    local cache_idx, cache_counter_idx = cache_name.."__EoHSInPlaceCache", cache_name.."__EoHSInPlaceCacheCounter"
    
    local top_level = false
    local metatable = getmetatable(domain)
    domain = metatable.in_place_cache_underlying_domain
    if metatable.rely_on then
      metatable.rely_on(cache_idx)
    else
      top_level = true
      domain["_EoHSInPlaceCache_InFunction_"] = true
    end
    
    local cached = domain[cache_idx]
    if cached then
      cached = EoHS.deserialize(cached)
    else
      local counter = (domain[cache_counter_idx] or 0) + 1
      domain[cache_counter_idx] = counter
      
      local caching_func_context = "_EoHSInPlaceCacheName_"..cache_name.."_EoHSInPlaceCacheNumber_"..counter.."_EoHSInPlaceCacheEnd_"
      local relying_on = {}
      local rely_on = function(k)
        if relying_on[k] then return end
        relying_on[k] = true
        local reliance_idx = k.."__ReliantEoHSInPlaceCaches"
        domain[reliance_idx] = (domain[reliance_idx] or "")..caching_func_context
      end
      cached = func(setmetatable({}, {
        in_place_cache_underlying_domain = domain,
        rely_on = rely_on,
        __index = function(unused,k) rely_on(k); return domain[k] end,
        __newindex = function() EoHS.err("A caching function tried to mutate something") end,
      }), ...)
      
      domain[cache_idx] = EoHS.serialize(cached) -- doesn't need to be caching_set: no one should be referring to this nil value currently.
    end
    if top_level then domain["_EoHSInPlaceCache_InFunction_"] = nil end
    return cached
  end
end


local get_unit_variables_table = function(unit)
  local variables = unit.variables
  if not variables then variables = EoHS.get_subtag(unit, "variables") end
  if not variables then return nil end
  return setmetatable({}, {
    __index = function(unused,k) return variables[k] end,
    __newindex = function(unused,k,v) EoHS.err("Modifying a read-only access to unit variables") end,
  })
end
local force_unit_variables_table = function(unit)
  local variables = unit.variables
  if not variables then variables = EoHS.force_subtag(unit, "variables") end
  return variables
end
EoHS.all_EoHS_unit_variables = {}
local caching_interface = function(cache_table)
  return setmetatable({}, {
    in_place_cache_underlying_domain = cache_table,
    __index = function(unused,k) return cache_table[k] end,
    __newindex = function(unused,k,v)
      caching_set(cache_table, k, v)
    end,
  })
end


local conversion_table = {
  ["\\"]="/",[","]=".",["{"]="[",["}"]="]",["!"]="?",
}
local reverse_conversion_table = {}; for k,v in pairs(conversion_table) do reverse_conversion_table[v]=k end
EoHS.serialize = function(v)
  local escape = function(s) return string.gsub(s, '[\\,{}!]', function(k) return '\\'..(conversion_table[k] or k) end) end
  if type(v) == "string" or type(v) == "boolean" or type(v) == "number" then
    return type(v)..','..escape(tostring(v))
  elseif type(v) == "table" then
    local result = ""
    local sorted_keys = {}
    for k in pairs(v) do
      if type(k) == "string" then
        table.insert(sorted_keys, k)
      end
    end
    table.sort(sorted_keys)
    local record = function(name, value)
      result = result..'!'..name..'='..EoHS.serialize(value)
    end
    for i,k in ipairs(sorted_keys) do
      record("N"..k,v[k])
    end
    for i,val in ipairs(v) do
      record("",val)
    end
    result = "{"..result.."}"
    --EoHS.debug(v, result, EoHS.deserialize(result))
    return result
  else
    EoHS.err("bad input to EoHS.serialize: "..EoHS.inspect(v))
  end
  --EoHS.assert(EoHS.tags_are_identical(t, EoHS.deserialize(result)), "serialization is buggy: "..EoHS.inspect(t).." became "..EoHS.inspect(result).." and then became "..EoHS.deserialize(result))
end
EoHS.deserialize = function(serialized)
  local unescape = function(s) return string.gsub(s, '\\(.)', function(k) return reverse_conversion_table[k] or k end) end
  local ta = string.match(serialized, "^{(.*)}$")
  if ta then
    local result = {}
    while ta ~= "" do
      local old_ta = ta
      ta = string.gsub(ta, "^!([^!=]-)=(%b{})", function(name, v)
        if name == "" then table.insert(result, EoHS.deserialize(v))
        else result[string.sub(name, 2)] = EoHS.deserialize(v) end
        return ""
      end)
      ta = string.gsub(ta, "^!([^!=]*)=([^!{}]-,[^!{}]*)", function(name, v)
        if name == "" then table.insert(result, EoHS.deserialize(v))
        else result[string.sub(name, 2)] = EoHS.deserialize(v) end
        return ""
      end)
      if old_ta == ta then EoHS.err("bad input to EoHS.deserialize: "..serialized); break end
    end
    if string.len(serialized) < 400 then EoHS.assert(serialized == EoHS.serialize(result), "serialization is buggy: "..EoHS.inspect(serialized).." became "..EoHS.inspect(result).." and then became "..EoHS.inspect(EoHS.serialize(result))) end
    return result
  end
  local t,v = string.match(serialized, "^(.-),(.*)$")
  v = unescape(v)
  if t == "boolean" then return (v == "true")
  elseif t == "number" then return tonumber(v)
  else return v end
end

EoHS.get_fake_subtag = function(source, subtag_name)
  if type(source) == "function" then
    return setmetatable({}, {
      __index = function(unused,k) return source(subtag_name.."_"..k) end,
      __newindex = function(unused,k,v) EoHS.err("Modifying a read-only EoHS.get_fake_subtag") end,
    })
  elseif type(source) == "table" then
    return setmetatable({}, {
      --original_table = (getmetatable(source).original_table or source)
      --fake_subtag_path = (getmetatable(source).fake_subtag_path or "") .. subtag_name.."_"
      __index = function(unused,k) return source[subtag_name.."_"..k] end,
      __newindex = function(unused,k,v) source[subtag_name.."_"..k] = v end,
    })
  end
end
--[[EoHS.copy_fake_subtag = function(fake_subtag)
  local original_table = getmetatable(fake_subtag).original_table
  EoHS.assert(original_table, "Trying to copy a whole subtag made from a function, which isn't possible")
end]]
EoHS.get_unit_variables = function(unit)
  return EoHS.get_fake_subtag(get_unit_variables_table(unit), "EoHS")
end
EoHS.force_unit_variables = function(unit)
  return caching_interface(EoHS.get_fake_subtag(force_unit_variables_table(unit), "EoHS"))
end

-- These work on both unit tables and proxy units.
EoHS.get_unit_variable = function(unit, varname)
      EoHS.all_EoHS_unit_variables[varname] = true
  local variables = EoHS.get_unit_variables(unit)
  if variables then return variables[varname] end
end
EoHS.set_unit_variable = function(unit, varname, value)
      EoHS.all_EoHS_unit_variables[varname] = true
  EoHS.force_unit_variables(unit)[varname] = value
end


-->>)}
