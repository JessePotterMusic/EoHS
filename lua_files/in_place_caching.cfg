{EOHS_LUA_FILE (<<-- in_place_caching.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

local caching_set
local invalidate_cache = function(domain, cache_name, counter)
  if tonumber(domain[cache_name.."__cache_counter"]) == tonumber(counter) then
    caching_set(domain, cache_name.."__cache", nil) -- does need to be caching_set: other caches may be referring to the cache, and it's not valid now.
  end
end

local caching_set = function(domain, k, v)
  if domain[k] ~= v then
    domain[k] = v
    local k_reliant_caches = domain[k.."__reliant_caches"]
    if k_reliant_caches then
      for cache_name,counter in string.gmatch(k_reliant_caches, "EoHS_cache_name(.-)EoHS_cache_number(.-)EoHS_cache_end") do
        invalidate_cache(cache_name, counter)
      end
      domain[k.."__reliant_caches"] = nil
    end
  end
end

-- Produce a value, possibly by relying on current values,
-- and store it in a cache.
local function caching_call(domain, id, func, ...)
  local cache_name = id
  for i,arg in ipairs({...}) do
    local argstring = type(arg)..string.gsub(tostring(arg), "[^%a%d_]", function(bad_char) return end)
    cache_name = cache_name.."_InPlaceCacheArg_"..argstring
  end
  local cached = domain[cache_name.."__cache"]
  if not cached then
    local counter = (domain[cache_name.."__cache_counter"] or 0) + 1
    
    local caching_func_context = "_InPlaceCacheName_"..cache_name.."_InPlaceCacheNumber_"..cache_counter.."_InPlaceCacheEnd_"
    local result = func(function(k)
      domain[k.."__reliant_caches"] = (domain[k.."__reliant_caches"] or "")..caching_func_context
      return domain[k]
    end,
    function(id2, func2, ...)
      local result, cache_key = caching_call(domain, id2, func2, ...)
      domain[cache_key.."__reliant_caches"] = (domain[cache_key.."__reliant_caches"] or "")..caching_func_context
      return result
    end, ...)
    
    domain[cache_name.."__cache"] = result -- doesn't need to be caching_set: no one should be referring to this nil value currently.
  end
  return domain[cache_name.."__cache"], cache_name.."__cache"
end


local force_unit_variables_table = function(unit)
  local variables = unit.variables
  if not variables then variables = EoHS.force_subtag(unit, "variables") end
  return variables
end

-- These work on both unit tables and proxy units.
EoHS.get_unit_variable = function(unit, varname)
  return caching_get(force_unit_variables_table(unit), "EoHS_"..varname)
end
EoHS.set_unit_variable = function(unit, varname, value)
  caching_set(force_unit_variables_table(unit), "EoHS_"..varname, value)
end

--[[

The prize of this work: Automatic caching, subject to certain restrictions.
A caching function can ONLY refer to its convertible-to-string arguments and to unit variables,
which it accesses through the callback that is its first argument,
and to the results of other caching functions.
Ex.:

EoHS.swords_plus_shields_plus_intelligencerating_plus_constant =
  EoHS.make_caching_unit_func("swords_plus_shields_plus_intelligencerating_plus_constant",
  function(get_func, call_func, constant)
    return get_func("swords") + get_func("shields") + call_func("rate_unit_intelligence") + constant
  end)
end)

Thereafter anyone could call EoHS.swords_plus_shields_plus_intelligencerating_plus_constant(unit, 2) lots of times,
  and the time spent in the function would be saved as long as the unit's swords and shields,
  and anything used by the intelligence rating function, stayed the same.

]]

local caching_unit_funcs = {}
EoHS.make_caching_unit_func = function(id, func)
  local internal_func_id = "EoHS_unit_caching_func_"..id
  local internal_func = function(get_func, call_func, ...)
    return func(
      function(k) return get_func("EoHS_"..k) end,
      function(id2) return call_func("EoHS_unit_caching_func_"..id2, caching_unit_funcs[id2]) end,
      ...)
  end
  caching_unit_funcs[id] = internal_func
  return function(unit, ...)
    local variables = force_unit_variables_table(unit)
    return caching_call(variables, internal_func_id, internal_func, ...)
  end
end


>>)}
