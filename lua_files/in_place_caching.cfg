{EOHS_LUA_FILE (<<-- in_place_caching.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

local caching_set
local invalidate_cache = function(domain, cache_name, counter)
  local cache_counter_idx = cache_name.."__EoHSInPlaceCacheCounter"
  if tonumber(domain[cache_counter_idx]) == tonumber(counter) then
    caching_set(domain, cache_name.."__EoHSInPlaceCache", nil) -- does need to be caching_set: other caches may be referring to the cache, and it's not valid now.
  end
end

caching_set = function(domain, k, v)
  if domain[k] ~= v then
    domain[k] = v
    local reliance_idx = k.."__ReliantEoHSInPlaceCaches"
    local k_reliant_caches = domain[reliance_idx]
    if k_reliant_caches then
      for cache_name,counter in string.gmatch(k_reliant_caches, "_EoHSInPlaceCacheName_(.-)_EoHSInPlaceCacheNumber_(.-)_EoHSInPlaceCacheEnd_") do
        invalidate_cache(domain, cache_name, counter)
      end
      domain[reliance_idx] = nil
    end
  end
end

-- Produce a value, possibly by relying on current values,
-- and store it in a cache.
local function caching_call(domain, id, func, ...)
  local cache_name = id
  for i,argument in EoHS.vararg(...) do
    local common_bad_char_translations = {[","]="COMMA",["/"]="SOLIDUS",["."]="PERIOD",["-"]="HYPHEN"}
    local argstring = type(argument)..string.gsub(tostring(argument), "[^%a%d_]", function(bad_char) return common_bad_char_translations[bad_char] or "BADCHAR" end)
    cache_name = cache_name.."_EoHSInPlaceCacheArg_"..argstring
  end
  local cache_idx, cache_counter_idx = cache_name.."__EoHSInPlaceCache", cache_name.."__EoHSInPlaceCacheCounter"
  local cached = domain[cache_idx]
  if not cached then
    local counter = (domain[cache_counter_idx] or 0) + 1
    domain[cache_counter_idx] = counter
    
    local caching_func_context = "_EoHSInPlaceCacheName_"..cache_name.."_EoHSInPlaceCacheNumber_"..counter.."_EoHSInPlaceCacheEnd_"
    local rely_on = function(k)
      local reliance_idx = k.."__ReliantEoHSInPlaceCaches"
      domain[reliance_idx] = (domain[reliance_idx] or "")..caching_func_context
    end
    cached = func(function(k)
      rely_on(k)
      return domain[k]
    end,
    function(id2, func2, ...)
      local result, cache_idx2 = caching_call(domain, id2, func2, ...)
      rely_on(cache_idx2)
      return result
    end, ...)
    
    domain[cache_idx] = cached -- doesn't need to be caching_set: no one should be referring to this nil value currently.
  end
  return cached, cache_idx
end


local get_unit_variables_table = function(unit)
  local variables = unit.variables
  if not variables then variables = EoHS.get_subtag(unit, "variables") end
  if not variables then return nil end
  return setmetatable({}, {
    __index = function(unused,k) return variables[k] end,
    __newindex = function(unused,k,v) EoHS.err("Modifying a read-only access to unit variables") end,
  })
end
local force_unit_variables_table = function(unit)
  local variables = unit.variables
  if not variables then variables = EoHS.force_subtag(unit, "variables") end
  return variables
end
EoHS.all_EoHS_unit_variables = {}
local caching_interface = function(cache_table)
  return setmetatable({}, {
    __index = function(unused,k) return cache_table[k] end,
    __newindex = function(unused,k,v)
      EoHS.all_EoHS_unit_variables[k] = true
      caching_set(cache_table, k, v)
    end,
  })
end
--[[
EoHS.serialize_wml_table = function(wml_table)
  local result = ""
  for k,v in pairs(wml_table) do
    result = result.."_EoHSSerializeKey_"..k.."_EoHSSerializeValue_"..v
  end
end]]

EoHS.get_fake_subtag = function(source, subtag_name)
  if type(source) == "function" then
    return setmetatable({}, {
      __index = function(unused,k) return source(subtag_name.."_"..k) end,
      __newindex = function(unused,k,v) EoHS.err("Modifying a read-only EoHS.get_fake_subtag") end,
    })
  elseif type(source) == "table" then
    return setmetatable({}, {
      --original_table = (getmetatable(source).original_table or source)
      --fake_subtag_path = (getmetatable(source).fake_subtag_path or "") .. subtag_name.."_"
      __index = function(unused,k) return source[subtag_name.."_"..k] end,
      __newindex = function(unused,k,v) source[subtag_name.."_"..k] = v end,
    })
  end
end
--[[EoHS.copy_fake_subtag = function(fake_subtag)
  local original_table = getmetatable(fake_subtag).original_table
  EoHS.assert(original_table, "Trying to copy a whole subtag made from a function, which isn't possible")
end]]
EoHS.get_unit_variables = function(unit)
  return EoHS.get_fake_subtag(get_unit_variables_table(unit), "EoHS")
end
EoHS.force_unit_variables = function(unit)
  return caching_interface(EoHS.get_fake_subtag(force_unit_variables_table(unit), "EoHS"))
end

-- These work on both unit tables and proxy units.
EoHS.get_unit_variable = function(unit, varname)
  local variables = EoHS.get_unit_variables(unit)
  if variables then return variables[varname] end
end
EoHS.set_unit_variable = function(unit, varname, value)
  EoHS.force_unit_variables(unit)[varname] = value
  --caching_set(force_unit_variables_table(unit), "EoHS_"..varname, value)
end

--[[

The prize of this work: Automatic caching, subject to certain restrictions.
A caching function can ONLY refer to its convertible-to-string arguments and to unit variables,
which it accesses through the callback that is its first argument,
and to the results of other caching functions.
Ex.:

EoHS.swords_plus_shields_plus_intelligencerating_plus_constant =
  EoHS.make_caching_unit_func("swords_plus_shields_plus_intelligencerating_plus_constant",
  function(get_func, call_func, constant)
    return get_func("swords") + get_func("shields") + call_func("rate_unit_intelligence") + constant
  end)
end)

Thereafter anyone could call EoHS.swords_plus_shields_plus_intelligencerating_plus_constant(unit, 2) lots of times,
  and the time spent in the function would be saved as long as the unit's swords and shields,
  and anything used by the intelligence rating function, stayed the same.

]]

local caching_unit_funcs = {}
EoHS.make_caching_unit_variables_func = function(id, func)
  local internal_func_id = "unit_caching_func_"..id
  local internal_func = function(get_func, call_func, ...)
    return func(get_func,
      function(id2, ...) return call_func("unit_caching_func_"..id2, caching_unit_funcs[id2], ...) end,
      ...)
  end
  caching_unit_funcs[id] = internal_func
  return function(variables, ...)
    return caching_call(variables, internal_func_id, internal_func, ...)
  end
end


>>)}
