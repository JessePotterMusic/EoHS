{EOHS_LUA_FILE (<<-- image_manipulation.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery

--[[

A "image_base" is an image string without mods.
A "image_modded" is an image string, possibly with mods.
A "image_layer" is an image_modded or {
  image_modded = image_modded
  offset = {x=,y=}
  character_center_offset = {x=,y=} (cumulative with offsx)
  weapon_head_offset = {x=,y=} (cumulative with offsx)
}
A "image_aggregate" is an image_layer or a list of image_layers, bottom to top.

]]

EoHS.image_rect = function(partial_image_rect)
  local result = EoHS.deep_copy(partial_image_rect)
  if not result.min then result.min = {} end
  if not result.max then result.max = {} end
  if not result.size then result.size = {} end
  if not result.offset then result.offset = {} end
  --convenience names
  if partial_image_rect.x1 then partial_image_rect.min.x = partial_image_rect.x1 end
  if partial_image_rect.x2 then partial_image_rect.max.x = partial_image_rect.x2 end
  if partial_image_rect.y1 then partial_image_rect.min.y = partial_image_rect.y1 end
  if partial_image_rect.y2 then partial_image_rect.max.y = partial_image_rect.y2 end
  for i,dim in ipairs{"x","y"} do
    if (result.min[dim] and 1 or 0) + (result.max[dim] and 1 or 0) + (result.size[dim] and 1 or 0) + (result.offset[dim] and 1 or 0) > 2 then EoHS.err("EoHS.image_rect overdefined") end
    if result.offset[dim] then
      if result.min[dim] then
        result.offset[dim]
        EoHS.err("EoHS.image_rect whyyyyy")
      elseif result.max[dim] then
        EoHS.err("EoHS.image_rect whyyyyy")
      elseif result.size[dim] then
        result.min[dim] = result.offset[dim] - math.ceil (result.size[dim]/2)
        result.max[dim] = result.offset[dim] + math.floor(result.size[dim]/2) - 1
      else
        EoHS.err("EoHS.image_rect whyyyyy")
      end
    else
      if result.min[dim] then
        if result.max[dim] then
          result.size[dim] = 1 + result.max[dim]-result.min[dim]
        elseif result.size[dim] then
          result.max[dim] = result.min[dim]+result.size[dim] - 1
        else
          result.max[dim] = math.huge
          result.size[dim] = math.huge
        end
      elseif result.max[dim] then
        if result.size[dim] then
          result.min[dim] = 1 + result.max[dim]-result.size[dim]
        else
          result.min[dim] = -math.huge
          result.size[dim] = math.huge
        end
      elseif result.size[dim] and (result.size[dim] ~= math.huge) then
        EoHS.err("EoHS.image_rect Can't generate from size with neither max or min!")
      else
        result.min[dim] = -math.huge
        result.max[dim] = math.huge
        result.size[dim] = math.huge
      end
        
      result.offset[dim] = result.min[dim] + math.ceil(result.size[dim]/2)
    end
    if result.max[dim]<result.min[dim] then return EoHS.image_rect_nowhere() end
  end
  
  return result
end

EoHS.image_rect_nowhere = function() return nil end
EoHS.image_rect_is_anywhere = function(image_rect) return image_rect~=nil end
EoHS.image_rect_balanced = function(image_rect)
  local result
  for i,dim in ipairs{"x","y"} do
    local d = math.max(result.max[dim]+1, -result.min[dim])
    result.min[dim] = -d
    result.max[dim] = d-1
    result.size[dim] = d*2
    result.offset[dim] = 0
  end
  return result
end
EoHS.image_rect_intersection = function(image_rect1, image_rect2)
  if not (EoHS.image_rect_is_anywhere(image_rect1) and EoHS.image_rect_is_anywhere(image_rect2)) then return EoHS.image_rect_nowhere() end
    
  local result = { max={}, min={} }
  for i,dim in ipairs{"x","y"} do
    result.min[dim] = math.max(image_rect1.min[dim], image_rect2.min[dim])
    result.max[dim] = math.min(image_rect1.max[dim], image_rect2.max[dim])
  end
  return EoHS.image_rect(result)
end
EoHS.image_rect_superunion = function(image_rect1, image_rect2)
  if not EoHS.image_rect_is_anywhere(image_rect1) then return EoHS.deep_copy(image_rect2) end
  if not EoHS.image_rect_is_anywhere(image_rect2) then return EoHS.deep_copy(image_rect1) end
    
  local result = { max={}, min={} }
  for i,dim in ipairs{"x","y"} do
    result.min[dim] = math.min(image_rect1.min[dim], image_rect2.min[dim])
    result.max[dim] = math.max(image_rect1.max[dim], image_rect2.max[dim])
  end
  return EoHS.image_rect(result)
end
EoHS.image_rects_are_equal = function(image_rect1, image_rect2)
  for i,dim in ipairs{"x","y"} do
    if not (image_rect1.min[dim] == image_rect2.min[dim]) then return false end
    if not (image_rect1.max[dim] == image_rect2.max[dim]) then return false end
  end
  return true
end

EoHS.get_image_base = function(image_layer)
  if type(image_layer) == "string" then
    -- Hack to appease the macro TEAM_COLOR_OVERRIDE, which currently (1.10.6) uses "RC()" when it should use "~RC()"
    if string.match(image_layer, "pngRC") then return string.match(image_layer, "^(.-)RC") end
    return string.match(image_layer, "[^~]*")
  end
  return EoHS.image_base(image_layer.image_modded)
end

EoHS.get_image_modded = function(image_layer)
  if type(image_layer) == "string" then return image_layer end
  return image_layer.image_modded
end

EoHS.full_image_layer_reference = function(image_layer)
  if type(image_layer) == "string" then return { image_modded=image_layer, offset={x=0,y=0}} end
  return image_layer
end
EoHS.full_image_layer_copy = function(image_layer)
  if type(image_layer) == "string" then return { image_modded=image_layer, offset={x=0,y=0}} end
  return EoHS.deep_copy(image_layer)
end

EoHS.image_aggregate_extents = function(image_layer)
  if is_layer_list(image_aggregate) then
    local result = EoHS.image_rect_nowhere()
    for i,layer in ipairs(image_aggregate) do
      result = EoHS.image_rect_superunion(result, EoHS.image_aggregate_extents(layer))
    end
    return result
  else
    local width, height = wesnoth.get_image_size(EoHS.get_image_base(image_layer))

    for mod in string.gmatch(EoHS.get_image_modded(image_layer), "~%a*%b()") do
      local crop_width, crop_height = string.match(mod, "^~CROP%(%d*,%d*,(%d*),(%d*)%)")
      if crop_width then
        width = crop_width
        height = crop_height
      end
      local scale_width, scale_height = string.match(mod, "^~SCALE%((%d*),(%d*)%)")
      if scale_width then
        width = scale_width
        height = scale_height
      end
    end
    return EoHS.image_rect{ size={x=width,y=height}, offset=EoHS.full_image_layer_reference(image_layer).offset }
  end
end

EoHS.translate_offset = function(offset, offset_offset)
  offset.x = offset.x + (offset_offset.x or 0)
  offset.y = offset.y + (offset_offset.y or 0)
end

local is_layer_list = function(image_aggregate)
  return (type(image_aggregate) == "table") and not image_aggregate.image_modded
end
local layers = function(image_aggregate)
  if is_layer_list(image_aggregate) then return ipairs(image_aggregate) end
  local done = false
  return function()
    if done then return nil end
    return 1,image_aggregate
  end
end

EoHS.image_aggregate_translated = function(image_aggregate, offset)
  if is_layer_list(image_aggregate) then
    local result = {}
    for i,layer in ipairs(image_aggregate) do
      table.insert(result, EoHS.image_aggregate_translated(layer, offset))
    end
    return result
  else
    local result = EoHS.full_image_layer_copy(image_aggregate)
    EoHS.translate_offset(result.offset, offset)
    return result
  end
end

local image_aggregate_cropped_or_masked = function(image_aggregate, crop_extents, mask_layer, negate)
  if is_layer_list(image_aggregate) then
    local result = {}
    for i,layer in ipairs(image_aggregate) do
      local layer_result = image_aggregate_cropped_or_masked(layer, crop_extents, mask_layer, negate)
      for i,layer2 in layers(layer_result) do
        table.insert(result, layer2)
      end
    end
    return result
  else
    local extents = EoHS.image_aggregate_extents(image_aggregate)
    local cropped_extents = EoHS.image_rect_intersection(extents, crop_extents)
    if negate then
      if mask_layer then EoHS.err("image_aggregate_cropped_or_masked can't negate a mask") end
      if not EoHS.image_rect_is_anywhere(cropped_extents) then
        return EoHS.full_image_layer_copy(image_aggregate)
      elseif EoHS.image_rects_are_equal(extents, cropped_extents) then
        return {}
      else
        local result = {}
        local do_rect = function(rect)
          local layers = image_aggregate_cropped_or_masked(image_aggregate, EoHS.image_rect(rect))
          EoHS.assert(#layers==1, "image_aggregate_cropped_or_masked unexpected behavior")
          for i,layer in layers(layers) do
            table.insert(result, layer)
          end
        end
        if cropped_extents.min.x > extents.min.x then
          do_rect{ min=extents.min, max={x=cropped_extents.min.x-1,y=extents.max.y} }
        end
        if cropped_extents.max.x < extents.max.x then
          do_rect{ min={x=cropped_extents.max.x+1,y=extents.min.y}, max=extents.min }
        end
        if cropped_extents.min.y > extents.min.y then
          do_rect{ min={x=cropped_extents.min.x,y=extents.min.y}, max={x=cropped_extents.max.x,y=cropped_extents.min.y-1} }
        end
        if cropped_extents.max.y < extents.max.y then
          do_rect{ min={x=cropped_extents.min.x,y=cropped_extents.max.y+1}, max={x=cropped_extents.max.x,y=extents.max.y} }
        end
        return result
      end
    else
      if not EoHS.image_rect_is_anywhere(cropped_extents) then
        return {}
      elseif EoHS.image_rects_are_equal(extents, cropped_extents) then
        return EoHS.full_image_layer_copy(image_aggregate)
      else
        local result = EoHS.full_image_layer_copy(image_aggregate)
        result.image_modded = (result.image_modded.."~CROP("..
          (cropped_extents.min.x-extents.min.x)..","..
          (cropped_extents.min.y-extents.min.y)..","..
          (cropped_extents.size.x)..","..
          (cropped_extents.size.y)..")")
        EoHS.translate_offset(result.offset, {
          x = cropped_extents.offset.x-extents.offset.x,
          y = cropped_extents.offset.y-extents.offset.y,
        })
        if mask_layer then
          if (crop_extents.min.x < cropped_extents.min.x) or (crop_extents.min.y < cropped_extents.min.y) then
            -- Annoying: Have to crop the mask because negative coordinates don't work.
            mask_layer = image_aggregate_cropped_or_masked(mask_layer, cropped_extents)
          end
          result.image_modded = (result.image_modded.."~MASK("..mask_layer.image_modded..",0,0)")
        end
        return result
      end
    end
  end
end

EoHS.image_aggregate_cropped = function(image_aggregate, crop_params)
  return image_aggregate_cropped_or_masked(image_aggregate, EoHS.image_rect(crop_params))
end
EoHS.image_aggregate_split = function(image_aggregate, crop_params)
  local rect = EoHS.image_rect(crop_params)
  return image_aggregate_cropped_or_masked(image_aggregate, rect), image_aggregate_cropped_or_masked(image_aggregate, rect, nil, true)
end

EoHS.image_aggregate_masked = function(image_aggregate, mask_layer)
  return image_aggregate_cropped_or_masked(image_aggregate, EoHS.image_aggregate_extents(mask_layer), mask_layer)
end

EoHS.image_aggregate_combine = function(image_aggregate1, image_aggregate2)
  local result
  if is_layer_list(image_aggregate1) then
    result = EoHS.deep_copy(image_aggregate1)
  else
    result = {EoHS.deep_copy(image_aggregate1)}
  end
  for i,layer in ipairs(image_aggregate2) do
    table.insert(result, layer)
  end
  return result
end

local naive_blit_onto = function(image_layer1, image_layer2)
  local extents1 = EoHS.image_aggregate_extents(image_layer1)
  local extents2 = EoHS.image_aggregate_extents(image_layer2)
  image_layer1.image_modded = (image_layer1.image_modded.image_modded.."~BLIT("..
    (image_layer2.image_modded)..","..
    (extents2.min.x-extents1.min.x)..","..
    (extents2.min.y-extents1.min.y)..")")
end

EoHS.collapse_image_aggregate = function(image_aggregate, crop_params)
  local extents = EoHS.image_aggregate_extents(image_aggregate)
  if (extents.offset.x == 0) and (extents.offset.y == 0) then
    if not is_layer_list(image_aggregate) then
      return EoHS.get_image_modded(image_aggregate)
    else
      local first_layer_extents = EoHS.image_aggregate_extents(image_aggregate[1])
      if EoHS.image_rects_are_equal(first_layer_extents, extents) then
        local result = EoHS.get_image_modded(image_aggregate[1])
        for i,layer in ipairs(image_aggregate) do
          if i~=1 then naive_blit_onto(result, layer) end
        end
        return result
      end
    end
  end
  
  local balanced_extents = EoHS.image_rect_balanced(extents)
  local result = "misc/blank-hex.png~SCALE("..(balanced_extents.size.x)..","..(balanced_extents.size.y)..")"
  for i,layer in layers(image_aggregate) do
    naive_blit_onto(result, layer)
  end
  return result
end

  >>
[/lua]

