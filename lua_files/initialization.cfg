this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- initialization.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

EoHS.init_campaign = function(player_picks_settings)
  EoHS.begin_event(true, true) -- Most of the time we put these outside the function, directly in the [lua] code=,
  -- but here we want the campaign-initing command - the only thing called directly from WML -
  -- to be as short as possible.
  
  EoHS.set_variable("player_picks_settings", player_picks_settings)
  EoHS.set_variable("settings_inited", false)
  EoHS.set_variable("show_menu_item", false)
  wesnoth.fire("set_menu_item", {
    id = "EoHS_menu_item",
    image = "icons/scroll_red.png~SCALE(20,20)",
    description = _"EoHS actions",
    { "show_if", {
      { "variable", {
        name="EoHS.show_menu_item",
        boolean_equals="true",
      }}
    }},
    { "command", {
      { "lua", {
        code = [[--EoHS.menu_item_invoked
EoHS.begin_event(true, true)
EoHS.menu_item_invoked()
EoHS.end_event()]]
      }},
    }},
  })
  -- TODO: remove this before releasing
  wesnoth.fire("set_menu_item", {
    id = "EoHS_zdebug_menu_item",
    image = "icons/scroll_red.png~SCALE(20,20)~GS()~CS(-50,0,0)",
    description = _"EoHS debug mode",
    { "show_if", {
      { "variable", {
        name="EoHS.debug_mode",
        boolean_equals="false",
      }}
    }},
    { "command", {
      { "set_variable", {
        name = "EoHS.debug_mode", value = true
      }},
    }},
  })
  
  for side in ipairs(wesnoth.sides) do
    EoHS.init_side_variables(side)
    EoHS.set_side_variable(side, "persistent_variables", {})
  end
  
  local leaders = EoHS.get_units({ canrecruit=true, type="Red Mage" })
  for i,unit in ipairs(leaders) do
    EoHS.set_unit_variable(unit, "is_starting_wizard", true)
    EoHS.set_side_variable(unit.side, "original_nick", unit.name)
    if type(unit.name) == "string" then
      EoHS.set_side_variable(unit.side, "original_nick_hash", EoHS.sha1(unit.name))
    end
    local modifications = EoHS.force_subtag(unit, "modifications")
    local variables = EoHS.force_unit_variables(unit)
    local skillset = EoHS.get_unit_skillset(unit)
    variables.is_wizard = true
    table.insert(modifications, 1, {"trait",{
      id = "EoHS_wizard",
      name = _"wizard",
      description = _"This unit is immune to direct damage from spells, and it can only lose a quarter of its max hitpoints each time it's attacked. Beyond that, combat stops immediately.",
      --{ "effect", { apply_to="ellipse", ellipse="misc/ellipse-leader" } }, -- TODO remove in 1.11 as it's redundant with canrecruit=true
    }})
    EoHS.set_unit_dress_up_options(unit, EoHS.random_dress_up_options(unit))
    -- variables.is_mounted = true -- TODO remove
    -- table.insert(variables, {"mount",EoHS.create_wunit{type="Fire Dragon"}.__cfg}) -- TODO remove
    EoHS.update_all_type_adjustments(unit)
    unit.hitpoints = nil
    EoHS.put_unit(unit)
  end
  EoHS.init_scenario()
  
  EoHS.end_event()
end

-- Mega hack (could probably be housed in a different file if we want to shorten this one)
do
  local unit1_moused_over_x, unit1_moused_over_y
  local unit2_moused_over_x, unit2_moused_over_y
  local last_mouse_over_time
  local mouseover_counter = 0
  local update_off_turn_menu_invocation_hack = EoHS.filter_func(function()
    local time = EoHS.timestamp()
    if last_mouse_over_time and ((time - last_mouse_over_time) > 800) then
      mouseover_counter = 0
      unit1_moused_over_x = nil; unit1_moused_over_y = nil
      unit2_moused_over_x = nil; unit2_moused_over_y = nil
    end
    last_mouse_over_time = time
    local du = wesnoth.get_displayed_unit()
    if du then
      if (du.x == unit2_moused_over_x) and (du.y == unit2_moused_over_y) then
        -- Same as last time - do nothing.
      else
        if unit2_moused_over_x and unit1_moused_over_x and not ((du.x == unit1_moused_over_x) and (du.y == unit1_moused_over_y)) then
          -- Mousing to a third, different unit - reset
          mouseover_counter = 0
        end
        -- Otherwise, it's initial mousing or mousing back to the same unit, so we continue incrementing
        mouseover_counter = mouseover_counter + 1
        
        -- unit2 is the latest, unit1 is the previous one
        unit1_moused_over_x = unit2_moused_over_x
        unit1_moused_over_y = unit2_moused_over_y
        unit2_moused_over_x = du.x
        unit2_moused_over_y = du.y
        
        if mouseover_counter > 8 then
          mouseover_counter = 0
          EoHS.local_player_can_preselect_skills()
        end
      end
    end
  end)
  -- Not simply make_filter_func because we need to check the old context for the hack.
  _G.EoHS_update_off_turn_menu_invocation_hack = function()
    if (not EoHS.context) and (not EoHS.event_stack) then update_off_turn_menu_invocation_hack() end
    return false
  end
  EoHS.update_off_turn_menu_invocation_hack_ability = {"dummy",{ id="EoHS_update_off_turn_menu_invocation_hack", {"filter",{lua_function="EoHS_update_off_turn_menu_invocation_hack"}} }}
end

EoHS.at_init_scenario_funcs = {}
EoHS.at_init_scenario = function(func) table.insert(EoHS.at_init_scenario_funcs, func) end
EoHS.init_scenario = function()
  EoHS.standardize_units()
  for i,event in pairs(EoHS.events) do wesnoth.fire("event", event) end
  EoHS.set_variable("scenario_inited", true)
  EoHS.set_variable("scenario_vars", {})
  for i,func in ipairs(EoHS.at_init_scenario_funcs) do func() end
end

EoHS.init_settings = function()
  EoHS.set_variable("settings_inited", true)
  
  if EoHS.get_variable("player_picks_settings") then
    EoHS.current_player_picks_settings()
  else
    EoHS.set_variable("settings", EoHS.map_specific_default_settings())
  end
  
  EoHS.set_variable("show_menu_item", true)
  
  local local_player_has_something_to_preselect = false
  local leaders = EoHS.get_units({ EoHS.has_unit_variable("is_starting_wizard") })
  for i,unit in ipairs(leaders) do
    local settings = EoHS.get_wizard_settings(unit)
    local skillset = EoHS.get_unit_skillset(unit)
    EoHS.init_wizard_settings(settings)
    EoHS.init_skillset(skillset)
    local level = EoHS.get_wizard_setting(unit, "starting_level")
    EoHS.set_unit_variable(unit, "wizard_level", level)
    unit.type = EoHS.appropriate_wizard_unit_type("Mage", level)
    EoHS.update_all_type_adjustments(unit)
    unit.hitpoints = nil
    EoHS.set_unit_variable(unit, "mana", EoHS.unit_mana_cap(unit) or 0)
    EoHS.put_unit(unit)
    
    EoHS.do_only_on_client_controlling_human_side(unit.side, function()
      local_player_has_something_to_preselect = true
    end)
  end
  if local_player_has_something_to_preselect then
    EoHS.local_player_can_preselect_skills()
  end
end

table.insert(EoHS.events, {
  name = "preload",
  first_time_only = "no",
  { "insert_tag", {
    name = "command",
    variable = "EoHS.preload"
  }},
})

EoHS.next_scenario_initing_event_names = {
  "prestart", "start", "side_turn", "turn_refresh", "prerecruit", "recruit", "moveto"
  -- deliberately omitted: attack (because the combat events rely on the fact that they all exist before the combat),
  -- preload (because it could create different behavior after a load),
  -- side turn end (I don't know if the init relies on synchronization but I won't risk it)
}
EoHS.next_scenario_initing_event = function(name)
  return { "event", {
    name = name,
    id = "EoHS_next_scenario_initing_event_"..name,
    first_time_only = "no",
    { "filter_condition", {
      { "variable", {
        name = "EoHS.scenario_inited",
        boolean_equals = false
      }},
    }},
    { "insert_tag", {
      name = "command",
      variable = "EoHS.preload"
    }},
    { "lua", {
      code = [[--EoHS.next_scenario_initing_event("]]..name..[[")
EoHS.begin_event(true, true)
EoHS.init_scenario()
EoHS.end_event()]]
    }},
  }}
end

-- These events can normally be undone, so we don't want to trigger events on them unless we have to.
-- But we do want units to be standardized ASAP if the scenario does something!
-- We could standardize units in non-synchronized events too - or in moveto events and allow undoing -
--   but that doesn't seem worth the risk.
EoHS.selective_unit_standardization_event_names = {
  "moveto"
}
EoHS.selective_unit_standardization_event = function(name)
  return {
    name = name,
    first_time_only = "no",
    { "filter_condition", {
      { "have_unit", {
        EoHS.is_on_the_map,
        lua_function = "EoHS_standardize_wunit"
      }},
    }},
    { "lua", {
      code = [[--EoHS.selective_unit_standardization_event
EoHS.begin_event(true, true)
EoHS.standardize_units()
EoHS.end_event()]]
    }},
  }
end
for i,name in ipairs(EoHS.selective_unit_standardization_event_names) do
  table.insert(EoHS.events, EoHS.selective_unit_standardization_event(name))
end

EoHS.standardize_units = function()
  local units = EoHS.get_units({ EoHS.is_on_the_map })
  for i,unit in ipairs(units) do
    if EoHS.standardize_unit(unit) then EoHS.put_unit(unit) end
  end
end

--[[local opposite_filters = {
  self = "opponent",
  opponent = "self",
  attacker = "defender",
  defender = "attacker",
}]]
        --[[ Comment pulled out of standardize_unit so that standardize_unit is more readable:
          Mage Shield issues:
           Later comment:
             Whoops - (1) is simply incorrect, and for (2), there was an easier way to do it, which is that multiply=0 always zeroes the CTH.
             However, I'm leaving this code here in case I need it for something later.
           
            1) After an attack event, if another attack event invalidates the combat, then the attack_end event DOES NOT occur.
              So we'd prefer not to set any temporaries in the attack event that can't be fixed before they cause problems.
            2) If a slowing attack hits, we in fact CANNOT stop the slow effect or remove it before it reduces the next swing's damage.
              Therefore, we must make the attacks all miss. There's no way to override (for instance) magical, so we have to disable it.
              Due to (1), we don't want to remove it outright, only to modify it so that it fails to apply in attacks against Mage Shield.
              Thus, the filter:
              {"not",{ EoHS.has_unit_variable("unhittable") }}
              must be applied to all [chance_to_hit] specials, except for the special one that makes shielded units unhittable.
              But it's worse than that! The filter needed depends on the special's apply_to=. For any of the four normal values,
              I have to filter the opposite one, and for apply_to=both, I have to *split the special in two* so that I can
              stop them from hitting mage shields without changing the shielded unit's own chance to hit (or vice versa).
        ]]
        --[[if (special[1] == "chance_to_hit") and not (special[2].id = "EoHS_cant_hit_unhittable_units") then
          local required_filter = {"not",{ EoHS.has_unit_variable("unhittable") }}
          local add_to_filter = function(filter)
            -- The [not] has to be last - otherwise there could be an [or] after it
            local last = filter[1] and filter[#filter]
            if not (last and (last[1] == "not") and (EoHS.get_subtag_attribute(last[2], "filter_wml.variables.EoHS.unhittable") == true)) then
              table.insert(filter, required_filter)
              did_anything = true
            end
          end
          local apply_to = special[2].apply_to or "self"
          local opposite = opposite_filters[apply_to]
          if opposite then
            add_to_filter(EoHS.force_subtag(special[2], "filter_"..opposite))
          else
            EoHS.assert(apply_to=="both", "Found bad weapon special apply_to value")
            -- Interestingly, it doesn't matter which of the two axes we split it along. I find self/opponent more elegant though.
            local other_special = EoHS.deep_copy(special)
                  special[2].apply_to = "self"    ; table.insert(EoHS.force_subtag(      special[2], "filter_opponent"), required_filter)
            other_special[2].apply_to = "opponent"; table.insert(EoHS.force_subtag(other_special[2], "filter_self"    ), required_filter)
            table.insert(specials, other_special)
            did_anything = true
          end
        end]]

EoHS.make_filter_func("EoHS_standardize_wunit", function(wunit) EoHS.standardize_unit(wunit.__cfg) end)
EoHS.standardize_unit = function(unit)
  local subtag_ids = {}
  local did_anything = false
  -- TODO: don't have to put_unit everything standardize_unit does
  -- We set a bunch of unit attributes as variables
  -- so that the caching system can notice when they change.
  local variables = EoHS.force_unit_variables(unit)
  local unit_attribute_memory = EoHS.get_fake_subtag(variables, "unit_attribute_memory")
  if unit_attribute_memory.type ~= unit.type then
    variables.original_type = unit.type
    if unit_attribute_memory.type then
      EoHS.update_all_type_adjustments(unit) -- which calls standardize_unit again
      return true
    else
      unit_attribute_memory.type = unit.type
      did_anything = true
    end
  end
  local remember = function(varname)
    if unit_attribute_memory[varname] ~= unit[varname] then
      unit_attribute_memory[varname] = unit[varname]
      did_anything = true
    end
  end
  remember("gender"); remember("variation"); remember("image"); remember("side"); remember("underlying_id")
  local resistance_memory = EoHS.get_fake_subtag(unit_attribute_memory, "resistance")
  local resistance = EoHS.get_subtag(unit, "resistance")
  local resistance_changed = false
  for k,v in pairs(resistance) do
    if resistance_memory[k] ~= v then
      resistance_memory[k] = v
      resistance_changed = true
      did_anything = true
    end
  end
  if resistance_changed then
    EoHS.update_circle_of_protection_ability(unit)
    --[[local abilities = EoHS.force_subtag(unit, "abilities")
    EoHS.remove_subtags(abilities, "resistance", "EoHS_circle_of_protection")
    for k,v in pairs(resistance) do
      table.insert(abilities, {"resistance",{
        id = "EoHS_circle_of_protection",
        apply_to = k,
        affect_self = true,
        active_on = "defense",
            value = 100-math.ceil(v/2),
        max_value = 100-math.ceil(v/2),
        {"filter",{
          lua_function="wunit_is_in_any_circle_of_protection"
        }}
      }})
    end]]
  end
  
  if not variables.original_name then
    variables.original_name = unit.name
    did_anything = true
  end
  local ability_ids = {}
  for i,subtag in ipairs(unit) do
    if subtag[2].id then subtag_ids[subtag[2].id] = true end
    if subtag[1] == "attack" then
      local special_ids = {}
      local specials = EoHS.force_subtag(subtag[2], "specials")
      for i,special in ipairs(specials) do
        if special[2].id then special_ids[special[2].id] = true end
      end
      for i,special in ipairs(EoHS.universal_attack_specials) do
        if not special_ids[special[2].id] then
          table.insert(specials, special)
          did_anything = true
        end
      end
    end
    if subtag[1] == "abilities" then for i,ability in ipairs(subtag[2]) do if ability[2].id then ability_ids[ability[2].id] = true end end end
  end
  for i,name in ipairs(EoHS.next_scenario_initing_event_names) do
    if not subtag_ids["EoHS_next_scenario_initing_event_"..name] then
      table.insert(unit, EoHS.next_scenario_initing_event(name))
      did_anything = true
    end
  end
  if not ability_ids.EoHS_update_off_turn_menu_invocation_hack then
    table.insert(EoHS.force_subtag(unit, "abilities"), EoHS.update_off_turn_menu_invocation_hack_ability)
  end
  if EoHS.update_mount_hitpoints(unit) then did_anything = true end
  if EoHS.update_unit_graphics(unit) then did_anything = true end -- too slow? TODO evaluate speed of standardize_unit, decide whether to rely on it regenerating stuff...
  return did_anything
end


local scenario_over_event = function()
  EoHS.standardize_units()
  EoHS.set_variable("show_menu_item", false)
  EoHS.set_variable("scenario_inited", false)
  --EoHS.set_variable("scenario_vars")
  for side in ipairs(wesnoth.sides) do
    EoHS.score_for_side_completing_game(side)
  end
  EoHS.score_for_game_ending()
end
EoHS.set_simple_event("victory", true, true, scenario_over_event)
EoHS.set_simple_event("defeat", true, true, scenario_over_event)

local units_func_context = function()
  local funcs = {}
  return function(variable, func) table.insert(funcs, {func=func or variable,variable=func and variable}) end, function(units)
    units.with_variable = {}
    for i,unit in ipairs(units) do
      local variables = EoHS.get_unit_variables(unit)
      for i,func in ipairs(funcs) do if func.variable and variables[func.variable] then
        if units.with_variable[func.variable] then table.insert(units.with_variable[func.variable], unit)
        else units.with_variable[func.variable] = {unit} end
      end end
    end
    for i,func in pairs(funcs) do func.func(units) end
  end
end
local do_side_turn_funcs; EoHS.at_side_turn, do_side_turn_funcs = units_func_context()
EoHS.set_simple_event("side_turn", true, true, function()
  local init_needed = not EoHS.get_variable("settings_inited")
  EoHS.update_and_share_persistent_variables_of_current_side(init_needed)
  if init_needed then EoHS.init_settings() end
  
  local units = EoHS.get_units({ EoHS.is_on_the_map })
  for i,unit in ipairs(units) do
    local put = false
    if EoHS.standardize_unit(unit) then put = true end
    if EoHS.get_unit_variable(unit, "best_max_moves_this_turn") then
      EoHS.set_unit_variable(unit, "best_max_moves_this_turn")
      put = true
    end
    if unit.side == wesnoth.current.side then
      if EoHS.earn_mana_income(unit) then put = true end
      if EoHS.get_unit_variable(unit, "extra_action_points") ~= 5 then
        EoHS.set_unit_variable(unit, "extra_action_points", 5)
        put = true
      end
    end
    if put then EoHS.put_unit(unit) end
  end
  do_side_turn_funcs(units)
end)
local do_turn_refresh_funcs; EoHS.at_turn_refresh, do_turn_refresh_funcs = units_func_context()
EoHS.set_simple_event("turn_refresh", true, true, function()
  if EoHS.get_variable("client_local_preselect_side_turn") == wesnoth.current.side then
    EoHS.set_variable("client_local_preselect_side_turn")
    EoHS.local_player_can_preselect_skills()
  end
  
  EoHS.handle_non_EoHS_terrain_changes("absolute")
  EoHS.update_terrain_changes()
  local units = EoHS.get_units({ EoHS.is_on_the_map })
  for i,unit in ipairs(units) do
    if EoHS.standardize_unit(unit) then EoHS.put_unit(unit) end
  end
  
  do_turn_refresh_funcs(units)
  
  local prepared_trainings = EoHS.synchronize_choice(function()
    local result = {}
    local side_trainings = EoHS.client_local_trainings[wesnoth.current.side]
    if side_trainings then for k,v in pairs(side_trainings) do
      if v.training then table.insert(result, {"training", v.training}) end
      if v.dress_up then table.insert(result, {"dress_up", v.dress_up}) end
    end end
    EoHS.client_local_trainings[wesnoth.current.side] = nil
    return result
  end, function() return {ai=true} end)
  if prepared_trainings.ai then
    EoHS.set_side_variable(wesnoth.current.side, "was_ever_ai", true)
    for i,unit in ipairs(units) do
      if (unit.side == wesnoth.current.side) and EoHS.get_unit_variable(unit, "is_wizard") then
        if EoHS.choose_alliance_for_ai(unit) then EoHS.put_unit(unit) end
      end
    end
  else
    -- TODO: un-duplicate code with menu.cfg
    for i,instruction in ipairs(prepared_trainings) do
      if instruction[1] == "training" then
        local unit = EoHS.get_unit(instruction[2].trainer_id)
        EoHS.train_unit_to_skillset(unit, instruction[2])
        EoHS.put_unit(unit)
      end
      if instruction[1] == "dress_up" then
        local unit = EoHS.get_unit(instruction[2].dresser_id)
        EoHS.set_unit_dress_up_options(unit, instruction[2])
        EoHS.update_unit_graphics(unit)
        EoHS.put_unit(unit)
      end
    end
  end
end)
local do_side_turn_end_funcs; EoHS.at_side_turn_end, do_side_turn_end_funcs = units_func_context()
EoHS.set_simple_event("side_turn_end", true, false, function()
  -- can't, side turn end events aren't synced
  --EoHS.update_and_share_persistent_variables_of_current_side()
  EoHS.handle_non_EoHS_terrain_changes("relative")
  local units = EoHS.get_units({ EoHS.is_on_the_map })
  for i,unit in ipairs(units) do
    local put = false
    local kill = false
    if EoHS.standardize_unit(unit) then put = true end
    if unit.side == wesnoth.current.side then
      local disappears_after_turns = EoHS.get_unit_variable(unit, "disappears_after_turns")
      if disappears_after_turns then
        if disappears_after_turns <= 0 then
          kill = true
        else
          EoHS.set_unit_variable(unit, "disappears_after_turns", disappears_after_turns - 1)
          EoHS.update_summon_trability_info(unit, true)
          if disappears_after_turns < EoHS.max_summon_duration_overlays then
            EoHS.remove_a_summon_duration_overlay(unit)
          end
          put = true
        end
      end
    end
    if kill then wesnoth.fire("kill", {x=unit.x,y=unit.y,animate=false,fire_event=false})
    else
      if put then EoHS.put_unit(unit) end
    end
  end
  do_side_turn_end_funcs(units)
end)
EoHS.set_simple_event("advance", true, true, function()
  local unit = EoHS.at_beginning_of_event_get_autostored_unit("unit")
  if EoHS.do_special_advancement_next(unit) then
    EoHS.set_unit_variable(unit, "do_special_advancement_next", true)
    EoHS.put_unit(unit)
  end
end)
EoHS.set_simple_event("post_advance", true, true, function()
  local unit = EoHS.at_beginning_of_event_get_autostored_unit("unit")
  local do_special_advancement = EoHS.get_unit_variable(unit, "do_special_advancement_next")
  if do_special_advancement then
    EoHS.set_unit_variable(unit, "do_special_advancement_next")
    if EoHS.get_unit_variable(unit, "is_summon") then
      EoHS.set_unit_variable(unit, "advanced_as_summon", unit.type)
    end
    if EoHS.get_unit_variable(unit, "is_wizard") then
      EoHS.set_unit_variable(unit, "wizard_level", (EoHS.get_unit_variable(unit, "wizard_level") or unit.level) + 1)
    end
  end
  if not EoHS.get_unit_variable(unit, "spiritform") then EoHS.set_unit_variable(unit, "original_type", unit.type) end
  EoHS.update_all_type_adjustments(unit) -- This calls standardize_unit
  if do_special_advancement then
    -- It seems that when a unit levels up into its own type, it doesn't get fully healed.
    -- This behavior is undesirable.
    unit.hitpoints = unit.max_hitpoints
  end
  EoHS.put_unit(unit)
end)
EoHS.set_simple_event("prerecruit", true, true, function()
  local unit = EoHS.at_beginning_of_event_get_autostored_unit("unit")
  EoHS.standardize_unit(unit)
  
  if (unit.type == "Pirate Galleon") or (unit.type == "Transport Galleon") then
    local modifications = EoHS.force_subtag(unit, "modifications")
    table.insert(modifications, {"trait",{
      id="EoHS_portable",
      name=_"portable",
      description=_"EoHS ships can be ported slowly across land, so that it's not so arbitrary whether your castle is connected to water.",
      {"effect",{
        apply_to="movement_costs",
        replace=true,
        {"movement_costs",{
          -- omitting only impassable, chasms, and mountains, which many units can't cross anyway.
          flat=unit.max_moves, fungus=unit.max_moves, village=unit.max_moves,
          sand=unit.max_moves, forest=unit.max_moves, hills  =unit.max_moves,
          cave=unit.max_moves, frozen=unit.max_moves, castle = 2,
        }}
      }},
      {"effect",{
        apply_to="defense",
        replace=true,
        {"defense",{
          castle = 60,
        }}
      }},
    }})
  end
  --EoHS eliminates upkeep
  if not EoHS.get_unit_variable(unit, "is_summon") then
    local modifications = EoHS.force_subtag(unit, "modifications")
    table.insert(modifications, EoHS.macros.TRAIT_LOYAL[1])
  end

  EoHS.put_unit(unit)
end)

-->>)}
