this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- utils-ui.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

EoHS.give_alert = function()
  wesnoth.play_sound("bell.wav")
end

EoHS.message = function(string)
  -- Doesn't use side= to decide who it's shown to; instead, we just use this function
  -- in a disunified manner (especially since we sometimes want to show different messages
  --   to different players, not just binary show/not show.)
  wesnoth.fire("chat", { speaker = "EoHS", message = string })
  -- TODO: add timestamps
  EoHS.set_variable("message_log", (EoHS.get_variable("message_log") or "")..(
    EoHS.substitute(_"Turn $1|, side $2|: ", {wesnoth.current.turn, wesnoth.current.side})..string.."\n"
  ))
end

EoHS.place_item = function(item)
  -- TODO: consider redraw
  wesnoth.fire("item", item)
  local items = EoHS.get_hex_variable(item.x, item.y, "items") or {}
  table.insert(items, {"item",item})
  EoHS.set_hex_variable(item.x, item.y, "items", items)
end
EoHS.remove_item = function(item)
  wesnoth.fire("remove_item", {x=item.x,y=item.y,image=(item.image or item.halo)})
  local items = EoHS.get_hex_variable(item.x, item.y, "items")
  EoHS.remove_subtags(items, "item", function(i) return (i.image == item.image) or (i.halo == item.halo) end)
  EoHS.set_hex_variable(item.x, item.y, "items", items)
end
EoHS.get_items = function(x,y)
  return EoHS.get_hex_variable(x, y, "items")
end

do
  local old_view_locked = false
  local EoHS_lock_counter = 0
  EoHS.lock_view = function()
    if not wesnoth.lock_view then return end
    if EoHS_lock_counter == 0 then
      old_view_locked = wesnoth.view_locked and wesnoth.view_locked()
      if not old_view_locked then wesnoth.lock_view(true) end
    end
    EoHS_lock_counter = EoHS_lock_counter + 1
  end
  EoHS.unlock_view = function()
    if not wesnoth.lock_view then return end
    EoHS_lock_counter = EoHS_lock_counter - 1
    if EoHS_lock_counter == 0 then
      if not old_view_locked then wesnoth.lock_view(false) end
    end
  end
end

local function is_even(v) return (v % 2) == 0 end
EoHS.pixels_to_hex = function(x1, y1, x2, y2)
  return 54*(x2 - x1), 72*(y2 - y1) + (is_even(x2) and 36 or 0) - (is_even(x1) and 36 or 0)
end

EoHS.if_has_total_knowledge_of_side = function(side, then_func, else_func)
  return EoHS.disunified(function()
    local controls_any, controls_knower
    for side2,info in ipairs(wesnoth.sides) do
      if info.controller ~= "network" then
        controls_any = true
        if (info.controller == "human") or (info.controller == "human_ai") then
          if not wesnoth.is_enemy(side, side2) then controls_knower = true; break end
          if not (info.fog or info.shroud) then controls_knower = true; break end
        end
      end
    end
    if controls_knower or not controls_any then
      return then_func()
    else
      return else_func and else_func()
    end
  end)
end

EoHS.add_temporary_anims = function(unit, anims)
  anims.apply_to = "new_animation"
  local adjust_func = EoHS.unit_animation_adjustments(unit)
  for i,anim in ipairs(anims) do adjust_func(anim) end
  table.insert(EoHS.force_subtag(unit, "modifications"), {"object",{id="EoHS_temporary_anims",
    {"effect",anims},
  }})
end
EoHS.remove_temporary_anims = function(unit)
  EoHS.remove_subtags(unit, "modifications.object", "EoHS_temporary_anims")
end

local anim_x = function(a) return a.x or (a.unit and a.unit.x) or EoHS.get_subtag(a, "filter").x end
local anim_y = function(a) return a.y or (a.unit and a.unit.y) or EoHS.get_subtag(a, "filter").y end
EoHS.animate_units = function(tables, extras)
  if not tables[1] then return end
  local min_x,min_y,max_x,max_y
  local units_modified = {}
  for i,t in ipairs(tables) do
    t.x = anim_x(t)
    t.y = anim_y(t)
    table.insert(t, {"filter",{x=t.x, y=t.y}})
    if not (min_x and (min_x <= t.x)) then min_x = t.x end
    if not (min_y and (min_y <= t.y)) then min_y = t.y end
    if not (max_x and (max_x >= t.x)) then max_x = t.x end
    if not (max_y and (max_y >= t.y)) then max_y = t.y end
  end
  local centerness = function(t)
    return math.abs((t.x - min_x) * (t.y - min_y) * (t.x - max_x) * (t.y - max_y))
  end
  local centermost_idx
  local best_score
  for i,t in ipairs(tables) do
    local score = centerness(t)
    if not (best_score and (best_score >= score)) then
      best_score = score
      centermost_idx = i
    end
  end
  -- The animation will play wherever the centermost unit is.
  -- The game will scroll there automatically. BUT... while it scrolls, the units appear
  --   at their actual location, which might be bad - we use this for swarm movement,
  --   and the swarms cannot start at their starting location because there might also
  --   be a non-swarm unit there.
  -- So we preempt the problem by scrolling there ahead of time.
  EoHS.lock_view()
  wesnoth.scroll_to_tile(tables[centermost_idx].x, tables[centermost_idx].y, true)
  if extras and extras.after_scrolling then extras.after_scrolling() end
  for i,t in ipairs(tables) do
    if t.animation then
      local unit = t.unit or EoHS.get_unit(t.x,t.y)
      EoHS.assert(unit, "EoHS.animate_units given a location with no unit")
      table.insert(units_modified, unit)
      local anim = t.animation
      t.animation = nil
      t.flag = "EoHS_animate_units"
      anim.apply_to = "EoHS_animate_units"
      EoHS.add_temporary_anims(unit, { {"animation",anim} })
      local put_extras = extras and extras.put_extras or {}
      put_extras.immediate=true
      EoHS.put_unit(unit, put_extras)
    end
    t.x = nil
    t.y = nil
    t.unit = nil
  end
  local anim_tag = tables[centermost_idx]
  for i,t in ipairs(tables) do
    if i ~= centermost_idx then table.insert(anim_tag, {"animate",t}) end
  end
  wesnoth.fire("animate_unit", anim_tag)
  EoHS.unlock_view()
  for i,unit in ipairs(units_modified) do
    EoHS.remove_temporary_anims(unit)
    EoHS.put_unit(unit)
  end
end

EoHS.parallel_attacks = function(attacks)
  EoHS.shuffle(attacks)
  for i,attack in ipairs(attacks) do
    attack.extras.animate = false
    EoHS.game_action_simulations.attack_unit(attack.context, attack.extras)
  end
  
  local original_units = {}
  local round = 1
  while true do
    local any = false
    local anims = {}
    local anim_xys = {} -- Hack - only play one animation from each location
    local unit_xys = {} -- TODO deal with the facing issue
    for i,attack in ipairs(attacks) do
      local a = attack.extras.animation_rounds[round]
      if a then
        any = true
        for i,thing in ipairs(a) do
          if type(thing) == "function" then
            thing()
          else
            local xy = anim_x(thing)..","..anim_y(thing)
            if thing.type then unit_xys[xy] = thing
            else
              if not anim_xys[xy] then
                anim_xys[xy] = true
                table.insert(anims, thing)
              end
            end
          end
        end
      end
    end
    
    if not any then break end
    for k,v in pairs(unit_xys) do
      local xy = v.x..","..v.y
      if not original_units[xy] then
        local unit = EoHS.get_unit(v.x, v.y)
        original_units[xy] = unit or {type="remove_unit", x=v.x, y=v.y}
      end
      if v.type == "remove_unit" then EoHS.remove_unit(v.x,v.y)
      else EoHS.put_unit(v, {allow_unknown_id=true, allow_new_location=true, allow_overwrite=true, immediate=true}) end
    end
    EoHS.animate_units(anims)
    round = round + 1
  end
  
  for k,v in pairs(original_units) do
    if v.type == "remove_unit" then EoHS.remove_unit(v.x,v.y)
    else EoHS.put_unit(v, {allow_unknown_id=true, allow_new_location=true, allow_overwrite=true, immediate=true}) end
  end
end

-->>)}
