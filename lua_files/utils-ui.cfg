this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- utils-ui.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

local w111 = wesnoth.compare_versions(wesnoth.game_config.version, ">=", "1.11.0")

EoHS.give_alert = function()
  wesnoth.play_sound("bell.wav")
end

EoHS.redraw = function()
  -- "redraw" by itself apparently doesn't yield to the wesnoth UI hard enough.
  wesnoth.fire ("redraw")
  wesnoth.fire ("delay",{time = 10})
  wesnoth.fire ("redraw")
end

EoHS.message = function(string)
  -- Doesn't use [chat] side= to decide who it's shown to; instead, we just use this function
  -- in a disunified manner (especially since we sometimes want to show different messages
  --   to different players, not just binary show/not show.)
  string = EoHS.substitute("$1|", {string}) -- wesnoth.message can't take tstrings, so convert them
  wesnoth.message("EoHS", string)
  -- TODO: add timestamps
  EoHS.set_variable("message_log", (EoHS.get_variable("message_log") or "")..(
    EoHS.substitute(_"Turn $1|, side $2|: ", {wesnoth.current.turn, wesnoth.current.side})..string.."\n"
  ))
end

EoHS.place_item = function(item)
  if item.redraw == nil then item.redraw = false end
  wesnoth.fire("item", item)
  local items = EoHS.get_hex_variable(item.x, item.y, "items") or {}
  table.insert(items, {"item",item})
  EoHS.set_hex_variable(item.x, item.y, "items", items)
end
EoHS.remove_item = function(item)
  local items = EoHS.get_hex_variable(item.x, item.y, "items")
  if not items then return end
  local num_found = 0
  EoHS.remove_subtags(items, "item", function(i)
    if (i.image == item.image) and (i.halo == item.halo) then
      num_found = num_found + 1
      if num_found == 1 then
        return true
      end
    end
  end)
  if num_found == 1 then
    wesnoth.fire("remove_item", {x=item.x,y=item.y,image=(item.image or item.halo)})
  end
  EoHS.set_hex_variable(item.x, item.y, "items", items)
end
EoHS.get_items = function(x,y)
  return EoHS.get_hex_variable(x, y, "items")
end

EoHS.wrap_line = function (text, max_width, extras)
  local result
  text = text.." "
  local line = string.rep (" ", extras.starting_indentation or 0)
  for word in string.gmatch (text, "[^%s]*%s") do
    local proposed_line = line..word
    if string.len (proposed_line) <= max_width+1 then
      line = proposed_line
    else
      result = (result and result.."\n" or "")..string.sub (line, 1, -2)
      line = string.rep (" ", extras.subsequent_indentation or 0)..word
    end
  end
  return (result and result.."\n" or "")..string.sub (line, 1, -2)
end

EoHS.wrap_text = function (text, max_width, extras)
  text = text.."\n"
  local result = ""
  for line in string.gmatch (text, "([^\n]*)\n") do
    result = result..EoHS.wrap_line(line, max_width, extras).."\n"
  end
  return string.sub (result, 1, -2)
end

do
  local old_view_locked = false
  local EoHS_lock_counter = 0
  EoHS.lock_view = function()
    if not wesnoth.lock_view then return end
    if EoHS_lock_counter == 0 then
      old_view_locked = wesnoth.view_locked and wesnoth.view_locked()
      if not old_view_locked then wesnoth.lock_view(true) end
    end
    EoHS_lock_counter = EoHS_lock_counter + 1
  end
  EoHS.unlock_view = function()
    if not wesnoth.lock_view then return end
    EoHS_lock_counter = EoHS_lock_counter - 1
    if EoHS_lock_counter == 0 then
      if not old_view_locked then wesnoth.lock_view(false) end
    end
  end
end

local function is_even(v) return (v % 2) == 0 end
EoHS.pixels_to_hex = function(x1, y1, x2, y2)
  return 54*(x2 - x1), 72*(y2 - y1) + (is_even(x2) and 36 or 0) - (is_even(x1) and 36 or 0)
end

EoHS.show_unit_type_help = function(type_id)
  wesnoth.fire("open_help", {topic=(EoHS.get_unit_type(type_id).hide_help and "." or "").."unit_"..type_id})
end

EoHS.if_has_total_knowledge_of_side = function(side, then_func, else_func)
  return EoHS.disunified(function()
    local controls_any, controls_knower
    for side2,info in ipairs(wesnoth.sides) do
      if (info.controller == "human") or (info.controller == "human_ai") then
        controls_any = true
        if not wesnoth.is_enemy(side, side2) then controls_knower = true; break end
        if not (info.fog or info.shroud) then controls_knower = true; break end
      end
    end
    if controls_knower or not controls_any then
      return then_func()
    else
      return else_func and else_func()
    end
  end)
end

EoHS.menu_rectangle_aggregate = function(base, w, h)
  -- TODO don't double up corner shadows
  base = "dialogs/"..base.."-"
  local offsx = w/2 - 1
  local offsy = h/2 - 1
  local blit = function(ext, x, y, xscale, yscale)
    local image = base..ext..".png"
    local ew,eh = wesnoth.get_image_size(image)
    if xscale then ew = w end
    if yscale then eh = h end
    return "~BLIT("..image.."~SCALE("..ew..","..eh.."),"..(4+x*(4+w-ew))..","..(4+y*(4+h-eh))..")"
  end
  return "misc/blank-hex.png~SCALE("..(w+8)..","..(h+8)..")"..
    blit("background"   , 0, 0, true,  true)..
    blit("border-left"  , 0, 0, false, true)..
    blit("border-right" , 1, 0, false, true)..
    blit("border-top"   , 0, 0, true, false)..
    blit("border-bottom", 0, 1, true, false)..
    blit("border-topleft" , 0, 0)..
    blit("border-topright", 1, 0)..
    blit("border-botleft" , 0, 1)..
    blit("border-botright", 1, 1)
end

EoHS.add_temporary_anims = function(unit, anims)
  anims.apply_to = "new_animation"
  local adjust_func = EoHS.unit_animation_adjustments(unit)
  for i,anim in ipairs(anims) do adjust_func(anim) end
  table.insert(EoHS.force_subtag(unit, "modifications"), {"object",{id="EoHS_temporary_anims",
    {"effect",anims},
  }})
end
EoHS.remove_temporary_anims = function(unit)
  EoHS.remove_subtags(unit, "modifications.object", "EoHS_temporary_anims")
end

EoHS.animate_unit = function(anim_table, options)
  -- If we don't redraw first, the animation lags enough that it essentially starts in the middle
  --   or is skipped entirely. The redraw clears that behavior.
  if not (options and options.dont_redraw_first) then EoHS.redraw() end
  wesnoth.fire("animate_unit", anim_table)
end

local anim_x = function(a) return a.x or (a.unit and a.unit.x) or EoHS.get_subtag(a, "filter").x end
local anim_y = function(a) return a.y or (a.unit and a.unit.y) or EoHS.get_subtag(a, "filter").y end
EoHS.animate_units = function(tables, extras)
  if not tables[1] then
    if extras and extras.after_scrolling then
      extras.after_scrolling()
      return
    end
  end
  local min_x,min_y,max_x,max_y
  local units_modified = {}
  for i,t in ipairs(tables) do
    t.x = anim_x(t)
    t.y = anim_y(t)
    table.insert(t, {"filter",{x=t.x, y=t.y}})
    if not (min_x and (min_x <= t.x)) then min_x = t.x end
    if not (min_y and (min_y <= t.y)) then min_y = t.y end
    if not (max_x and (max_x >= t.x)) then max_x = t.x end
    if not (max_y and (max_y >= t.y)) then max_y = t.y end
  end
  local centerness = function(t)
    return math.abs((t.x - min_x) * (t.y - min_y) * (t.x - max_x) * (t.y - max_y))
  end
  local centermost
  if extras and extras.force_center then
    for i,t in ipairs(tables) do
      if (anim_x(t) == extras.force_center.x) and (anim_y(t) == extras.force_center.y) then
        centermost = t
      end
    end
    if not centermost then
      centermost = {
        flag = "EoHS_animate_units_dummy",
        with_bars = false,
        x=extras.force_center.x, y=extras.force_center.y,
        {"filter",{x=extras.force_center.x, y=extras.force_center.y}},
      }
      table.insert(tables, centermost)
    end
  else
    local best_score
    for i,t in ipairs(tables) do
      local score = centerness(t)
      if not (best_score and (best_score >= score)) then
        best_score = score
        centermost = t
      end
    end
  end
  -- The animation will play wherever the centermost unit is.
  -- The game will scroll there automatically. BUT... while it scrolls, the units appear
  --   at their actual location, which might be bad - we use this for swarm movement,
  --   and the swarms cannot start at their starting location because there might also
  --   be a non-swarm unit there.
  -- So we preempt the problem by scrolling there ahead of time.
  EoHS.lock_view()
  EoHS.redraw()
  wesnoth.scroll_to_tile(centermost.x, centermost.y, true)
  if extras and extras.after_scrolling then extras.after_scrolling() end
  for i,t in ipairs(tables) do
    if t.animation then
      local unit = t.unit or EoHS.get_unit(t.x,t.y)
      EoHS.assert(unit, "EoHS.animate_units given a location with no unit")
      table.insert(units_modified, unit)
      local anim = t.animation
      t.animation = nil
      t.flag = "EoHS_animate_units"
      anim.apply_to = "EoHS_animate_units"
      EoHS.add_temporary_anims(unit, { {"animation",anim} })
      local put_extras = extras and extras.put_extras or {}
      put_extras.immediate=true
      EoHS.put_unit(unit, put_extras)
    end
    t.x = nil
    t.y = nil
    t.unit = nil
  end
  local anim_tag = centermost
  for i,t in ipairs(tables) do
    if t ~= centermost then table.insert(anim_tag, {"animate",t}) end
  end
  local proxy_unit = false
  if centermost.flag == "EoHS_animate_units_dummy" and not wesnoth.get_unit (extras.force_center.x, extras.force_center.y) then
    proxy_unit = true
    wesnoth.put_unit({
      type="Fog Clearer",
      x=extras.force_center.x,
      y=extras.force_center.y,
      side=1,
    })
    wesnoth.fire("hide_unit", {x=extras.force_center.x, y=extras.force_center.y})
  end
  wesnoth.fire("animate_unit", anim_tag)
  if proxy_unit then
    wesnoth.put_unit(extras.force_center.x, extras.force_center.y)
  end
  EoHS.unlock_view()
  for i,unit in ipairs(units_modified) do
    EoHS.remove_temporary_anims(unit)
    EoHS.put_unit(unit)
  end
end

EoHS.parallel_attacks = function(attacks, animation_extras)
  for i,attack in ipairs(attacks) do
    attack.extras.animate = false
    EoHS.game_action_simulations.attack_unit(attack.context, attack.extras)
  end
  
  EoHS.redraw_unexpected = true
  
  local original_units = {}
  local round = 1
  while true do
    local any = false
    local anims = {}
    local anim_xys = {} -- Hack - only play one animation from each location
    local unit_xys = {} -- TODO deal with the issue where one-attacking-many ends up with the one facing in various directions, which looks odd
    for i,attack in ipairs(attacks) do
      local a = attack.extras.animation_rounds[round]
      if a then
        any = true
        for i,thing in ipairs(a) do
          if type(thing) == "function" then
            thing()
          else
            local xy = anim_x(thing)..","..anim_y(thing)
            if thing.type then unit_xys[xy] = thing
            else
              if not anim_xys[xy] then
                anim_xys[xy] = true
                table.insert(anims, thing)
              end
            end
          end
        end
      end
    end
    
    if not any then break end
    for k,v in pairs(unit_xys) do
      local xy = v.x..","..v.y
      if not original_units[xy] then
        local unit = EoHS.get_unit(v.x, v.y)
        original_units[xy] = unit or {type="remove_unit", x=v.x, y=v.y}
      end
      if v.type == "remove_unit" then EoHS.remove_unit(v.x,v.y)
      else EoHS.put_unit(v, {allow_unknown_id=true, allow_new_location=true, allow_overwrite=true, immediate=true}) end
    end
    EoHS.redraw_unexpected = nil
    EoHS.animate_units(anims, animation_extras)
    EoHS.redraw_unexpected = true
    round = round + 1
  end
  EoHS.redraw_unexpected = nil
  for k,v in pairs(original_units) do
    if v.type == "remove_unit" then EoHS.remove_unit(v.x,v.y)
    else EoHS.put_unit(v, {allow_unknown_id=true, allow_new_location=true, allow_overwrite=true, immediate=true}) end
  end
end
EoHS.parallel_attacks_or_animate_once = function(parameters, attacks)
  local actor = EoHS.get_unit(parameters.actor_id)
  if attacks[1] then
    EoHS.parallel_attacks(attacks, {force_center={x=parameters.target_x,y=parameters.target_y}})
  else
    EoHS.animate_units({{
      flag="attack",
      {"filter",{x=actor.x,y=actor.y}},
      hits = true,
      with_bars = true,
    }}, {force_center={x=parameters.target_x,y=parameters.target_y}})
  end
end

EoHS.dump_server_pbl = function(passphrase)
  -- TODO: description can't be translatable?
  wesnoth.fire("wml_message", { logger="err", message=[[author="Elvish Pillager"
description="]]..tostring(EoHS.macros.EOHS_DESCRIPTION)..[["
email="web@elidupree.com"
icon="units/monsters/fire-dragon.png~BLIT(units/human-magi/great-mage.png~TC(2,magenta),72,30)~BLIT(units/monsters/fire-dragon.png~CROP(125,45,35,30),125,45)~BLIT(units/monsters/fire-dragon.png~CROP(108,70,52,130),108,70)~BLIT(halo/elven/ice-halo5.png,91,8)~CROP(72,34,72,72)~BLIT(misc/blank-hex.png~BG(0,0,0)~CROP(0,0,72,12),0,60)~BLIT(misc/font8x8.png~CROP(40,24,8,8)~CS(-255,0,-255),12,62)~BLIT(misc/font8x8.png~CROP(32,24,8,8)~CS(-255,0,-255),20,62)~BLIT(misc/font8x8.png~CROP(56,24,8,8)~CS(-255,0,-255),28,62)~BLIT(misc/font8x8.png~CROP(32,24,8,8)~CS(-255,0,-255),36,62)~BLIT(misc/font8x8.png~CROP(16,40,8,8)~CS(-255,0,-255),44,62)~BLIT(misc/font8x8.png~CROP(16,40,8,8)~CS(-255,0,-255),52,62)"
passphrase="]]..passphrase..[["
title="Era of High Sorcery"
type="era"
translate="true"
version="]]..EoHS.macros.EOHS_VERSION..[["
]]})
end

-- We need the crown overlay because otherwise the crown will go under the orb-recolorer, etc.
-- Other overlays work fine just by putting the orb-recolorer at the beginning of the list.
-- We don't worry about dumping stuff on top of other add-ons' overlays.
local no_attacks_overlay = w111 and "misc/orb.png~CS(-255,0,0)~O(0.5)" or "misc/orb-unmoved.png~CS(-255,-80,0)~O(0.5)"
local canrecruit_overlay = "misc/leader-crown.png"

local update_overlays_impl = function(unit,add,drop)
  local variables = EoHS.force_unit_variables(unit)
  local changed = false
  local clear_from = function (index)
    while true do
      local overlay = variables["overlay_"..index]
      if not overlay then break end
      drop(unit, overlay)
      variables["overlay_"..index] = nil
      changed = true
      index = index + 1
    end
  end
  
  local old_add = add
  local idx = 1
  add = function(overlay)
    local old_overlay = variables["overlay_"..idx]
    if old_overlay ~= overlay then
      changed = true
      clear_from (idx)
    end
    variables["overlay_"..idx] = overlay
    idx = idx + 1
    old_add(unit, overlay)
  end
  if (unit.side == wesnoth.current.side) and (wesnoth.sides[unit.side].controller == "human") and (unit.attacks_left == 0) then
    add(no_attacks_overlay)
  end
  if unit.canrecruit then add(canrecruit_overlay) end
  local add_var = function(varname)
    local overlay = variables[varname]
    if overlay then add(overlay) end
  end
  add_var("scroll_overlays")
  
  if variables["is_summon"] then add(EoHS.summon_overlay) end
  
  local duration = variables["disappears_after_turns"]
  if duration then
    for i=math.min(duration, EoHS.max_summon_duration_overlays-1),1,-1 do
      add("misc/blank-hex.png~BLIT("..EoHS.summon_overlay.."~SCALE(43,72)~CROP(0,0,43,"..(72-5*i).."),10,"..(5*i)..")")
    end
  end
  
  -- idx is now one beyond all the replaced overlays
  clear_from (idx)
  
  return changed
end

local drop_overlay_variable = function(unit, overlay) unit.overlays = string.gsub(unit.overlays, EoHS.lua_pattern_escape(overlay)..",?", "") end
local add_overlay_variable = function(unit, overlay) unit.overlays = unit.overlays and (unit.overlays ~= "") and unit.overlays..","..overlay or overlay end
local drop_overlay_immediate = function(wunit, overlay) wesnoth.fire("remove_unit_overlay", {x=wunit.x, y=wunit.y, image=overlay}) end
local add_overlay_immediate = function(wunit, overlay) wesnoth.fire(       "unit_overlay", {x=wunit.x, y=wunit.y, image=overlay}) end

EoHS.update_unit_overlays = function(unit)
  return update_overlays_impl(unit, add_overlay_variable, drop_overlay_variable)
end

EoHS.update_wunit_overlays = function(wunit)
  return update_overlays_impl(wunit, add_overlay_immediate, drop_overlay_immediate)
end

EoHS.unit_racename = function(unit)
  local custom = EoHS.get_unit_variable(unit, "race")
  if custom then return EoHS.custom_races[custom].name end
  return wesnoth.races[unit.race].name
end
EoHS.unit_typename = function(unit)
  return EoHS.get_unit_variable(unit, "type_name_override") or unit.language_name
end
EoHS.unit_appellation = function(unit)
  if EoHS.get_unit_variable(unit, "is_wizard") or (unit.unrenamable and (unit.name ~= "")) or (unit.name ~= EoHS.get_unit_variable(unit, "original_name")) then
    return unit.name
  else
    return EoHS.unit_typename(unit)
  end
end

local old_terrain = wesnoth.theme_items.terrain

-- To avoid nasty theme item recursion things, defer any sophisticated scripts
-- (like ones that ever yield to the UI themselves) to report_countdown.
-- report_countdown is special and allows ONE level of recursion without
-- throwing an error.
local ui_queue = {}
EoHS.queue_ui = function (time_sensitive, func)
  table.insert (ui_queue, {
    time = wesnoth.get_time_stamp(),
    time_sensitive = time_sensitive,
    func=func
  })
end
local frequent_functions = {}
EoHS.frequently = function (throttle_milliseconds, func)
  table.insert (frequent_functions, {
    last_call = wesnoth.get_time_stamp(),
    throttle_milliseconds = throttle_milliseconds,
    func=func
  })
end
local in_report_countdown = false
local old_report_countdown = wesnoth.theme_items.report_countdown 
wesnoth.theme_items.report_countdown = EoHS.filter_func(function()
  if in_report_countdown then
    return old_report_countdown()
  end
  in_report_countdown = true
  
  -- swap them in case more is added to the queue during the execution
  local executing = ui_queue
  ui_queue = {}
  EoHS.capture_errors (function()
    EoHS.check_for_deselect()
    
    for index, thing in ipairs (executing) do
      if not (thing.time_sensitive and wesnoth.get_time_stamp() > thing.time + 500) then
        thing.func()
      end
    end
    for index, thing in ipairs (frequent_functions) do
      if not (thing.throttle_milliseconds and wesnoth.get_time_stamp() < thing.last_call + thing.throttle_milliseconds) then
        thing.last_call = wesnoth.get_time_stamp()
        thing.func()
      end
    end
  end)
    
  in_report_countdown = false
  return old_report_countdown()
end)

EoHS.theme_item = function (name, impl)
  local default = wesnoth.theme_items [name]
  wesnoth.theme_items [name] = EoHS.filter_func(function()
    if EoHS.in_theme_item then
      EoHS.err ("Recursive theme item detected!")
      return default()
    end
    if EoHS.redraw_unexpected then
      EoHS.err ("Unexpected redraw detected.")
    end

    EoHS.in_theme_item = true
    
    local result = EoHS.capture_errors (impl, default) or {}
    
    EoHS.in_theme_item = nil
    return result
  end)
end

EoHS.theme_item ("upkeep", function(old_upkeep)
  -- always invoke it even if we don't use the result, in case another add-on is using it to invoke unrelated scripts
  local old_result = old_upkeep()
  if EoHS.get_variable("settings_inited") and EoHS.get_variable("settings.eliminate_upkeep") then
    return { { "element", { text = _"EoHS" }} }
  else
    return old_result
  end
end)

EoHS.theme_item ("unit_type", function(old_unit_type)
  -- always invoke it even if we don't use the result, in case another add-on is using it to invoke unrelated scripts
  local old_result = old_unit_type()
  local wunit = wesnoth.get_displayed_unit()
  if not wunit then return {} end
  local override = EoHS.get_unit_variable(wunit, "type_name_override")
  if override then
    return { { "element", {
      text = (w111 and override or '<span foreground="#f5e6c1">'..override..'</span>'),
      tooltip = EoHS.substitute(_"Type: <b>$1|</b>\n$2|", {override, EoHS.get_unit_variable(wunit, "type_description_override") or ""})
    }} }
  end
  return old_result
end)

EoHS.theme_item ("unit_race", function(old_unit_race)
  -- always invoke it even if we don't use the result, in case another add-on is using it to invoke unrelated scripts
  local old_result = old_unit_race()
  local wunit = wesnoth.get_displayed_unit()
  if not wunit then return {} end
  local custom = EoHS.get_unit_variable(wunit, "race")
  if custom then
    local override = EoHS.custom_races[custom].name
    return { { "element", {
      text = (w111 and override or '<span foreground="#a69275">'..override..'</span>'),
      tooltip = EoHS.substitute(_"Race: <b>$1|</b>", {override})
    }} }
  end
  return old_result
end)


local click_functions = {}
EoHS.on_click = function(thing) table.insert (click_functions, thing) end
local double_click_functions = {}
EoHS.on_double_click = function(thing) table.insert (double_click_functions, thing) end
local deselect_functions = {}
EoHS.on_deselect = function(thing) table.insert (deselect_functions, thing) end
local mouse_move_functions = {}
EoHS.on_mouse_move = function(thing) table.insert (mouse_move_functions, thing) end
local recent_redraws = {}
EoHS.theme_item ("position", function(old_position)
  local result = old_position()
  -- defend very hard against other add-ons customizing the theme item
  if result and result[1] and result[1][2] and result[1][2].text then
    local x,y = string.match (result[1][2].text, "(%d+),(%d+)")
    x,y = tonumber (x),tonumber (y)
    local selected_x,selected_y = wesnoth.get_selected_tile()
    --wesnoth.message (EoHS.inspect(selected_x))
    local now = wesnoth.get_time_stamp()
    
    -- when the mouse is off the map, but a unit is selected,
    -- old_position defaults to the location of the selected unit.
    -- However, terrain is empty. Handle that case:
    if not old_terrain() [1] then x, y = nil, nil end
    
    local current = {
      mouse_x=x,
      mouse_y=y,
      selected_x=selected_x,
      selected_y=selected_y,
      time=now,
    }
    table.insert (recent_redraws, 1, current)
    if recent_redraws [6] then table.remove (recent_redraws) end
    
    if recent_redraws [2] then
      if recent_redraws [2].mouse_x ~= current.mouse_x or recent_redraws [2].mouse_y ~= current.mouse_y then
        EoHS.queue_ui(true, function() for index, thing in ipairs (mouse_move_functions) do
          thing (x,y,recent_redraws [2].mouse_x,recent_redraws [2].mouse_y)
        end end)
      end
    end
    
    local can_be_click = true
    for index, redraw in ipairs(recent_redraws) do
      local previous = recent_redraws [index+1]
      if redraw.mouse_x ~= current.mouse_x then can_be_click = false end
      if redraw.mouse_y ~= current.mouse_y then can_be_click = false end
      if redraw.time < current.time - 500 then can_be_click = false end
      if index == 2 and redraw.considered_click then can_be_click = false end
      if (not redraw.selected_x) and previous and previous.selected_x then
        can_be_click = false
      end
      if can_be_click and index == 2 then
        current.considered_click = true
        EoHS.queue_ui(true, function() for index, thing in ipairs (click_functions) do
          thing (x,y)
        end end)
      end
      if can_be_click and index == 4 then
        EoHS.queue_ui(true, function() for index, thing in ipairs (double_click_functions) do
          thing (x,y)
        end end)
      end
    end
    
    EoHS.check_for_deselect()
  end
  return result
end)
local old_selected
EoHS.check_for_deselect = function()
  local current_selected = wesnoth.get_selected_tile()
  if old_selected and not current_selected then
    EoHS.queue_ui(true, function() for index, thing in ipairs (deselect_functions) do
      thing ()
    end end)
  end
  old_selected = current_selected
end


EoHS.on_double_click(function (x,y)
  EoHS.local_player_can_preselect_skills (true)
end)

--[[wesnoth.theme_items.unit_moves = function()
  local wunit = wesnoth.get_displayed_unit()
  if not wunit then return {} end
  return { {"element",{ text=EoHS.substitute(_"$1|/$2|, $3| AP", {wunit.moves, wunit.max_moves, EoHS.get_unit_action_points(wunit)})}} }
end]]
-- TODO rename filter_func so this is correct usage
-- TODO: improve descriptions of Soul Bind weapons, lightning attacks
EoHS.theme_item ("unit_weapons", function(old_unit_weapons)
  -- always invoke it even if we don't use the result, in case another add-on is using it to invoke unrelated scripts
  local old_result = old_unit_weapons()

  local info = EoHS.current_targeting_info
  if info and not info.done then
    local result = {}
    for index, element in ipairs (info.elements.independent) do
      table.insert (result, element)
    end
    for index, element in ipairs (info.elements.dependent) do
      table.insert (result, element)
    end
    return result
  end

  local wunit = wesnoth.get_displayed_unit()
  if not wunit then return {} end
  if not EoHS.get_variable("settings_inited") then return old_result end
  local result = {}
  local ap = EoHS.get_unit_action_points(wunit)
  local ap_color = "00ff00"
  if ap < 6 then ap_color = string.format("%.2x%.2x%.2x", 120-(ap*24), 120+(ap*15), 120+(ap*15)) end
  table.insert(result, {"element",{ text='<span foreground="#'..ap_color..'">'..EoHS.substitute(_"AP: $1|", {ap})..'</span>\n' }})
  EoHS.if_has_total_knowledge_of_side(wunit.side, function()
    local unit = EoHS.get_unit(wunit.x, wunit.y)
    if unit then
      local mana_income = EoHS.unit_mana_income(unit)
      if mana_income then
        local mana = EoHS.get_unit_variable(unit, "mana") or 0
        local mana_cap = EoHS.unit_mana_cap(unit)
        local mana_entry = EoHS.substitute(mana_cap and _'mana: $1|/$2|<span color="#a0a0a0">, +$3|/turn</span>\n' or _'mana: $1|<span color="#a0a0a0">, +$3|/turn</span>\n', {mana, mana_cap, mana_income})
        table.insert(result, {"element",{ text=mana_entry }})
        if EoHS.get_wizard_setting(unit, "can_spend_gold_on_spells") then
          local side_info = wesnoth.sides[unit.side]
          --[[local income = side_info.total_income
          -- side_info.total_income does not take into account upkeep
          local income_source = wesnoth.theme_items.income()
          -- defend very hard against other add-ons customizing the theme item
          if income_source and income_source[1] and income_source[1][2] and income_source[1][2].text then
            income_source = income_source[1][2].text
            if type (income_source) == "string" then
              income_source = - tonumber(string.match (income_source, ">.*(%d+)"))
            end
            if type (income_source) == "number" then
              income = income_source
            end
          end]]
          --table.insert(result, {"element",{ text=EoHS.substitute(_'m+gold: $1|<span color="#a0a0a0">, +$2|/turn</span>\n', {mana+side_info.gold, mana_income+income}) }})
          table.insert(result, {"element",{ text=EoHS.substitute(_'mana+gold: $1|\n', {mana+side_info.gold}) }})
        end
      end
    end
  end)
  
  if EoHS.get_unit_variable (wunit, "wizard_level") then
    table.insert(result, {"element",{
      text=EoHS.substitute(_'<span color="#00a0e1">Shared XP: $1|/$2| this turn</span>\n\n', {
        EoHS.get_unit_variable (wunit, "shared_experience_this_turn") or 0,
        EoHS.wizard_shared_experience_limit (wunit)}),
      tooltip=_"Wizards gain all the experience gained by ANY other unit on their side, up to a certain limit per turn."
    }})
  end
  
  for i,e in ipairs(old_result) do
    table.insert(result, e)
  end
  
  return result
end)

-->>)}
