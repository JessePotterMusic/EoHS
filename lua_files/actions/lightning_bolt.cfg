this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- lightning_bolt.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

local get_lightning_bolt_attack = function(dist)
  return EoHS.skill_attack_func("nature_magic", function(attack)
    attack.type = "lightning"
    if dist == 0 then
      attack.damage = math.floor(((attack.damage * attack.number * 7) + 5) / 10)
      table.insert(EoHS.force_subtag(attack, "specials"), {"chance_to_hit",{value=100}})
    else
      attack.damage = math.floor(((attack.damage * attack.number * 7) + 5) / (30 * dist))
    end
    attack.number = 1
  end)
end

local is_water = function(x,y)
  local terrain = wesnoth.get_terrain(x,y)
  return string.match(terrain, "^[WS]") or string.match(terrain, "^[CK]h[ws]")
end

local affected_hexes_func = function(parameters, known_or_actual)
  local result = {}
  if is_water(parameters.target_x, parameters.target_y) then
    for i,hex in ipairs(EoHS.find_reach(parameters.target_x, parameters.target_y, function(x,y)
        if EoHS.location_is_known_or_actual_passable(x,y,parameters.side,known_or_actual) and is_water(x,y) then return 1 end
      end, 2)) do
      if not EoHS.get_circle_of_protection(hex.x, hex.y) then table.insert(result, {x=hex.x, y=hex.y, visual="harm", dist=hex.cost}) end
    end
    return result
  else
    return {{x=parameters.target_x, y=parameters.target_y, visual="harm", dist=0}}
  end
end

local lightning_paralysis_special = EoHS.attack_disabling_special({ id="EoHS_lightning_paralysis", name=_"paralyzed" })

EoHS.make_spell("lightning_bolt", {
  image = "attacks/lightning.png",
  name = _"Lightning Bolt",
  description = _"You strike a hex with a single lightning bolt, which ignores resistance and always hits for 70% the total damage of your faerie fire attack. After the attack, the target is paralyzed and loses all its moves and attacks (including retaliation) until the end of its next turn (but wizards still have AP and can cast spells). However, unlike in real life, lightning can never strike twice in the same place.\n\nIf you strike a water hex with lightning, all units in other water within two connected water hexes will take a secondary attack for minor damage at 70% chance to hit.",
  
  base_cost = { action_points = 7, mana = 20 },
  base_range = 7,
  target_type = EoHS.target_types.hex,
  
  affected_hexes = affected_hexes_func,
  
  make_extra_attributes = function(parameters, make_aspect, list_entry_only)
    if EoHS.get_hex_variable(parameters.target_x, parameters.target_y, "struck_by_lightning") then
      make_aspect.type_value_and_details(_"Already struck", "", "", "impossible")
    end
    local actor = EoHS.get_unit(parameters.actor_id)
    if not EoHS.ensure_attack_allowed(make_aspect, actor, get_lightning_bolt_attack(0)) then return end
    local affected_hexes = affected_hexes_func(parameters, "known")
    for i,hex in ipairs(affected_hexes) do
      EoHS.make_attack_attribute(make_aspect, list_entry_only, actor, hex.x, hex.y, get_lightning_bolt_attack(hex.dist))
    end
  end,
  
  happen = function(parameters)
    --EoHS.begin_casting(parameters.actor_id, parameters.target_x, parameters.target_y)
    local actor = EoHS.get_unit(parameters.actor_id)
    EoHS.face_towards(actor, parameters.target_x, parameters.target_y) -- combat will also do this, but the animations need to see the correct facing

    local dx, dy = EoHS.pixels_to_hex(actor.x, actor.y, parameters.target_x, parameters.target_y)
    
    local animations = {}
    local casting_image_1 = EoHS.unit_casting_image_stuff(actor, 1)
    local casting_image_2 = EoHS.unit_casting_image_stuff(actor, 2)
    for which=1,3 do
      local animation = {
        base_score=10,
        offset=0,
        lightning_start_time = -250,
        start_time = -300,
        { "frame", { image=casting_image_1, duration=100, sound = "lightning.ogg", }},
        { "frame", { image=casting_image_2, duration=300, }},
        { "frame", { image=casting_image_1, duration=100, }},
      }
      for frame=1,4 do
        local image = "halo/lightning-bolt-"..which.."-"..frame..".png"
        table.insert(animation, { "lightning_frame", {
          layer = 70,
          duration = 100,
          image = image,
          auto_hflip = false,
          auto_vflip = false,
          x = dx,
          y = dy - 125,
        }})
      end
      table.insert(animations, {"attack_anim",animation})
    end
    EoHS.add_temporary_anims(actor, animations)
    EoHS.put_unit(actor, {immediate=true})
    
    local attacks = {}
    local affected_hexes = affected_hexes_func(parameters, "actual")
    local actor_included = false
    EoHS.shuffle(affected_hexes)
    for i,hex in ipairs(affected_hexes) do
      if (hex.x == actor.x) and (hex.y == actor.y) then
        actor_included = hex.dist
      else
        local info = EoHS.spell_attack_info(actor, hex.x, hex.y, get_lightning_bolt_attack(hex.dist))
        if info then table.insert(attacks, info) end
      end
    end
    -- Always attack the actor last
    if actor_included then
      table.insert(attacks, EoHS.spell_attack_info(actor, actor.x, actor.y, get_lightning_bolt_attack(actor_included)))
    end
    
    EoHS.parallel_attacks_or_animate_once(parameters, attacks)
    
    EoHS.place_item({x=parameters.target_x, y=parameters.target_y, image="scenery/trash.png~GS()"})
    EoHS.set_hex_variable(parameters.target_x, parameters.target_y, "struck_by_lightning", true)
    
    actor = EoHS.get_unit(parameters.actor_id)
    if actor then
      EoHS.remove_temporary_anims(actor)
      EoHS.put_unit(actor, {immediate=true})
    end
    local unit = EoHS.get_unit(parameters.target_x, parameters.target_y)
    if unit then
      unit.moves = 0
      EoHS.set_unit_variable(unit, "lightning_paralysis", true)
      for i,attack in ipairs(EoHS.get_subtags(unit, "attack")) do
        table.insert(EoHS.force_subtag(attack, "specials"), lightning_paralysis_special)
      end
      table.insert(EoHS.force_subtag(unit, "modifications"), {"object",{id="EoHS_lightning_paralysis",
        {"effect",{apply_to="movement",set=0}},
        {"effect",{apply_to="attack",{"set_specials",{mode="append", lightning_paralysis_special}}}}}})
      unit.max_moves = 0
      EoHS.update_conditional_abilities(unit)
      EoHS.update_unit_graphics(unit)
      EoHS.put_unit(unit, {immediate=true})
      wesnoth.float_label(unit.x, unit.y, '<span color="#ff0000">'..(_"paralyzed")..'</span>')
    end
    --EoHS.finish_casting(parameters.actor_id)
  end,
})

-- TODO un-duplicate code with e.g. curse of anxiety
EoHS.remove_lightning_paralysis = function(unit)
  EoHS.set_unit_variable(unit, "lightning_paralysis")
  EoHS.remove_subtags(unit, "modifications.object", "EoHS_lightning_paralysis")
  EoHS.remove_subtags(unit, "attack.specials.*", "EoHS_lightning_paralysis")
  EoHS.update_conditional_abilities(unit)
  EoHS.update_unit_graphics(unit)
  unit.max_moves = nil
end

EoHS.make_conditional_ability("lightning_paralysis", function(unit)
  if EoHS.get_unit_variable(unit, "lightning_paralysis") then
    return { "dummy", {
      name = _"paralyzed",
      description = _"This unit loses all its moves and attacks (including retaliation) until the end of its next turn.",
    }}
  end
end)

--[[EoHS.at_turn_refresh("lightning_paralysis", function(units)
  for i,unit in ipairs(units.with_variable.lightning_paralysis or {}) do
    if unit.side == wesnoth.current.side then
      EoHS.set_unit_attribute_immediate(unit, "moves", 0)
    end
  end
end)]]

EoHS.at_side_turn_end("lightning_paralysis", function(units)
  for i,unit in ipairs(units.with_variable.lightning_paralysis or {}) do
    if unit.side == wesnoth.current.side then
      EoHS.remove_lightning_paralysis(unit)
      EoHS.put_unit(unit)
    end
  end
end)

-->>)}
