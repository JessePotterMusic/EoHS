this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- pall_of_fatigue.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

local affected_hexes_func = function(parameters, known_or_actual)
  local result = {}
  for i,hex in ipairs(EoHS.find_reach(parameters.src_x, parameters.src_y, EoHS.known_or_actual_passable_only(parameters.side, known_or_actual), EoHS.apply_farseer(9, parameters))) do
    local unit = EoHS.get_seen_or_actual_unit(hex.x, hex.y, parameters.side, known_or_actual)
    if unit and wesnoth.is_enemy(unit.side, parameters.side) then table.insert(result, {x=hex.x, y=hex.y, visual="harm"}) end
  end
  return result
end
local get_fatigue_attack = EoHS.skill_attack_func("necromancy", function(attack) attack.damage = math.floor((attack.damage*attack.number*2+5)/10); attack.number = 1 end)

EoHS.make_spell("pall_of_fatigue", {
  image = "attacks/staff-necromantic.png",
  name = _"Pall of Fatigue",
  description = _"Every enemy unit within nine hexes of you is subject to a cold magic attack, like your ranged chill wave but weaker. The attack has only one swing and one-fifth the total power.",
  
  base_cost = { action_points=6, mana=6 },
  
  affected_hexes = affected_hexes_func,
  
  make_extra_attributes = function(parameters, make_aspect, list_entry_only)
    local actor = EoHS.get_unit(parameters.actor_id)
    if not EoHS.ensure_attack_allowed(make_aspect, actor, get_fatigue_attack) then return end
    local affected_hexes = affected_hexes_func(parameters, "known")
    if list_entry_only then return end -- Somewhat undesirable, but don't do the big pathfinding all the time. TODO maybe find a way to provide the same pathfinding work to all spells
    for i,hex in ipairs(affected_hexes) do
      EoHS.make_attack_attribute(make_aspect, list_entry_only, actor, hex.x, hex.y, get_fatigue_attack)
    end
  end,
  
  happen = function(parameters)
    local affected_hexes = affected_hexes_func(parameters, "actual")
    local actor = EoHS.get_unit(parameters.actor_id)
    local attacks = {}
    
    local casting_image_1 = EoHS.unit_casting_image_stuff(actor, 1)
    local casting_image_2 = EoHS.unit_casting_image_stuff(actor, 2)
    local dx, dy = EoHS.pixels_to_hex(actor.x, actor.y, parameters.target_x, parameters.target_y)
    local animation = {
      base_score = 10,
      offset=0,
      start_time = -600,
      { "frame", { image=casting_image_1, duration=200, }},
      { "frame", { image=casting_image_2, duration=800, sound = "wail-long.wav", }},
      { "frame", { image=casting_image_1, duration=200, }},
      fatigue_start_time = -600,
      { "fatigue_frame", { image="halo/fire-aura.png~CS(-255,-255,-255)~SCALE(1400,1400)", duration=1200, alpha="0~1,1~0" }},
    }
    EoHS.add_temporary_anims(actor, { {"attack_anim", animation} })
    EoHS.put_unit(actor, {immediate=true})
    
    EoHS.shuffle(affected_hexes)
    for i,hex in ipairs(affected_hexes) do
      local info = EoHS.spell_attack_info(actor, hex.x, hex.y, get_fatigue_attack)
      if info then table.insert(attacks, info) end
    end
    
    EoHS.parallel_attacks_or_animate_once(parameters, attacks)
    
    actor = EoHS.get_unit(parameters.actor_id)
    if actor then
      EoHS.remove_temporary_anims(actor)
      EoHS.put_unit(actor, {immediate=true})
    end
  end,
})

-->>)}
