this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- energy_blast.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

local get_energy_blast_attack = function(actor)
  for attack in helper.child_range(actor, "attack") do
    if attack.name == "EoHS_evocation_skill_ranged_attack" then
      local result = EoHS.deep_copy(attack)
      result.type = "arcane"
      result.damage = math.floor(0.5+(result.damage * 0.75))
      result.number = math.floor(0.5+(result.number * 0.75))
      return result
    end
  end
end

EoHS.make_spell("energy_blast", {
  image = "attacks/magic-missile.png",
  name = _"Energy Blast",
  description = _"You strike a unit with a magical arcane attack, like your fireball attack but with 3/4 the normal strikes and damage. After the attack, the target's arcane resistance is reduced by 50%, which is cumulative, but recovers at a rate of 10% per turn. This spell costs 5 AP if you have a rank 3 Evocation spell, otherwise 6 AP.",
  
  is_enchantment = true,
  
  base_cost = function(parameters)
    return {
      action_points = (EoHS.skillset_realm_rank(EoHS.get_unit_skillset(EoHS.get_unit(parameters.actor_id)), "evocation") >= 3) and 5 or 6,
      mana = 3 }
  end,
  base_range = 3,
  target_type = EoHS.target_types.unit_probably_enemy,
  
  affected_hexes = function(parameters)
    return {{x=parameters.target_x,y=parameters.target_y,visual="harm"}}
  end,
  
  make_extra_attributes = function(parameters, make_aspect, list_entry_only)
    local actor = EoHS.get_unit(parameters.actor_id)
    make_aspect.type_value_and_details(_"Minimum range:", "2", "", (EoHS.distance_between(actor.x,actor.y,parameters.target_x,parameters.target_y) >= 2) and "valid" or "impossible")
    local unit = EoHS.get_seen_unit(parameters.target_x,parameters.target_y,actor.side)
    if unit then
      local value,details,validity = "","","valid"
      local name = EoHS.unit_appellation(unit)
      if EoHS.unit_is_immune_to_direct_spell_damage(unit) then
        value = _"None"
        details = EoHS.unit_is_immune_to_direct_spell_damage_description(unit)
        validity = "impossible"
      elseif list_entry_only then
        -- It's valid - and these won't be shown anyway. Save time by not making the attack context.
      else
        local attack_context = EoHS.game_action_simulations.fleshed_out_attack_context({
          attacker={unit=actor,attack=get_energy_blast_attack(actor)},
          defender={unit=unit}})
        value = attack_context.attacker.damage.."-"..attack_context.attacker.attacks
        details = ""
      end
      make_aspect.type_value_and_details(EoHS.substitute(_"Damage to $1|", {name}), value, details, validity)
    end
  end,
  
  happen = function(parameters)
    --EoHS.begin_casting(parameters.actor_id, parameters.target_x, parameters.target_y)
    local actor = EoHS.get_unit(parameters.actor_id)
    EoHS.face_towards(actor, parameters.target_x, parameters.target_y) -- combat will also do this, but the animations need to see the correct facing
    local unit = EoHS.get_unit(parameters.target_x, parameters.target_y)
    EoHS.set_unit_variable(actor, "energy_blasting_x", parameters.target_x)
    EoHS.set_unit_variable(actor, "energy_blasting_y", parameters.target_y)
    EoHS.update_unit_graphics(actor)
    EoHS.put_unit(actor, {immediate=true})
    
    local attack_context = {
      attacker={x=actor.x,y=actor.y},
      defender={x=unit.x,y=unit.y}
    }
    EoHS.game_action_simulations.attack_unit(attack_context, {spend_moves_and_attacks = false, update_context_func = function()
      local actor = EoHS.get_unit(parameters.actor_id)
      attack_context.attacker.attack = actor and get_energy_blast_attack(actor)
    end})
    
    actor = EoHS.get_unit(parameters.actor_id)
    if actor then
      EoHS.set_unit_variable(actor, "energy_blasting_x")
      EoHS.set_unit_variable(actor, "energy_blasting_y")
      EoHS.put_unit(actor, {immediate=true})
    end
    unit = EoHS.get_unit(parameters.target_x, parameters.target_y)
    if unit then
      EoHS.set_unit_variable(unit, "energy_overload", (EoHS.get_unit_variable(unit, "energy_overload") or 0) + 50)
      EoHS.update_energy_overload(unit)
      EoHS.put_unit(unit, {immediate=true})
      wesnoth.float_label(unit.x, unit.y, '<span color="#ff0000">'..(_"overloaded")..'</span>')
    end
    --EoHS.finish_casting(parameters.actor_id)
  end,
})

EoHS.make_conditional_ability("energy_overload", function(unit)
  local energy_overload = EoHS.get_unit_variable(unit, "energy_overload")
  if energy_overload then
    return { "dummy", {
      name = EoHS.substitute(_"energy overload($1|%)", {energy_overload}),
      description = EoHS.substitute(_"This unit is $1|% weaker to arcane damage, but will recover 10% at the beginning of each turn.", {energy_overload}),
    }}
  end
end)

EoHS.update_energy_overload = function(unit)
  EoHS.update_conditional_abilities(unit)
  local energy_overload = EoHS.get_unit_variable(unit, "energy_overload")
  local modifications = EoHS.force_subtag(unit, "modifications")
  EoHS.remove_subtags(modifications, "object", "EoHS_energy_overload")
  if energy_overload then
    table.insert(modifications, {"object",{
      id="EoHS_energy_overload",
      {"effect",{apply_to="resistance",replace=false,{"resistance",{arcane=energy_overload}}}},
    }})
  end
  EoHS.set_subtag_attribute(unit, "resistance.arcane", nil)
end

EoHS.at_side_turn("energy_overload", function(units)
  for i,unit in ipairs(units.with_variable.energy_overload or {}) do
    if unit.side == wesnoth.current.side then
      local current = EoHS.get_unit_variable(unit, "energy_overload")
      current = current - 10
      EoHS.set_unit_variable_immediate(unit, "energy_overload", (current > 0) and current)
    end
  end
end)

-->>)}
