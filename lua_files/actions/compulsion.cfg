this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- compulsion.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

-- TODO: caching some of this stuff?
local cost_func = function(caster_side, victim, wvictim, optimism, attack_target_x, attack_target_y)
  return function(x, y, current_cost)
    if (attack_target_x==x) and (attack_target_y==y) then
      return 1
    end
    local unshrouded = EoHS.hex_is_unshrouded(x,y,caster_side)
    if (not EoHS.wunit_can_move_on_hex(wvictim, x, y)) or ((optimism == "pessimistic") and not unshrouded) then
      return nil
    end
    local near_attack_target = attack_target_x and (EoHS.distance_between(x,y,attack_target_x,attack_target_y) <= 1)
    local seen_unit = EoHS.get_seen_unit(x,y,caster_side)
    if (seen_unit and (wesnoth.is_enemy(caster_side, seen_unit.side) or near_attack_target)) or
        ((optimism == "pessimistic") and not EoHS.hex_is_unfogged(x,y,caster_side)) then
      return nil
    end
    local cost = unshrouded and wesnoth.unit_movement_cost(wvictim, wesnoth.get_terrain(x, y)) or 1
    local zoc = false
    for x2,y2 in helper.adjacent_tiles(x,y) do
      if (optimism == "pessimistic") and not EoHS.hex_is_unfogged(x2,y2,caster_side) then
        zoc = true
        break
      end
      local unit = EoHS.get_seen_unit(x2,y2,caster_side)
      if unit and unit.zoc and wesnoth.is_enemy(caster_side, unit.side) and not ((x2==victim.x) and (y2==victim.y)) then
        zoc = true
        break
      end
    end
    if zoc then
      if near_attack_target then
        zoc = false
      end
      -- TODO: handling selective skirmisher abilities better
      for i,ability in ipairs(EoHS.game_action_simulations.abilities_affecting_unit_wunit(victim, wvictim)) do
        if ability[1] == "skirmisher" then
          zoc = false
          break
        end
      end
    end
    if zoc then
      cost = math.max(cost, victim.max_moves - current_cost)
    end
    return cost
  end
end

local find_path = function(caster_side, victim, wvictim, target_x, target_y, optimism)
  local adjust_max = 0
  local attack_target_x, attack_target_y = nil, nil
  local attacking = EoHS.get_seen_unit(target_x,target_y,caster_side)
  if attacking then
    adjust_max = 1
    attack_target_x, attack_target_y = target_x, target_y
  end
  local path = EoHS.find_path(victim.x,victim.y,target_x,target_y,cost_func(caster_side, victim, wvictim, optimism, attack_target_x, attack_target_y),victim.max_moves+adjust_max)
  return path
end

local stuff = function(parameters)
  local result = {}
  result.affected_hexes = {}
  for x2,y2 in helper.adjacent_tiles(parameters.src_x,parameters.src_y) do
    local unit = EoHS.get_unit(x2,y2)
    if unit and wesnoth.is_enemy(parameters.side, unit.side) then
      if result.victim then
        result.details = _"There are too many enemies next to you."
        result.validity = "impossible"
        result.victim = nil
        return result
      else
        result.victim = unit
        result.wvictim = wesnoth.get_unit(x2,y2)
      end
    end
  end
  if not result.victim then
    result.details = _"There are no enemies next to you."
    result.validity = "impossible"
    return result
  end
  if (EoHS.get_unit_variable(result.victim, "is_wizard") or (result.victim.type == "Fire Dragon") or (result.victim.type == "Skeletal Dragon")) and (result.victim.level > parameters.actor_level - 2) then
    result.details = _"Compulsion doesn't work on wizards or dragons unless you're at least two levels higher than them."
    result.validity = "impossible"
    return result
  end
  if EoHS.get_unit_variable(result.victim, "lightning_paralysis") then
    result.details = _"You can't make a paralyzed unit move."
    result.validity = "impossible"
    return result
  end
  if (result.victim.x==parameters.target_x) and (result.victim.y==parameters.target_y) then
    result.details = _"You can't make a unit attack itself."
    result.validity = "impossible"
    return result
  end

  result.optimistic = find_path(parameters.side, result.victim, result.wvictim, parameters.target_x, parameters.target_y, "optimistic")
  result.optimistic = result.optimistic[1] and result.optimistic
  if not result.optimistic then
    result.details = _"The unit can't reach your target."
    result.validity = "impossible"
    return result
  end
  result.pessimistic = find_path(parameters.side, result.victim, result.wvictim, parameters.target_x, parameters.target_y, "pessimistic")
  result.pessimistic = result.pessimistic[1] and result.pessimistic
  if not result.pessimistic then
    result.details = _"The unit might not be able to reach your target."
    result.validity = "undesirable"
  end
  local projected = result.pessimistic or result.optimistic
  result.attacking = EoHS.get_seen_unit(parameters.target_x,parameters.target_y,parameters.side)
  for i,l in ipairs(projected) do
    local x,y = l[1], l[2]
    table.insert(result.affected_hexes, {x=x, y=y, visual=((i==1) or (result.attacking and (i==#projected))) and "harm" or "change"})
  end
  return result
end



EoHS.make_spell("compulsion", {
  image = "attacks/gaze.png",
  name = _"Compulsion",
  description = _"You enchant the adjacent enemy unit to move to your chosen target and possibly attack. (You can only cast Compulsion when there is exactly one enemy unit adjacent to you.) It will proceed to the target by the shortest path, and then, if you targeted a unit, it will attack that unit with whichever attack does the most damage. You can make it attack a unit on any side; while moving, it is subject to your enemies' ZoC and not to your allies'. If the unit would have to pass through fog or shroud, you may attempt to cast Compulsion; this will clear the fog/shroud, but if the unit still can't reach the target in one turn, it doesn't move at all. Compulsion doesn't work on wizards or dragons unless you're at least two levels higher than them.",
  
  is_enchantment = true,
  
  base_cost = { action_points=7, mana=9 },
  base_range = 13,
  target_type = EoHS.target_types.hex,
  
  affected_hexes = function(parameters, known_or_actual)
    local s = stuff(parameters)
    return s.affected_hexes
  end,
  
  make_extra_attributes = function(parameters, make_aspect)
    local s = stuff(parameters)
    if s.validity then
      make_aspect({
        type=_"Usability:",
        value=(s.validity == "impossible") and _"No" or _"Maybe",
        details=s.details,
        validity=s.validity,
        doesnt_affect_scribing = true,
      })
    end
  end,
  
  happen = function(parameters, extras)
    local s = stuff(parameters)
    EoHS.begin_casting(parameters.actor_id, s.victim.x, s.victim.y)
    extras.do_on_clients_who_see(function() wesnoth.fire("sound", { name = "magic-dark.ogg" }) end)
    
    local old_side = s.wvictim.side
    s.wvictim.side = parameters.side
    wesnoth.fire("redraw",{clear_shroud=true,side=parameters.side})
    s.wvictim.side = old_side
    -- Try the known route first, so it's what we showed the player. Try harder only if there isn't one.
    local path = s.pessimistic or find_path(parameters.side, s.victim, s.wvictim, parameters.target_x, parameters.target_y, "pessimistic")
    if not path[1] then
      EoHS.message(_"The compelled unit wasn't able to reach that destination!")
    else
      local xs,ys = {},{}
      for i,l in ipairs(path) do
        local x,y = l[1], l[2]
        if not ((i==1) or (s.attacking and (i==#path))) then
          table.insert(xs, x)
          table.insert(ys, y)
          local ambushed = false
          for x2,y2 in helper.adjacent_tiles(x,y) do
            local unit = EoHS.get_unit(x2,y2)
            if unit and EoHS.game_action_simulations.unit_wunit_is_hidden(unit, wesnoth.get_unit(x2,y2), parameters.side) then
              ambushed = true
              EoHS.set_unit_status_immediate(unit, "uncovered", false)
            end
          end
          if ambushed then
            if i < #path - 1 then
              s.attacking = nil
            end
            break
          end
        end
      end
      local attacker_id = EoHS.unit_id(s.victim)
      local defender_id = s.attacking and EoHS.unit_id(s.attacking)
      if xs[1] then
        EoHS.unsafe_code_may_fire_events(function() wesnoth.fire("move_unit", {
          x=s.victim.x, y=s.victim.y,
          to_x = table.concat(xs, ","),
          to_y = table.concat(ys, ","),
          fire_event = true,
        }) end)
      end
      if defender_id then
        local attacker = EoHS.get_unit(attacker_id)
        local defender = EoHS.get_unit(defender_id)
        if attacker and defender and (EoHS.distance_between(attacker.x, attacker.y, defender.x, defender.y) == 1) then
          local wattacker = wesnoth.get_unit(attacker.x, attacker.y)
          local wdefender = wesnoth.get_unit(defender.x, defender.y)
          local attack_num = 1
          local best_num
          local best_priority = -math.huge
          for attack in helper.child_range(attacker, "attack") do
            local att_stats, def_stats = wesnoth.simulate_combat(wattacker, attack_num, wdefender)
            local priority = EoHS.synchronize_choice(math.floor(100 * ((defender.hitpoints-def_stats.average_hp)/defender.max_hitpoints + def_stats.hp_chance[0])))
            if priority > best_priority then
              best_priority = priority
              best_num = attack_num
            end
            attack_num = attack_num + 1
          end
          if best_num then
            -- Hack: this counts as a regular attack, not a special action
            EoHS.during_action = nil
            EoHS.game_action_simulations.attack_unit({
              attacker = { x=attacker.x, y=attacker.y, weapon_index_zero_based = best_num - 1 },
              defender = { x=defender.x, y=defender.y, weapon_index_zero_based = "choose"     },
            })
            EoHS.units_may_advance_now()
            EoHS.during_action = true
          end
        end
      end
    end
    
    EoHS.finish_casting(parameters.actor_id)
  end,
})

-->>)}
