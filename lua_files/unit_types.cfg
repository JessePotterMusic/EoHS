this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- unit_types.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

local w111 = wesnoth.compare_versions(wesnoth.game_config.version, ">=", "1.11.0")

EoHS.do_special_advancement_next = function(unit)
  return EoHS.get_unit_variable(unit, "is_wizard") or ((unit.advances_to == unit.type) and EoHS.get_unit_variable(unit, "is_summon"))
end

local wizard_max_experience_table = {
  wesnoth.unit_types[     "Mage"].max_experience,
  wesnoth.unit_types[ "Red Mage"].max_experience,
  wesnoth.unit_types["Arch Mage"].max_experience,
}
EoHS.wizard_max_experience = function(level)
  if level < 1 then return math.ceil(wizard_max_experience_table[1] / (2-level)) end
  if level > 3 then return wizard_max_experience_table[3] + (120*(level - 3)) end
  return wizard_max_experience_table[level]
end
local wizard_max_hitpoints_table = {
  wesnoth.unit_types[      "Mage"].max_hitpoints,
  wesnoth.unit_types[  "Red Mage"].max_hitpoints,
  wesnoth.unit_types[ "Arch Mage"].max_hitpoints,
  wesnoth.unit_types["Great Mage"].max_hitpoints,
}
EoHS.wizard_max_hitpoints = function(level)
  local val
      if level < 1 then val = math.ceil(wizard_max_hitpoints_table[1] / (2-level))
  elseif level > 4 then val = wizard_max_hitpoints_table[4] + (11*(level - 4))
  else val = wizard_max_hitpoints_table[level] end
  return val + 10
end
EoHS.appropriate_wizard_unit_type = function(reference_type, level)
  local human_line = {["Mage"]=true,["Red Mage"]=true,["Arch Mage"]=true,["Great Mage"]=true}
  local dwarf_line = {["Dwarvish Runesmith"]=true,["Dwarvish Runemaster"]=true,["Dwarvish Arcanister"]=true}
  local maleelf_line = {["Elvish Lord"]=true,["Elvish High Lord"]=true}
  if human_line[reference_type] then
        if level <= 1 then return       "Mage"
    elseif level == 2 then return   "Red Mage"
    elseif level == 3 then return  "Arch Mage"
    else                   return "Great Mage" end
  end
  if dwarf_line[reference_type] then
        if level  < 3 then return "Dwarvish Runesmith"
    elseif level  < 4 then return "Dwarvish Runemaster"
    else                   return "Dwarvish Arcanister" end
  end
  if maleelf_line[reference_type] then
        if level  < 3 then return "Elvish Lord"
    else                   return "Elvish High Lord" end
  end
  
  return reference_type
end

-- TODO: Rename this function to be in line with the other functions' style?
-- (e.g. the "all" is unnecessary and we could use something like "attributes" rather than "adjustments",
--   since this mostly is intended to overwrite things rather than tweaking them)
EoHS.update_all_type_adjustments = function(unit, only_a_prototype)
  local variables = EoHS.force_unit_variables(unit)
  if not variables.original_type then variables.original_type = unit.type end
  local original_type = variables.original_type
  local reference_type = original_type
  if variables.is_wizard and (reference_type == "Elvish Lady") then reference_type = EoHS.appropriate_wizard_unit_type("Elvish Lord", variables.wizard_level) end
  local type_cfg = EoHS.get_unit_type(reference_type)
  unit.level = type_cfg.level
  local observed_type = unit.type
  unit.type = original_type
  unit.advances_to = type_cfg.advances_to
  unit.alignment = type_cfg.alignment
  unit.cost = type_cfg.cost
  unit.race = type_cfg.race
  local type_in = function(list) for t in EoHS.comma_separated_values(list) do if original_type == t then return true end end; return false end
  
  local hitpoints = type_cfg.hitpoints
  local experience = type_cfg.experience
  local extra_effects_before_extra_attacks = {}
  local extra_attacks = {}
  local extra_effects = {}
  local make_effect = function(apply_to, contents, before_extra_attacks)
    contents.apply_to = apply_to
    table.insert(before_extra_attacks and extra_effects_before_extra_attacks or extra_effects, { "effect", contents })
  end
  -- We'd remove AMLA for units with special advancements, but we can't; fortunately it's overridden by the valid advances_to
  
  if EoHS.get_unit_variable(unit, "is_summon") then
    if (original_type == "Chocobone") then
      unit.cost = 26
      unit.advances_to = "Death Knight"
      experience = 90
    elseif (original_type == "Death Knight") then
      unit.cost = 48
      make_effect("movement", { set = 9 })
      make_effect("attack", { name = "battle axe", increase_damage = -2 })
      table.insert(extra_attacks, {
        name = "spear",
        description = _"spear",
        type = "pierce",
        range = "melee",
        damage = 14,
        number = 2,
        { "specials", EoHS.macros.WEAPON_SPECIAL_CHARGE },
      })
    end
    
    if (original_type ==       "Wolf") then experience = 30; unit.advances_to = "Great Wolf"; unit.cost = 15 end
    if (original_type == "Great Wolf") then experience = 65; unit.advances_to =   "Direwolf"; make_effect("attack", { increase_damage = 2 }) end
    if (original_type ==   "Direwolf") then                                                   make_effect("attack", { increase_damage = 2 }) end
    
    if (original_type == "Fire Guardian") then
      if variables.advanced_as_summon ~= original_type then
        unit.cost = 12
        unit.advances_to = original_type
        experience = 42
      else
        unit.level = 2
        unit.cost = 26
        experience = 100
        hitpoints = hitpoints + 17
        make_effect("attack", { name = "fire claws", increase_damage = 2, increase_attacks = 1 })
        make_effect("attack", { name = "fire breath", increase_damage = 2, increase_attacks = 1 })
        make_effect("image_mod", { add = "~CS(50,-60,-90)", })
      end
    end
    
    if (original_type == "Giant Scorpion") then
      if variables.advanced_as_summon ~= original_type then
        unit.cost = 19
        unit.advances_to = original_type
        experience = 34
      else
        unit.level = 2
        unit.cost = 29
        experience = 100
        hitpoints = hitpoints + 10
        make_effect("resistance", { replace = true, { "resistance", { blade = 70, pierce = 70, fire = 120, arcane = 110, cold = 100 }}, })
        make_effect("attack", { name = "pincers", increase_damage = 2 })
        make_effect("attack", { name = "sting", increase_attacks = 1 })
        make_effect("image_mod", {
          { "color_palette", {
            EoHS_giant_scorpion_palette = "394960,8796b3,435778,56657c,8c9bb2,6b7b94,6b7c98,7686a0,00274f,313f5a,273649,131a24,1a2835,39455f,2f3241,31415b,92acc7,7994af,8199bd,576276,596d88,717b9e,2e3b5b,5f6d88,b5b0ce,9b98b7,5f607f,b1add0,8384a3,8180a2,414c5e,737492,384c71,1d2c49",
          }},
          { "color_range", {
            id = "EoHS_bigger_scorpion_range",
            rgb = "921e00,ffe267,000000",
          }},
          add = "~SCALE(84,84)~RC(EoHS_giant_scorpion_palette>EoHS_bigger_scorpion_range)",
        })
      end
    end
    
    if (original_type == "Gryphon") then
      if variables.advanced_as_summon ~= original_type then
        unit.cost = 28
        unit.advances_to = original_type
        experience = 74
      else
        unit.level = 3
        unit.cost = 48
        experience = 150
        hitpoints = hitpoints + 18
        make_effect("attack", { name = "claws", increase_damage = 4 })
        make_effect("movement", { increase = 1 })
        make_effect("image_mod", { add = "~CS(0,-20,-60)" })
      end
    end
    
    if (original_type == "Water Serpent") then
      if variables.advanced_as_summon ~= original_type then
        unit.cost = 24
        unit.advances_to = original_type
        experience = 68
      else
        unit.level = 3
        unit.cost = 42
        experience = 150
        hitpoints = hitpoints + 12
        make_effect("attack", { name = "fangs", increase_attacks = 1, increase_damage = 1 })
        make_effect("movement", { increase = 1 })
        make_effect("image_mod", { add = w111 and "~CS(-30,-70,-90)" or "~CS(-60,-60,0)" })
      end
    end
    
    if (original_type == "Sea Serpent") then
      if variables.advanced_as_summon ~= original_type then
        unit.cost = 38
        unit.level = 2
        hitpoints = hitpoints - 9
        unit.advances_to = original_type
        experience = 88
      else
        unit.cost = 58
        hitpoints = hitpoints + 9
        make_effect("attack", { name = "fangs", increase_damage = 7 })
        make_effect("movement", { increase = 2 })
        make_effect("image_mod", { add = "~CS(-60,-60,0)" })
        local name = _"open water only"
        local description = _"This attack can be used in deep water, shallow water, and coastal reefs, but not in river ford, swamp, or land terrains."
        table.insert(extra_attacks, {
          name = "gigantic splash",
          description = _"gigantic splash",
          icon = "attacks/waterspray.png",
          type = "impact",
          range = "ranged",
          damage = 8,
          number = 3,
          {"specials",{
            EoHS.attack_disabling_special({
              name = name,
              description = description,
              name_inactive = name,
              description_inactive = description,
              {"filter_self",{
                {"not",{
                  {"filter_location",{
                    terrain="Ww*,Wo*",
                    {"not",{ terrain="Wwf" }}
                  }}
                }}
              }}
            })
          }}
        })
      end
    end
    
    if type_in("Ghost,Shadow,Nightgaunt,Wraith,Spectre") then
      unit.cost = type_cfg.cost - 4
    end
    if type_in("Wose,Elder Wose,Ancient Wose") then
      unit.cost = type_cfg.cost - 2
    end
    if type_in("Drake Fighter,Drake Warrior,Drake Blademaster") then
      unit.cost = type_cfg.cost + 3
      unit.language_name = _"Arctic Drake"
      make_effect("image_mod", {
        { "color_palette", {
          EoHS_drake_fighter_palette = "86ac53,fde9f1,fde6ef,fadb85,f7df8e,f6db84,dfc799,c7d95e,c3d355,c1d553,c19057,a2c157,9dba50,99b94e,7ca448,679345,5e8d44,57624d,573d2d,53844a,4c5742,4a5640,487a3f,3c513e,324634,2d4331,242e12,1c250d,151f06,100506",
        }},
        { "color_range", {
          id = "EoHS_blue_drake_range",
          rgb = "8888ff,ffffff,000000",
        }},
        add = "~RC(EoHS_drake_fighter_palette>EoHS_blue_drake_range)",
      })
      make_effect("resistance", { replace = true, { "resistance", { cold = 80, arcane = 80, }}, })
      -- I didn't originally intend to change its snow movement/defense, but the "arctic" theme requires me to (and I have nothing against it)
      make_effect("movement_costs", { replace = true, { "movement_costs", { frozen = 1, }}, })
      make_effect("defense",        { replace = true, { "defense",        { frozen = 60, }}, })
    end
  end
  
  if EoHS.get_unit_variable(unit, "is_wizard") then
    local skills = EoHS.get_unit_skillset(unit)
    
    unit.level = EoHS.get_unit_variable(unit, "wizard_level") or unit.level
    unit.advances_to = EoHS.appropriate_wizard_unit_type(original_type, unit.level + 1)
    experience = EoHS.wizard_max_experience(unit.level)
    hitpoints = EoHS.wizard_max_hitpoints(unit.level)
    unit.cost = 20 + unit.level*25
    unit.description = EoHS.rules
    
    --[[if (original_type == "Mage") then
      make_effect("remove_attacks", { name="missile" })
    end
    if type_in("Red Mage,Arch Mage,Great Mage") then
      make_effect("remove_attacks", { name="fireball" })
    end
    if (original_type == "Lich") then
      make_effect("remove_attacks", { name="chill tempest" })
      make_effect("remove_attacks", { name="shadow wave" })
    end]]
    if not EoHS.get_unit_variable(unit, "spiritform") then make_effect("remove_attacks", { range="ranged" }, true) end
    if original_type == "Elvish Lady" then
      for attack in helper.child_range(type_cfg, "attack") do
        if attack.range == "melee" then
          table.insert(extra_attacks, attack)
        end
      end
    end
    
    local make_attack = function(skill_name, upgrade_array, bonus, attack)
      local skill = EoHS.skillset_realm_rank(skills, skill_name)
      if skill > 0 then
        local upgrade_total = math.max(0, math.min(skill, unit.level)) + 1
        local upgrade_array_index = math.min(#upgrade_array, upgrade_total)
        local excess = math.max(0, upgrade_total - upgrade_array_index)
        
        attack.range = "ranged"
        attack.damage = upgrade_array[upgrade_array_index][1] + math.floor(excess * bonus)
        attack.number = upgrade_array[upgrade_array_index][2]
        table.insert(attack, { "specials", EoHS.macros.WEAPON_SPECIAL_MAGICAL })
        table.insert(extra_attacks, attack)
      end
    end
    make_attack("evocation",
      {{ 6,2},{ 7,3},{ 8,4}}, 4,
      {
        name = "EoHS_evocation_skill_ranged_attack",
        description = wesnoth.textdomain("wesnoth-units")("fireball"),
        icon = "attacks/fireball.png",
        type = "fire",
      }
    )
    make_attack("nature_magic",
      {{ 4,3},{ 5,4},{ 7,4},{9,4},{10,5}}, 2,
      {
        name = "EoHS_nature_magic_skill_ranged_attack",
        description = wesnoth.textdomain("wesnoth-units")("faerie fire"),
        icon = "attacks/faerie-fire.png",
        type = "arcane",
      }
    )
    make_attack("necromancy",
      {{ 6,2},{10,2},{10,3}}, 4,
      {
        name = "EoHS_necromancy_skill_ranged_attack",
        description = wesnoth.textdomain("wesnoth-units")("chill wave"),
        icon = "attacks/iceball.png",
        type = "cold",
      }
    )
    
    if type_in("Mage,Red Mage,Arch Mage,Great Mage") then
      make_effect("resistance", { replace=true, { "resistance", { fire = 100, arcane = 100, }} })
      make_effect("attack", {
        name = "staff",
        increase_attacks = 1,
        increase_damage  = -1 + math.max(unit.level-4, 0),
      })
    end
    if type_in("Elvish Lady,Elvish Lord,Elvish High Lord") then
      unit.cost = unit.cost + 7
      hitpoints = math.floor(0.5+hitpoints*0.9)
      --[[make_effect("attack", {
        range = "ranged",
        increase_attacks = -1,
      })]]
      if unit.level < 2 then 
        make_effect("attack", {
          range = "melee",
          increase_damage = 2*unit.level - 5,
        })
      end
      if unit.level > 3 then 
        make_effect("attack", {
          range = "melee",
          increase_damage = unit.level - 3,
        })
      end
    end
    if type_in("Dwarvish Runesmith,Dwarvish Runemaster,Dwarvish Arcanister") then
      unit.cost = unit.cost + 1
      hitpoints = math.floor(0.5+hitpoints*1.05)
      --[[make_effect("attack", {
        range = "ranged",
        increase_attacks = -1,
      })]]
      if unit.level < 2 then
        make_effect("resistance", { replace=true, { "resistance", { blade=80-10*unit.level, pierce=80, impact=80 }} })
        make_effect("attack", {
          range = "melee",
          increase_damage = 3*unit.level - 8,
        })
      end
      if unit.level > 4 then 
        make_effect("attack", {
          range = "melee",
          increase_damage = unit.level - 4,
        })
      end
    end
    if (original_type == "Troll Shaman") then
      unit.cost = unit.cost + 4
      hitpoints = math.floor(0.5+hitpoints*1.15)
      --[[make_effect("attack", {
        range = "ranged",
        increase_damage = -2,
      })]]
      make_effect("attack", {
        range = "melee",
        increase_damage = 2*unit.level - 2,
      })
    end
    if (original_type == "Lich") then
      unit.alignment = "chaotic"
      -- Invisibility undercuts the drama of a wizard, and this usually-irrelevant ability clutters the ability list.
      make_effect("remove_ability", {
        { "abilities", EoHS.macros.ABILITY_SUBMERGE },
      })
      make_effect("attack", {
        name = "touch",
        increase_damage = math.min(unit.level-3, 0),
      })
      --[[do
        local upgrade_array = {{1,1},{4,1},{4,2}}
        local bonus = 3
        local upgrade_total = math.min(0, unit.level - 3)
        local upgrade_array_index = math.min(#upgrade_array, upgrade_total)
        local excess = math.max(0, upgrade_total - upgrade_array_index)
        
        if unit.level > 3 then
          make_effect("attack", {
            name = "chill tempest",
            increase_damage = upgrade_array[upgrade_array_index][1] + math.floor(excess * bonus),
            increase_attacks = upgrade_array[upgrade_array_index][2],
          })
          make_effect("attack", {
            name = "shadow wave",
            increase_damage = math.floor((upgrade_array[upgrade_array_index][1] + excess * bonus) * 0.75),
            increase_attacks = upgrade_array[upgrade_array_index][2],
          })
        end
      end]]
    else
      unit.alignment = "neutral"
      if skills.khalifate then unit.alignment = "liminal"
      else
        if skills.military_commander and not skills.petty_necromancer  then unit.alignment = "lawful"  end
        if skills.petty_necromancer  and not skills.military_commander then unit.alignment = "chaotic" end
      end
      
      make_effect("resistance", { replace=false, { "resistance", {
        fire   = math.min(0, 10 - math.min(EoHS.skillset_realm_rank(skills, "evocation"   ), unit.level, 4) * 10),
        cold   = math.min(0, 10 - math.min(EoHS.skillset_realm_rank(skills, "necromancy"  ), unit.level, 4) * 10),
        arcane = math.min(0, 10 - math.min(EoHS.skillset_realm_rank(skills, "nature_magic"), unit.level, 4) * 10),
      }} })
    end
    
    if skills.mentor then
      make_effect("resistance", { replace=false, { "resistance", {
        arcane = -40,
        fire   = -40,
        cold   = -40,
      }} })
    end
    if skills.dwarvish_alliance then
      make_effect("resistance", { replace=false, { "resistance", {
        blade  = -20,
        impact = -20,
        pierce = -20,
      }} })
    end
    if skills.traveler then
      make_effect("movement", { increase=1 })
      make_effect("defense", { replace=false, { "defense", {
        deep_water = -10,
        shallow_water = -10,
        reef = -10,
        swamp_water = -20,
        forest = skills.elvish_alliance and 0 or -10,
        sand = skills.khalifate and 0 or -10,
        frozen = -10,
      }} })
      make_effect("movement_costs", { replace=false, { "movement_costs", {
        shallow_water = -1,
        swamp_water = -1,
        sand = -1,
        hills = -1,
        mountains = -1,
        cave = -1,
        frozen = -1,
      }} })
    end
    if skills.military_commander then
      make_effect("new_ability", { { "abilities", EoHS.leadership_abilities(unit.level) }})
    end
    if skills.rascally_friends then
      make_effect("new_ability", { { "abilities", EoHS.macros.ABILITY_SKIRMISHER } })
    end
    if skills.khalifate then
      make_effect("defense", { replace=false, { "defense", { sand = -20, }} })
      make_effect("movement_costs", { replace=false, { "movement_costs", { sand = -1, }} })
    end
    if skills.elvish_alliance then
      make_effect("new_ability", { { "abilities", (unit.level>2) and EoHS.macros.ABILITY_CURES or EoHS.macros.ABILITY_HEALS } })
      make_effect("defense", { replace=false, { "defense", { forest = -20, }} })
      make_effect("movement_costs", { replace=false, { "movement_costs", { forest = -1, }} })
    end
    if skills.orcish_mercenaries then 
      make_effect("attack", { range = "melee", increase_damage = 2, })
    end
    if skills.petty_necromancer then 
      make_effect("attack", {
        name = "staff",
        set_description = wesnoth.textdomain("wesnoth-units")("plague staff"),
        set_icon = "attacks/staff-plague.png", -- Won't work until 1.11
        { "set_specials", {
          mode = "append",
          EoHS.macros.WEAPON_SPECIAL_PLAGUE[1],
        }},
      })
    end
    
    if unit.alignment == "liminal" then
      make_effect("attack", {
        increase_damage = "20%",
      })
    end
    
    unit.profile = "unit_image"
    if EoHS.get_wizard_setting(unit, "can_recruit") then
      local current_recruits = {}
      for recruit in EoHS.comma_separated_values(unit.extra_recruit) do
        current_recruits[recruit] = true
      end
      local needed_recruits = {}
      local need = function(list)
        for recruit in EoHS.comma_separated_values(list) do
          table.insert(needed_recruits, recruit)
        end
      end
      if EoHS.replace_alliances_with_era then
        for i,alliance in ipairs(EoHS.skills.alliances) do
          if skills[alliance.id] then need(alliance.recruit) end
        end
      end
      if skills.military_commander then need("Cavalryman,Horseman,Spearman,Fencer,Heavy Infantryman,Bowman,Sergeant,Merman Fighter") end
      if skills.rascally_friends then need("Thief,Thug,Poacher,Footpad,Ruffian,Pirate Galleon") end
      if skills.elvish_alliance then need("Elvish Fighter,Elvish Archer,Elvish Scout,Elvish Shaman,Merman Hunter,Mermaid Initiate") end
      if skills.dwarvish_alliance then need("Dwarvish Fighter,Dwarvish Thunderer,Dwarvish Guardsman,Dwarvish Ulfserker,Dwarvish Scout") end
      if skills.orcish_mercenaries then need("Orcish Grunt,Troll Whelp,Wolf Rider,Orcish Archer,Orcish Assassin,Naga Fighter,Goblin Spearman") end
      if skills.traveler then need("Saurian Skirmisher,Saurian Augur,Woodsman,Peasant,Transport Galleon") end
      if skills.petty_necromancer then need("Skeleton,Skeleton Archer,Walking Corpse,Vampire Bat,Dark Adept,Ghoul") end
      if skills.khalifate then need("Jundi,Arif,Khaiyal,Rami,Hakim,Naffat,Falcon") end
      if skills.dwarvish_alliance and skills.summon_gryphon then need("Gryphon Rider") end
      for i,recruit in ipairs(needed_recruits) do
        if not current_recruits[recruit] then
          if unit.extra_recruit == "" then
            unit.extra_recruit = recruit
          else
            unit.extra_recruit = unit.extra_recruit..","..recruit
          end
        end
      end
    end
    
    local literal_variables = EoHS.get_subtag(unit, "variables")
    local intimidate = false
    local harms_strength = 0
    local mana_income -- Aggregating the mana income bonus here is a little odd, but since we're doing all the other Soul Bind things here...
    local images
    local num_souls
    local special_ids_found = {}
    -- hack - don't duplicate plague or drains... TODO a better way to do this
    -- TODO make liches not combine drain and charge
    if skills.petty_necromancer then special_ids_found.plague = true end
    if original_type == "Lich" then special_ids_found.drains = true end
    for soul in helper.child_range(literal_variables, "EoHS_bound_soul") do
      num_souls = (num_souls or 0) + 1
      images = (images or "").."BeginSoulImage"..soul.image.."EndSoulImage"
      hitpoints = hitpoints + soul.max_hitpoints
      if soul.intimidate then intimidate = true end
      harms_strength = math.max(harms_strength, soul.harms_strength)
      if soul.mana_income then mana_income = (mana_income or 0) + soul.mana_income end
      for i,subtag in ipairs(soul) do
        if subtag[1] == "abilities" then
          make_effect("new_ability", { subtag })
        end
        if subtag[1] == "stacking_specials" then
          local set_specials_contents = EoHS.deep_copy(subtag[2])
          EoHS.remove_subtags(set_specials_contents, "*", function(s)
            local has_already = special_ids_found[s.id]
            special_ids_found[s.id] = true
            return has_already
          end)
          set_specials_contents.mode = "append"
          make_effect("attack", {
            range = "melee",
            { "set_specials", set_specials_contents },
          })
        end
        if subtag[1] == "non_stacking_specials" then
          for i,special in ipairs(subtag[2]) do
            if not special_ids_found[special[2].id] then
              special_ids_found[special[2].id] = true
              for attack in helper.child_range(type_cfg, "attack") do -- TODO compatibility with extra attacks?
                if attack.range == "melee" then
                  local new_attack = EoHS.deep_copy(attack)
                  -- TODO: attack names are sometimes used as identifiers...
                  --         can we give the attacks separate names without breaking more things than we fix?
                  table.insert(EoHS.force_subtag(new_attack, "specials"), special)
                  table.insert(extra_attacks, new_attack)
                end
              end
            end
          end
        end
      end
    end
    if intimidate then
      make_effect("new_ability", { { "abilities", EoHS.intimidate_abilities(unit.level) }})
    end
    if harms_strength > 0 then
      make_effect("new_ability", { { "abilities", { {"dummy",{
        name=EoHS.substitute(_"harms -$1|", {harms_strength}),
        description=EoHS.substitute(_"At the end of this unit's turn, each adjacent enemy loses $1| HP. This can't reduce a unit's HP below 1.", {harms_strength}),
      }} }}})
      EoHS.set_unit_variable(unit, "harms_strength", harms_strength)
    else
      EoHS.set_unit_variable(unit, "harms_strength", nil)
    end
    EoHS.set_unit_variable(unit, "soul_bind_mana_income", mana_income)
    EoHS.set_unit_variable(unit, "soul_bind_images", images)
    EoHS.set_unit_variable(unit, "souls_bound", num_souls)
  end

  
  type_cfg = nil -- To make sure we don't use it after this, where it could be a bug (look at the original form explicitly if you don't want the current form)
 
  -- We don't need any stacking rules for the three type-changing spells, because:
  -- Spiritform only applies to wizards, and the others only apply to nonwizards
  -- Ogre Fury only applies to humanoids, and mudcrawlers are nonhumanoid
  -- Also, only wizards can be mounted, and you can't be mounted while in spirit form.
  
  if variables.spiritform then
    -- Overwrite most stuff, but not hitpoints
    extra_attacks = {}
    extra_effects = {}
    make_effect("movement", { increase=2 })
    unit.type = observed_type
    unit.advances_to = EoHS.get_unit_type(unit.type).advances_to
    
    -- TODO: aggregate the code for these and use that for all the type-changing effects
    unit.alignment = EoHS.get_unit_type(unit.type).alignment
    unit.race = EoHS.get_unit_type(unit.type).race
  end
  
  -- TODO: Can we distribute some of these into their own files?
  if variables.touch_enchantment == "mud_touch" then
    make_effect("attack", { range="melee", { "set_specials", { mode = "append", EoHS.mud_touch_special }}})
  end
  if variables.touch_enchantment == "dispelling_touch" then
    make_effect("attack", { range="melee", { "set_specials", { mode = "append", EoHS.dispelling_touch_special }}})
  end
  if variables.touch_enchantment == "reanimating_touch" then
    make_effect("attack", { range="melee", { "set_specials", { mode = "append", EoHS.reanimating_touch_special }}})
  end
  
  if variables.ogre_fury then
    extra_attacks = {}
    extra_effects = {}
    unit.level = unit.level + 1
    unit.type = (unit.level>1) and "Ogre" or "Young Ogre"
    hitpoints = EoHS.get_unit_type(unit.type).hitpoints
    if unit.level > 2 then
      hitpoints = hitpoints + 26*(unit.level-2)
      make_effect("attack", { name = "cleaver", increase_damage = 4*(unit.level-2) })
    end
    if unit.level == 1 then
      -- Being able to make L2 Ogres from 6g Ruffians would feel unreasonable.
      -- But making L1 Young Ogres with normal stats would be very disappointing and a waste of mana/gold.
      -- So we compromise.
      hitpoints = hitpoints + 5
      make_effect("attack", { name = "cleaver", increase_damage = 3 })
    end
    unit.alignment = EoHS.get_unit_type(unit.type).alignment
    unit.race = EoHS.get_unit_type(unit.type).race
  end
  
  if variables.mud_touched then
    local movement = EoHS.get_unit_type(unit.type).movement
    for i,effect in ipairs(extra_effects) do
      if effect.apply_to == "movement" then
        if effect.set then movement = effect.set end
        if effect.increase then movement = movement + effect.increase end
      end
    end
    if unit.level < 1 then
      unit.type = "Mudcrawler"
      extra_attacks = {}
      extra_effects = {}
    else
      local best_melee  = 0
      local best_ranged = 0
      local consider_attack = function(attack)
        attack = EoHS.deep_copy(attack)
        for i,effect in ipairs(extra_effects) do
          if (effect.apply_to == "attack") and EoHS.game_action_simulations.attack_matches_filter(attack, effect) then
            attack.damage = attack.damage + effect.increase_damage
            attack.number = attack.number + effect.increase_attacks
          end
        end
        local power = attack.damage*attack.number
        if attack.range == "melee"  then best_melee  = math.max(best_melee , power) end
        if attack.range == "ranged" then best_ranged = math.max(best_ranged, power) end
      end
      for i,attack in ipairs(EoHS.get_subtags(EoHS.get_unit_type(unit.type),"attack")) do consider_attack(attack) end
      for i,attack in ipairs(extra_attacks                                           ) do consider_attack(attack) end
      
      unit.type = "Giant Mudcrawler"
      extra_attacks = {}
      extra_effects = {}
      
      local bonus = math.floor(math.abs(best_ranged - best_melee)/3)
      -- Try to keep things equal power, given that a bonus to your weaker attack is generally less good than a penalty to your primary attack.
      if best_ranged < best_melee then
           best_ranged = best_ranged + bonus
           best_melee  = best_melee  - (bonus/2)
      else best_melee  = best_melee  + bonus
           best_ranged = best_ranged - (bonus/2) end
      -- Favor ranged, because mudcrawlers do
      best_melee  = best_melee  - 2
      best_ranged = best_ranged + 2
      local swings_bonus = ((best_ranged + best_melee) > 45) and 1 or 0
      make_effect("attack", { range = "melee" , increase_damage = math.floor(0.5 + best_melee /(2+swings_bonus))-7, increase_attacks = swings_bonus })
      make_effect("attack", { range = "ranged", increase_damage = math.floor(0.5 + best_ranged/(3+swings_bonus))-5, increase_attacks = swings_bonus })
      if unit.level > 1 then
        local size = 72 + (unit.level-1)*14
        local crop =      (unit.level-1)*5
        make_effect("image_mod", { add = "~SCALE("..size..","..size..")~CROP(0,"..crop..","..size..","..(size-crop)..")" })
      end
    end
    make_effect("movement", { set = math.floor(EoHS.get_unit_type(unit.type).movement / 2) })
    unit.alignment = EoHS.get_unit_type(unit.type).alignment
    unit.race = EoHS.get_unit_type(unit.type).race
  end
  
  if variables.is_reanimated and (unit.race ~= "undead") then
    unit.race = "undead"
    unit.alignment = "chaotic"
    local example = EoHS.get_unit_type_generic_example(unit.type)
    local new_resistances = EoHS.deep_copy(EoHS.get_subtag(example, "resistance"))
    local new_movement_costs = EoHS.deep_copy(EoHS.get_subtag(example, "movement_costs"))
    local new_defenses = EoHS.deep_copy(EoHS.get_subtag(example, "defense"))
    for i,effect in ipairs(extra_effects) do
      if effect.apply_to == "resistance" then
        for k,v in pairs(EoHS.get_subtag(effect, "resistance")) do
          new_resistances[k] = (effect.replace and 0 or new_resistances[k]) + v
        end
      end
    end
    
    new_defenses      .fungus      = math.max(new_defenses      .fungus      - 10, 30)
    new_defenses      .frozen      = math.max(new_defenses      .frozen      - 10, 60)
    new_movement_costs.frozen      = math.max(new_movement_costs.frozen      -  1,  2)
    new_movement_costs.swamp_water = math.max(new_movement_costs.swamp_water -  1,  2)
    if new_movement_costs.shallow_water and not new_movement_costs.deep_water then
      new_movement_costs.deep_water = new_movement_costs.shallow_water + 1
      new_defenses      .deep_water = new_defenses      .shallow_water + 10
      make_effect("new_ability", { { "abilities", EoHS.macros.ABILITY_SUBMERGE } })
    end
    
    -- These comments were copied verbatim from the old EoHS 1.1 line, except for obvious mistakes.
    -- In general: Go for Lich-type resistances. (Lich, Ancient Lich, Death Knight, and Chocobone have those resistances at the time of this writing, with the only difference being Lich having -40% arcane instead of -50%.)
    -- A human/elf/orc/goblin should gain exact Lich resistances.
    -- Usually don't increase extreme resistances/weaknesses, because the fantasy mechanism for them is usually unrelated and non-interacting with the reason undead have these weaknesses.

    -- All existing physical undead, except the bizarre Skeletal Dragon, have either -40% or -50% arcane resistance.
    -- Decide which based on whether the unit is weak to arcane already.
    -- But don't reduce its resistance if it's already huge for some reason.
    new_resistances.arcane = math.max(new_resistances.arcane, (new_resistances.arcane > 100) and 150 or 140)

    -- All skeleton(ish) undead have -20% fire resistance. Dragons have 0%, ghouls have 10%.
    -- Leave the high fire weakness alone.
    -- Everything else does pretty much what I want if I just reduce it by 20% (cap at -20%.) Not-quite-as-fire-resistant drakes seem to make sense.
    new_resistances.fire = math.max(new_resistances.fire, math.min(120, new_resistances.fire + 20))

    -- Liches have -10% impact resist. Skeletons (including the dragon) -20%, ghouls 0%.
    -- Leave the high impact weakness alone.
    -- Units with huge impact resistance are usually that way because of attributes that SHOULDN'T change on an undead (exo-skeleton for Giant Scorpions, non-structuralness for mudcrawlers)
    -- Everything else does pretty much what I want if I just reduce it by 10% (cap at -10%.)
    new_resistances.impact = (new_resistances.impact>=50) and math.max(new_resistances.impact, math.min(110, new_resistances.impact + 10)) or new_resistances.impact

    -- Liches (and ghouls) have 10% blade resist. Skeletons (including the dragon) 40%.
    -- Leave the high blade resistance alone.
    -- Everything else does pretty much what I want if I just increase it by 10% (cap at 40%.)
    new_resistances.blade = math.min(new_resistances.blade, math.max(60, new_resistances.blade - 10))

    -- Liches (and ghouls) have 30% pierce resist. Skeletons (including the dragon) 60%.
    -- Leave the high pierce resistance alone.
    -- Everything else does pretty much what I want if I just increase it by 30% (cap at 60%.)
    new_resistances.pierce = math.min(new_resistances.pierce, math.max(40, new_resistances.pierce - 30))

    -- All skeleton(ish) undead have 60% cold resistance; ghouls have 40%.
    -- Leave the high cold resistance alone.
    -- Everything else does pretty much what I want if I just increase it by 60% (cap at 60%.)
    -- 2.0 note: Changed cap to 70%, like the ghost.
    new_resistances.cold = math.min(new_resistances.cold, math.max(30, new_resistances.cold - 60))
    
    make_effect("resistance"    , { replace=true, {"resistance"    ,new_resistances   }})
    make_effect("defense"       , { replace=true, {"defense"       ,new_defenses      }})
    make_effect("movement_costs", { replace=true, {"movement_costs",new_movement_costs}})
    make_effect("image_mod"     , { add = "~CS(90,90,90)~CS(-130,-115,-95)" })
  end
  
  if variables.is_mounted then
    local mount = EoHS.get_mount(unit)
    
    local effect_movement_costs = EoHS.deep_copy(EoHS.get_subtag(mount, "movement_costs"))
    local effect_defense        = EoHS.deep_copy(EoHS.get_subtag(mount, "defense"       ))
    
    -- Hack - because non-present values don't overwrite properly
    for i,terrain in ipairs({"deep_water","shallow_water","reef","swamp_water","flat","sand","forest","hills","mountains","village","castle","cave","frozen","unwalkable","fungus"}) do
      if not effect_movement_costs[terrain] then
        effect_movement_costs[terrain] = 99
        effect_defense       [terrain] = 100
      end
    end
    
    hitpoints = hitpoints + mount.max_hitpoints
    make_effect("movement"      , { set = mount.max_moves })
    make_effect("movement_costs", { replace = true, { "movement_costs", effect_movement_costs } })
    make_effect("defense"       , { replace = true, { "defense"       , effect_defense        } })
    for attack in helper.child_range(mount, "attack") do
      attack = EoHS.deep_copy(attack)
      table.insert(EoHS.force_subtag(attack, "specials"), { "dummy", { id = "EoHS_granted_by_mount" }})
      table.insert(extra_attacks, attack)
    end
  end
  
  local type_hitpoints = EoHS.get_unit_type(unit.type).hitpoints
  if hitpoints ~= type_hitpoints then
    make_effect("hitpoints", { increase_total = hitpoints-type_hitpoints })
  end
  local type_experience = EoHS.get_unit_type(unit.type).experience
  if experience ~= type_experience then
    make_effect("max_experience", { increase = experience-type_experience })
  end
  
  for i,attack in ipairs(extra_attacks) do attack.apply_to = "new_attack"; table.insert(extra_effects_before_extra_attacks, {"effect",attack}) end
  for i,effect in ipairs(extra_effects) do table.insert(extra_effects_before_extra_attacks, effect) end
  extra_effects,extra_attacks,extra_effects_before_extra_attacks = extra_effects_before_extra_attacks,nil,nil
  extra_effects.id = "EoHS_type_adjustment_advancement"
  
  local modifications = EoHS.force_subtag(unit, "modifications")
  EoHS.remove_subtags(modifications, "advance", "EoHS_type_adjustment_advancement")
  if extra_effects[1] then
    table.insert(modifications, 1, { "advance", extra_effects }) -- advance comes before trait or object - it's fitting for type modifications
  end
  
  -- TODO can we overwrite less stuff, to increase compatibility?
  local rewritten_subtags = {attack=true,abilities=true,defense=true,resistance=true,movement_costs=true}
  EoHS.remove_subtags(unit,"*",function(val,tagname) return rewritten_subtags[tagname] end)
  unit.max_hitpoints = nil
  unit.max_experience = nil
  unit.max_moves = nil
  unit.upkeep = "loyal" -- EoHS removes upkeep
  EoHS.get_fake_subtag(variables, "unit_attribute_memory").type = unit.type
  
  -- Wesnoth will automatically re-add these if appropriate
  EoHS.set_subtag_attribute(unit, "status.not_living")
  EoHS.remove_subtags(modifications, "trait", "undead")
  EoHS.remove_subtags(modifications, "trait", "elemental")
  EoHS.remove_subtags(modifications, "trait", "mechanical")
  
  EoHS.shallow_overwrite(unit, EoHS.create_wunit(unit).__cfg)
  
  if EoHS.get_subtag_attribute(unit, "status.not_living") then
    EoHS.set_subtag_attribute(unit, "status.poisoned")
  end
  
  -- Has to be done after the main regeneration above
  EoHS.update_conditional_abilities(unit)
  
  if not only_a_prototype then
    EoHS.standardize_unit(unit)
    EoHS.update_unit_graphics(unit)
  end
end

EoHS.leadership_abilities = function(level)
  local result = {}
  for level2 = level-1,0,-1 do
    table.insert(result, { "leadership", {
      id = "leadership",
      cumulative = false,
      value = 25*(level-level2),
      affect_self = false,
      { "affect_adjacent", {
        adjacent = "n,ne,se,s,sw,nw",
        { "filter", {
          level = level2,
        }},
      }},
             name = (level2==level-1) and EoHS.macros.ABILITY_LEADERSHIP_LEVEL_1[1][2].name or nil,
      female_name = (level2==level-1) and EoHS.macros.ABILITY_LEADERSHIP_LEVEL_1[1][2].female_name or nil,
      description = (level2==level-1) and EoHS.macros.ABILITY_LEADERSHIP_LEVEL_1[1][2].description or nil,
    }})
  end
  return result
end
EoHS.intimidate_abilities = function(level)
  local result = {}
  for level2 = level-1,0,-1 do
    table.insert(result, { "leadership", {
      id = "EoHS_intimidate",
      cumulative = false,
      value = -15*(level-level2),
      affect_self = false,
      affect_allies = false,
      affect_enemies = true,
      { "affect_adjacent", {
        adjacent = "n,ne,se,s,sw,nw",
        { "filter", {
          level = level2,
        }},
      }},
             name = (level2==level-1) and _"intimidate" or nil,
      female_name = (level2==level-1) and _"female^intimidate" or nil,
      description = (level2==level-1) and _"Adjacent enemy units of lower level will do 15% less damage times the level difference." or nil,
    }})
  end
  return result
end

-- TODO: Maybe this should be in a different file? It's not really about unit types.
local conditional_ability_data = {}
EoHS.make_conditional_ability = function(id, func)
  table.insert(conditional_ability_data, {id="EoHS_"..id,func=func})
  conditional_ability_data["EoHS_"..id] = true
end
EoHS.update_conditional_abilities = function(unit)
  local modifications = EoHS.get_subtag(unit, "modifications")
  local abilities_tag = EoHS.get_subtag(unit, "abilities")
  if abilities_tag then EoHS.remove_subtags(abilities_tag, "*", function(a) return conditional_ability_data[a.id] end) end
  EoHS.remove_subtags(modifications, "object", "EoHS_conditional_abilities_object")
  local abilities = {}
  for i,data in ipairs(conditional_ability_data) do
    local ability = data.func(unit)
    if ability then
      ability[2].id = data.id
      if not w111 then ability[2].description = EoHS.substitute("$1|:\n$2|", {ability[2].name,ability[2].description}) end
      table.insert(abilities, ability)
      if not abilities_tag then abilities_tag = EoHS.force_subtag(unit, "abilities") end
      table.insert(abilities_tag, ability)
    end
  end
  if abilities[1] then
    table.insert(modifications, {"object",{ id="EoHS_conditional_abilities_object", {"effect",{ apply_to = "new_ability", {"abilities",abilities}}}}})
  end
  
  -- We could do this. But to be polite to add-ons that add abilities crudely, we just mess with the existing abilities tag (see above).
  -- EoHS.remove_subtags(unit, "abilities")
end

-->>)}
