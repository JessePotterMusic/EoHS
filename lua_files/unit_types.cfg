{EOHS_LUA_FILE (<<-- .cfg
-- #textdomain wesnoth-Era_of_High_Sorcery

EoHS.type_adjustment_effects = function(unit)
  local effects = { id="EoHS_type_adjustment_effects" }
  if EoHS.get_unit_variable(unit, "is_wizard") then
    if (unit.type == "Mage") then
      table.insert(effects, { "effect", { apply_to="remove_attacks", name="missile", }})
    end
    if (unit.type == "Red Mage") or (unit.type == "Arch Mage") or (unit.type == "Great Mage") then
      table.insert(effects, { "effect", { apply_to="remove_attacks", name="fireball", }})
    end
    if (unit.type == "Mage") or (unit.type == "Red Mage") or (unit.type == "Arch Mage") or (unit.type == "Great Mage") then
      table.insert(effects, { "effect", {
        apply_to = "hitpoints",
        increase_total = 10 + math.min(unit.level-4, 0)*11,
      }})
      table.insert(effects, { "effect", { apply_to="resistance", replace=true, { "resistance", {
        fire   = math.min(100, 110 - math.min(EoHS.get_unit_skill("evocation"   ), unit.level * 2, 6) * 5),
        cold   = math.min(100, 110 - math.min(EoHS.get_unit_skill("necromancy"  ), unit.level * 2, 6) * 5),
        arcane = math.min(100, 110 - math.min(EoHS.get_unit_skill("nature_magic"), unit.level * 2, 6) * 5),
        blade  = 100,
        impact = 100,
        pierce = 100,
      }} }})
      table.insert(effects, { "effect", {
        apply_to = "attack",
        name = "staff",
        increase_attacks = 1,
        increase_damage  = -1 + math.min(unit.level-4, 0),
      }})
      local make_attack = function(skill_name, upgrade_array, bonus, attack)
        local skill = EoHS.get_unit_skill(skill_name)
        if skill > 0 then
          local upgrade_total = math.min(skill, unit.level * 2)
          local upgrade_array_index = math.min(#upgrade_array, upgrade_total)
          local excess = math.max(0, upgrade_total - upgrade_array_index)
          
          attack.apply_to = "new_attack"
          attack.range = "ranged"
          attack.damage = upgrade_array[upgrade_array_index][1] + math.floor(excess * bonus)
          attack.number = upgrade_array[upgrade_array_index][2]
          table.insert(attack, { "specials", { EoHS.macros.WEAPON_SPECIAL_MAGICAL } })
          table.insert(effects, { "effect", attack })
        end
      end
      make_attack("evocation",
        {{ 5,3},{ 7,3},{ 7,4},{ 8,4}}, 2,
        {
          name = "EoHS_evocation_skill_ranged_attack",
          description = _"fireball",
          icon = "attacks/fireball.png",
          type = "fire",
        }
      )
      make_attack("nature_magic",
        {{ 5,3},{ 5,4},{ 6,4},{ 7,4},{ 8,4},{8,5},{9,5},{10,5}}, 1.5,
        {
          name = "EoHS_nature_magic_skill_ranged_attack",
          description = _"faerie fire",
          icon = "attacks/faerie-fire.png",
          type = "arcane",
        }
      )
      make_attack("necromancy",
        {{ 7,2},{ 7,3},{ 8,3},{10,3}}, 2,
        {
          name = "EoHS_necromancy_skill_ranged_attack",
          description = _"chill wave",
          icon = "attacks/iceball.png",
          type = "cold",
        }
      )
      table.insert(effects, )
      table.insert(effects, )
    end
    if (unit.type == "Lich") then
      table.insert(effects, { "effect", {
        apply_to = "hitpoints",
        increase_total = 4 + math.min(unit.level-3, 0)*11,
      }})
      table.insert(effects, { "effect", {
        apply_to = "attack",
        name = "touch",
        increase_damage = math.min(unit.level-3, 0),
      }})
      do
        local upgrade_array = {{1,1},{4,1},{4,2}}
        local bonus = 3
        local upgrade_total = math.min(0, unit.level - 3)
        local upgrade_array_index = math.min(#upgrade_array, upgrade_total)
        local excess = math.max(0, upgrade_total - upgrade_array_index)
        
        if unit.level > 3 then
          table.insert(effects, { "effect", {
            apply_to = "attack",
            name = "chill tempest",
            increase_damage = upgrade_array[upgrade_array_index][1] + math.floor(excess * bonus)
            increase_attacks = upgrade_array[upgrade_array_index][2]
          }})
          table.insert(effects, { "effect", {
            apply_to = "attack",
            name = "shadow wave",
            increase_damage = math.floor((upgrade_array[upgrade_array_index][1] + excess * bonus) * 0.75)
            increase_attacks = upgrade_array[upgrade_array_index][2]
          }})
        end
      end
    end
    if EoHS.get_unit_skill("traveler") then
      table.insert(effects, { "effect", { apply_to="movement", increase=1 }})
    end
    if (unit.type == "Mage") or (unit.type == "Red Mage") or (unit.type == "Arch Mage") or (unit.type == "Great Mage") or (unit.type == "Lich") then
      if EoHS.get_unit_skill("archmage") then
        table.insert(effects, { "effect", {
          apply_to = "resistance",
          replace = false,
          { "resistance", {
            arcane = -40,
            fire   = -40,
            cold   = -40,
          }}
        }})
      end
      if EoHS.get_unit_skill("dwarvish_alliance") then
        table.insert(effects, { "effect", {
          apply_to = "resistance",
          replace = false,
          { "resistance", {
            blade  = -20,
            impact = -20,
            pierce = -20,
          }}
        }})
      end
      if EoHS.get_unit_skill("elvish_alliance") then
        table.insert(effects, { "effect", { apply_to="defense", replace=false, { "defense", {
          forest = -20,
        }} }})
        table.insert(effects, { "effect", { apply_to="movement_costs", replace=false, { "movement_costs", {
          forest = -1,
        }} }})
      end
      if EoHS.get_unit_skill("traveler") then
        table.insert(effects, { "effect", { apply_to="defense", replace=false, { "defense", {
          shallow_water = -10,
          reef = -10,
          swamp_water = -20,
          sand = -10,
          frozen = -10,
        }} }})
        table.insert(effects, { "effect", { apply_to="movement_costs", replace=false, { "movement_costs", {
          shallow_water = -1,
          swamp_water = -1,
          sand = -1,
          hills = -1,
          mountains = -1,
          cave = -1,
          frozen = -1,
        }} }})
      end
      local defenses = {}
      local d = function(terrain, bonus_levels)
        local bonus = 0
        for i,bonus_level in ipairs(bonus_levels) do
          if EoHS.get_unit_skill("nature_magic") >= bonus_level then
            bonus = bonus - 10
          end
        end
        if bonus ~= then
          defenses[terrain] = bonus
        end
      end
      d("swamp_water", {  3, 6, 9,  })
      d("forest"     , {    5,   10,})
      d("fungus"     , {       8,   })
      table.insert(effects, { "effect", {
        apply_to = "defense",
        replace = false,
        { "defense", defenses },
      }})
        [movement_costs]
            -shallow_water=3
            reef=2
            -swamp_water=3
            flat=1
            sand=2
            -forest=2
            hills=2
            -mountains=3
            village=1
            castle=1
            -cave=2
            -frozen=3
            -fungus=2
        [/movement_costs]

        [defense]
            shallow_water=80
            reef=70
            swamp_water=80
            flat=60
            sand=70
            forest=50
            hills=50
            mountains=40
            village=40
            castle=40
            cave=60
            frozen=80
            fungus=50
        [/defense]
    if skills.nature_magic_skill >= 1 then movement_costs_effect[1][2].forest = -1 end
    if skills.nature_magic_skill >= 2 then movement_costs_effect[1][2].fungus = -1 end
    if skills.nature_magic_skill >= 3 then movement_costs_effect[1][2].swamp_water = -1 end
    if skills.nature_magic_skill >= 4 then movement_costs_effect[1][2].mountains = -1 end
    if skills.nature_magic_skill >= 6 then movement_costs_effect[1][2].shallow_water = -1 end
    if skills.nature_magic_skill >= 7 then movement_costs_effect[1][2].frozen = -1 end
    if skills.nature_magic_skill >= 8 then movement_costs_effect[1][2].cave = -1 end
        [movement_costs]
            deep_water=3
            -shallow_water=2
            reef=2
            -swamp_water=2
            flat=1
            sand=2
            -forest=2
            hills=2
            -mountains=3
            village=1
            castle=1
            -cave=2
            -frozen=2
            -fungus=2
        [/movement_costs]

        [defense]
            deep_water=90
            shallow_water=80
            reef=70
            swamp_water=70
            flat=60
            sand=70
            forest=50
            hills=50
            mountains=40
            village=40
            castle=40
            cave=60
            frozen=70
            fungus=40
        [/defense]
    end
  end

  table.insert(modifications, 1, { "object", {
    id="wizard_skin_and_hair_recoloring_object",
    { "effect", {
      unit_type=redmage_line_wizard_types,
      apply_to="image_mod",
    }}
  }})
  table.insert(modifications, 1, { "object", {
    id="wizard_animations_object",
  }})
  table.insert(modifications, 1, { "object", {
    { "effect", {}}, -- for Military Commander
    { "effect", {}}, -- for Prince of Thieves; comes after military_commander object: The orders seem equally reasonable to me, but I had to make one choice of the other because I want it to be consistent, and HttT precedent says "leadership,skirmisher" not "skirmisher,leadership"
  }})
  table.insert(modifications, 1, { "object", {
    id="wizard_type_mods_object_movetype",
    { "effect", {
      unit_type = normal_wizard_types,
      apply_to = "movement_costs",
      replace = false,
      { "movement_costs", {}},
    }},
    { "effect", {
      unit_type = normal_wizard_types,
      apply_to = "defense",
      replace = false,
      { "defense", {}},
    }},
  }})
  return effects
end

EoHS.update_type_adjustment_effects = function(unit)
  local effects = EoHS.type_adjustment_effects(unit)
  local modifications = EoHS.force_subtag(unit, "modifications")
  for i,modification in ipairs(modifications) do
    local modification 
    if modifications[i][2].id = "EoHS_type_adjustment_effects" then
      if (i==1) and effects[1] then
        modifications[1][2] = effects
        return
      else
        table.remove(i)
      end
    else
      i=i+1
    end
  end
  if effects[1] then
    table.insert(modifications, 1, { "advance", effects }) -- advance comes before trait or object - it's fitting for type modifications
  end
end

>>)}
