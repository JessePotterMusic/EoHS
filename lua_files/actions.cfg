{EOHS_LUA_FILE (<<-- actions.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

EoHS.unit_has_actions = function(unit)
  return EoHS.get_unit_variable(unit, "is_wizard")
end

EoHS.unit_has_action = function(unit, id)
  local actions = EoHS.unit_actions(unit)
  for i,id2 in ipairs(actions) do
    if id2 == id then return true end
  end
  return false
end

EoHS.unit_actions = function(unit)
  local result = {}
  if EoHS.get_unit_variable(unit, "is_wizard") then
    for i,spell_id in ipairs(EoHS.spells_known_from_skillset(EoHS.get_unit_skillset(unit))) do
      table.insert(result, spell_id)
      if spell_id == "summon_skeleton" then table.insert(result, "summon_skeleton_archer") end
    end
    --table.insert(result, "summon_wolf")
  end
  return result
end

local standard_action_aspects = {
  "ap","mana","range","target",
}
local g = function(contents) return { "grid", contents } end
local r = function(contents) return { "row", contents } end
local c = function(contents) return { "column", contents } end
local spacer = { "spacer", {}}

EoHS.action_list_entry_canvas = function(strings, image)
  local result = {}
  
  local texts = {
    { w = 200, },
    { w = 25, },
    { w = 45, },
    { w = 50, },
    { w = 90, },
  }
  for i,string in ipairs(strings) do
    local text = texts[i]
    text.y = EoHS.macros.GUI__TEXT_VERTICALLY_CENTRED
    if texts[i-1] then
      text.x = texts[i-1].x + texts[i-1].w + 3
    else
      text.x = 6
    end
    text.h = "(text_height)"
    text.font_size = 14
    text.color = EoHS.validity_color(string[1])
    text.text = string[2]
  end
  for i,text in ipairs(texts) do
    text.x = "("..(text.x+text.w).."-text_width)"
    table.insert(result, {"text",text})
  end
  if image then
    table.insert(result, {"image",{
      x=0,y=0,w="(height)",h="(height)",
      name=image,
    }})
  end
  
  return result
end
local action_list_entry_size_str = "mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm\nm"


EoHS.action_dialog_stuff = function(dialog_context, parameters, list_entry_only, selected, switch_func_func)
  local action = EoHS.actions[parameters.action_id]
  
  local cost = EoHS.action_cost(parameters)
  local range = EoHS.action_range(parameters)
  local whole_action_validity = "valid"
  local actor
  local action_image = action.image
  if parameters.actor_id then
    actor = EoHS.get_unit(parameters.actor_id)
    action_image = EoHS.mod_all_component_images(action_image, EoHS.TC_image_mod(actor.side, "magenta"))
  end
  
  local standard_aspects = {}
  local extra_aspects = {}
  local make_aspect = function(type_label, value_label, details_label, validity, index)
    if not validity then validity = "valid" end
    if validity == "impossible" then whole_action_validity = "impossible" end
    if validity == "undesirable" and whole_action_validity == "valid" then whole_action_validity = "undesirable" end
    if list_entry_only then
      if index then standard_aspects[index] = { validity, value_label } end
    else
      local    type_widget = EoHS.label_with_validity(dialog_context, validity, {label=    type_label}, "right")
      local   value_widget = EoHS.label_with_validity(dialog_context, validity, {label=   value_label}, "left")
      local details_widget = EoHS.label_with_validity(dialog_context, validity, {label= details_label}, "left")
      local row = r{
        c{horizontal_grow=true, border="right", border_size=9, type_widget},
        c{horizontal_grow=true, border="right", border_size=9, value_widget},
        c{horizontal_grow=true, border="right", border_size=9, details_widget},
      }
      if index then standard_aspects[index] = row
      else table.insert(extra_aspects, row) end
    end
  end
  if cost.action_points then
    make_aspect(_"AP:", ""..cost.action_points, "", (EoHS.unit_action_points(actor) >= cost.action_points) and "valid" or "impossible", "ap")
  end
  if cost.mana then
    local mana = math.max(0, EoHS.get_unit_variable(actor, "mana"))
    local validity = "valid"
    local label
    local details = ""
    if mana >= cost.mana then
      label = ""..cost.mana
    elseif EoHS.get_wizard_setting(actor, "can_spend_gold_on_spells") and (mana+wesnoth.sides[actor.side].gold >= cost.mana) then
      details = EoHS.substitute(_"You will transmute $1| gold into mana", {cost.mana-mana})
    else
      validity = "impossible"
    end
    make_aspect(_"Mana cost:", ""..cost.mana, details, validity, "mana")
  end
  if action.target_type then
    local target_type = action.target_type(parameters)
    make_aspect(_"Target type:", list_entry_only and target_type.short_name or target_type.name, target_type.details, target_type.validity, "target")
    
    if range then
      local dist = EoHS.distance_between(
             actor.       x,      actor.       y,
        parameters.target_x, parameters.target_y,
        EoHS.known_passable_only(), range)
      make_aspect(_"Range:", ""..range, "", (dist and (dist <= range)) and "valid" or "impossible", "range")
    end
  end
  if action.make_extra_attributes then
    action.make_extra_attributes(parameters, {
      type_value_and_details = make_aspect,
      type_and_details = function(t,d,v) make_aspect(t,"",d,v) end,
    })
  end
  
  if list_entry_only then
    local strings = {
      { whole_action_validity, action.name },
    }
    for i,id in ipairs(standard_action_aspects) do
      table.insert(strings, standard_aspects[id] or {"valid", ""})
    end
    --TODO damage entry
    
    return r{c{EoHS.fake_listbox_entry(dialog_context, action_list_entry_size_str, EoHS.action_list_entry_canvas(strings, action_image), selected, switch_func_func(parameters.action_id))}}, whole_action_validity
  else
    local aspect_rows = {}
    for i,id in ipairs(standard_action_aspects) do
      if standard_aspects[id] then
        table.insert(aspect_rows, standard_aspects[id])
      end
    end
    for i,aspect in ipairs(extra_aspects) do
      table.insert(aspect_rows, aspect)
    end
    
    local rows = {
      r{c{ horizontal_grow=true, border="all",border_size=9, 
        g{r{
          c{ vertical_alignment="top",border="right",border_size=4, {"image",{label=action_image}} },
          c{ horizontal_grow=true,grow_factor=2, g{
            r{c{horizontal_alignment="left",{"label",{label=action.name,definition="title"}} }},
            r{c{horizontal_alignment="left",border="all",border_size=9, {"label",{wrap=true,label=action.description}} }}
          }}
        }}
      }},
      r{c{g(aspect_rows)}},
    }
    
    if action.parameters_dialog_grid then
      table.insert(rows, r{c{action.parameters_dialog_grid(dialog_context, parameters)}})
    end
    return g(rows), whole_action_validity
  end
end

EoHS.actions_grid = function(dialog_context, parameters, switch_func_func)
  local actor = EoHS.get_unit(parameters.actor_id)
  local cost = (parameters.action_id and EoHS.action_cost(parameters)) or {}
  local resource_rows = {}
  local make_resource_row = function(name, amount, spent)
    local validity = (spent and (amount < spent)) and "impossible" or "valid"
    local cols = {
      c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, validity, { definition = "default_large", label = name   }, "right") },
      c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, "valid" , { definition = "default_large", label = amount }, "right") },
    }
    if spent then
      table.insert(cols, c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, "undesirable", { definition = "default_large", label = " - "          }, "right") })
      table.insert(cols, c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, "undesirable", { definition = "default_large", label = spent          }, "right") })
      table.insert(cols, c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, validity,      { definition = "default_large", label = " = "          }, "right") })
      table.insert(cols, c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, validity,      { definition = "default_large", label = (amount-spent) }, "right") })
    else
      table.insert(cols, c{ {"spacer",{}} })
      table.insert(cols, c{ {"spacer",{}} })
      table.insert(cols, c{ {"spacer",{}} })
      table.insert(cols, c{ {"spacer",{}} })
    end
    table.insert(resource_rows, r(cols))
  end
  
  local mana = EoHS.get_unit_variable(actor, "mana")
  local can_spend_gold_on_spells = EoHS.get_wizard_setting(actor, "can_spend_gold_on_spells")
  make_resource_row(_"Mana: ", mana, (can_spend_gold_on_spells and cost.mana) and math.min(mana,cost.mana) or cost.mana)
  if can_spend_gold_on_spells then
    local gold = wesnoth.sides[actor.side].gold
    make_resource_row(_"Gold: ", gold, cost.mana and math.max(0, cost.mana - mana))
    make_resource_row(_"Total: ", mana+gold, cost.mana)
  end
  make_resource_row(_"AP: ", EoHS.unit_action_points(actor), cost.action_points)
  
  if parameters.action_id then
    local standard_action_aspect_names = {
      ap=_"AP",mana=_"Mana",target=_"Target",range=_"Range",
    }
    local key_strings = {{"valid",""}}
    for i,id in ipairs(standard_action_aspects) do
      table.insert(key_strings, { "valid", standard_action_aspect_names[id] })
    end
    --TODO damage entry
    local key_label = {"label",{id = dialog_context.make_unique_id(), label="mmmmmmmmm"}}
    dialog_context.preshow(function()
      wesnoth.set_dialog_canvas(1, EoHS.action_list_entry_canvas(key_strings), key_label[2].id)
    end)
    
    local rows = {}
    local rolling_parameters = EoHS.deep_copy(parameters)
    local actions = EoHS.unit_actions(actor)
    --TODO: "all actions / known actions / usable actions"
    for i,id in ipairs(actions) do
      rolling_parameters.action_id = id
      local row, validity = EoHS.action_dialog_stuff(dialog_context, rolling_parameters, true, rolling_parameters.action_id==parameters.action_id, switch_func_func)
      table.insert(rows, row)
    end
  
    local action = EoHS.actions[parameters.action_id]
    local grid
    grid, current_action_validity = EoHS.action_dialog_stuff(dialog_context,parameters)
    local cast_str
    local thumbnail_size_str = "mmmmmmm"
    local button_size_str
    if action.target_type then
      local target_unit = EoHS.get_seen_unit(parameters.target_x, parameters.target_y, actor.side)
      local target_str
      if target_unit then
           cast_str = EoHS.substitute(_"Cast <b>$1|</b> at <b>$4|</b> ($2|,$3|)", {action.name, parameters.target_x, parameters.target_y, ((target_unit.name == "") and target_unit.language_name or target_unit.name)})
      else cast_str = EoHS.substitute(_"Cast <b>$1|</b> at ($2|,$3|)",            {action.name, parameters.target_x, parameters.target_y}) end
      button_size_str = cast_str..thumbnail_size_str
    else
      cast_str = EoHS.substitute(_"Cast <b>$1|</b>", {action.name})
      button_size_str = cast_str
    end
    button_size_str = string.gsub(button_size_str, "%b<>", "")
    -- lolhack: account for the fact that the button-sizing is based on a different size of text than what I write in afterwards
    button_size_str = string.gsub(button_size_str, "(.)(......)", function(a,b) return a..a..b end)
    local canvas = { {"text",{
      x = EoHS.macros.GUI__TEXT_HORIZONTALLY_CENTRED,
      y = EoHS.macros.GUI__TEXT_VERTICALLY_CENTRED,
      w = "(text_width)",
      h = "(text_height)",
      font_size = 14,
      color = EoHS.validity_color(current_action_validity),
      text = cast_str,
      text_markup = true
    }} }
    if action.target_type then
      EoHS.add_hex_canvas(canvas, parameters.target_x, parameters.target_y, actor.side, {
        x = "(width-(10+image_width))",
        y = "((height/2)-(image_height/2))",
        w = "58",
        h = "58",
      })
    end
    button_size_str = "m\nm\n"..thumbnail_size_str..button_size_str.."\nm\nm"
    EoHS.add_hex_canvas(canvas, actor.x, actor.y, actor.side, {
      x = "10",
      y = "((height/2)-(image_height/2))",
      w = "58",
      h = "58",
    })
    local cast_button = {"button",{id="ok",label=button_size_str}}
    dialog_context.preshow(function()
      EoHS.set_canvas_over_button(canvas, "ok")
    end)
    if current_action_validity == "impossible" then dialog_context.preshow(function() wesnoth.set_dialog_active(false, "ok") end) end
    return g{
      r{ c{ border="top", border_size=9, g(resource_rows)
        --{ "label", { definition = "default_large",
        --  label = EoHS.substitute(_"You have: $1| AP, $2| mana, $3| gold", {EoHS.unit_action_points(actor),EoHS.get_unit_variable(actor,"mana"),wesnoth.sides[actor.side].gold}) } },
      } },
      r{ c{ border="all", border_size=4, g{r{c{ {"spacer",{height=180}} },c{vertical_grow=true, g{
        r{c{horizontal_grow=true, border="bottom", border_size=3, key_label}},
        r{ grow_factor=2, c{vertical_grow=true, {"scrollbar_panel",{ horizontal_scrollbar_mode="never", {"definition", rows } }} }}
      }} }} }, },
      r{ c{ cast_button, } },
      r{ c{ border="top", border_size=4, grid }, },
    }
  else
    return g{r{ c{ border="top", border_size=9, g(resource_rows) } },r{c{ border="all", border_size=14, {"label",{label=_"You have no actions to use."}} }}}
  end
end

EoHS.do_action = function(parameters)
  local action = EoHS.actions[parameters.action_id]
  local cost = EoHS.action_cost(parameters)
  EoHS.pay_action_cost(parameters, cost)
  EoHS.actions[parameters.action_id].happen(parameters, cost)
end

EoHS.pay_action_cost = function(parameters, cost)
  if cost.mana then
    EoHS.deduct_mana_andor_gold(parameters.actor_id, cost.mana)
  end
  if cost.action_points then
    local actor = EoHS.get_unit(parameters.actor_id)
    EoHS.modify_action_points(actor, -cost.action_points)
    -- and if it uses action points then it's tiring
    actor.resting = false
    EoHS.put_unit(actor)
  end
end

EoHS.unit_action_points = function(unit)
  return (6*unit.attacks_left) + EoHS.get_unit_variable(unit, "extra_action_points")
end

EoHS.modify_action_points = function(unit, amount)
  local extra_action_points = EoHS.get_unit_variable(unit, "extra_action_points")
  extra_action_points = extra_action_points + amount
  while extra_action_points < 0 do
    unit.attacks_left = unit.attacks_left - 1
    extra_action_points = extra_action_points + 6
  end
  while extra_action_points >= 6 do
    unit.attacks_left = unit.attacks_left + 1
    extra_action_points = extra_action_points - 6
  end
  EoHS.set_unit_variable(unit, "extra_action_points", extra_action_points)
end

EoHS.deduct_mana_andor_gold = function(unit_id, amount)
  local unit = EoHS.get_unit(unit_id)
  local mana = EoHS.get_unit_variable(unit, "mana")
  if mana <= 0 then
    wesnoth.sides[unit.side].gold = wesnoth.sides[unit.side].gold - amount
  elseif mana < amount then
    EoHS.set_unit_variable(unit, "mana", 0)
    wesnoth.sides[unit.side].gold = wesnoth.sides[unit.side].gold + mana - amount
  else
    EoHS.set_unit_variable(unit, "mana", mana - amount)
  end
  EoHS.put_unit(unit)
end

EoHS.unit_mana_income = function(unit)
  if EoHS.get_unit_variable(unit, "is_wizard") then
    return EoHS.get_wizard_setting(unit, "mana_income_per_level")*unit.level
  end
end
EoHS.unit_mana_cap = function(unit)
  if EoHS.get_unit_variable(unit, "is_wizard") then
    local setting = EoHS.get_wizard_setting(unit, "mana_capacity_per_level")
    if setting == "infinite" then return nil end
    return setting*unit.level
  end
end
EoHS.earn_mana_income = function(unit)
  if wesnoth.current.turn > 1 then -- parallel to built-in rule about gold income
    local mincome = EoHS.unit_mana_income(unit)
    if mincome and (mincome > 0) then
      local mcap = EoHS.unit_mana_cap(unit)
      local old_mana = EoHS.get_unit_variable(unit, "mana")
      if (not mcap) or (old_mana < mcap) then
        local new_mana = old_mana + mincome
        if mcap and (new_mana > mcap) then
          new_mana = mcap
        end
        EoHS.set_unit_variable(unit, "mana", new_mana)
        return true
      end
    end
  end
  return false
end

EoHS.action_cost = function(parameters)
  local action = EoHS.actions[parameters.action_id]
  local cost
  if type(action.base_cost) == "function" then
    cost = action.base_cost(parameters)
  else
    cost = EoHS.deep_copy(action.base_cost)
  end
  
  local actor = EoHS.get_unit(parameters.actor_id)
  if actor and action.is_summon then
    if cost.action_points and EoHS.get_unit_skill(actor, "summoner") then
      cost.action_points = math.ceil(cost.action_points * 0.6)
    end
    local multiplier = EoHS.get_wizard_setting(actor, "summon_cost_multiplier")
    if cost.mana and multiplier then
      cost.mana = math.ceil(cost.mana * multiplier / 100)
    end
  end
  if cost.mana and EoHS.get_unit_skill(actor, "efficiency") then
    cost.mana = math.ceil(cost.mana * 0.8)
  end
  if cost.action_points and EoHS.get_unit_skill(actor, "enchanter") and action.is_enchantment then
    cost.action_points = math.ceil(cost.action_points * 0.6)
  end
  return cost
end

EoHS.action_range = function(parameters)
  local action = EoHS.actions[parameters.action_id]
  local range
  if type(action.base_range) == "function" then
    range = action.base_range(parameters)
  else
    range = action.base_range
  end
  if not range then return nil end
  
  local actor = EoHS.get_unit(parameters.actor_id)
  if EoHS.get_unit_skill(actor, "farseer") then
    range = range * 2
  end
  return range
end

-- TODO is it safe to assume that actions are only done by wesnoth.current.side?
EoHS.target_types = {
  hex = function(parameters) return {
    short_name = _"hex",
    name = _"Any hex",
    details = "",
    validity = EoHS.location_is_on_the_map(parameters.target_x,parameters.target_y) and "valid" or "impossible"
  } end,
  empty_hex = function(parameters)
    local unit = EoHS.get_seen_unit(parameters.target_x,parameters.target_y,wesnoth.current.side)
    local unfogged = EoHS.hex_is_unfogged(parameters.target_x,parameters.target_y)
    return {
      short_name = _"empty hex",
      name = _"Empty hex",
      details = ((not unfogged) and _"You can't tell if that hex is occupied" or ""),
      validity = (unfogged and not unit) and "valid" or "impossible"
    }
  end,
  unit = function(parameters)
    local unit = EoHS.get_seen_unit(parameters.target_x,parameters.target_y,wesnoth.current.side)
    local unfogged = EoHS.hex_is_unfogged(parameters.target_x,parameters.target_y)
    return {
      short_name = _"unit",
      name = _"Any unit",
      details = ((not unfogged) and _"You can't tell if there is a unit there" or ""),
      validity = (unit and unfogged) and "valid" or "impossible"
    }
  end,
  unit_probably_enemy = function(parametersa)
    local unit = EoHS.get_seen_unit(parameters.target_x,parameters.target_y,wesnoth.current.side)
    local unfogged = EoHS.hex_is_unfogged(parameters.target_x,parameters.target_y)
    local is_enemy = unit and wesnoth.is_enemy(unit.side, wesnoth.current.side)
    return {
      short_name = _"enemy",
      name = _"Any unit",
      details = ((not unfogged) and _"You can't tell if there is a unit there" or ((unit and not is_enemy) and _"You probably don't want to cast that at an ally" or "")),
      validity = ((unit and unfogged)
        and (is_enemy and "valid" or "undesirable")
        or "impossible")
    }
  end,
  unit_probably_ally = function(parameters)
    local unit = EoHS.get_seen_unit(parameters.target_x,parameters.target_y,wesnoth.current.side)
    local unfogged = EoHS.hex_is_unfogged(parameters.target_x,parameters.target_y)
    local is_enemy = unit and wesnoth.is_enemy(unit.side, wesnoth.current.side)
    return {
      short_name = _"ally",
      name = _"Any unit",
      details = ((not unfogged) and _"You can't tell if there is a unit there" or ((unit and is_enemy) and _"You probably don't want to cast that at an enemy" or "")),
      validity = ((unit and unfogged)
        and (is_enemy and "undesirable" or "valid")
        or "impossible")
    }
  end,
}

EoHS.action_message = function(parameters, string)
  local values = EoHS.deep_copy(parameters)
  values.action = {}
  for k,v in pairs(EoHS.actions[parameters.action_id]) do
    if (type(k) == "string") and (type(v) ~= "function") and (type(v) ~= "table") then values.action[k] = v end
  end
  if parameters.actor_id then
    values.actor = EoHS.get_unit(parameters.actor_id)
    if values.actor and (values.actor.name == "") then
      values.actor.name = values.actor.language_name
    end
  end
  if parameters.target_x then
    values.target = EoHS.get_unit(parameters.target_x, parameters.target_y)
    if values.target and (values.target.name == "") then
      values.target.name = values.target.language_name
    end
  end
  EoHS.message(EoHS.substitute(string, values), parameters.actor_id)
end
EoHS.cast_message_no_target = function(parameters)
  EoHS.action_message(parameters,
    _"$actor.name| ($actor.x|,$actor.y|) casts $action.name|.")
end
EoHS.cast_message_location_target = function(parameters)
  EoHS.action_message(parameters,
    _"$actor.name| ($actor.x|,$actor.y|) casts $action.name| at ($target_x|,$target_y|).")
end
EoHS.cast_message_unit_target = function(parameters)
  EoHS.action_message(parameters,
    _"$actor.name| ($actor.x|,$actor.y|) casts $action.name| at $target.name| ($target.x|,$target.y|).")
end

EoHS.begin_casting = function(actor_id, target_x, target_y)
  local actor = EoHS.get_unit(actor_id)
  wesnoth.scroll_to_tile(actor.x, actor.y, true)

  if target_x then
    EoHS.face_towards(actor, target_x, target_y)
  end

  EoHS.set_unit_variable(actor, "is_casting_a_spell", true)
  EoHS.update_unit_graphics(actor)
  wesnoth.fire("animate_unit", {
    flag = "EoHS_start_casting",
    with_bars = true,
    { "filter", { x=actor.x, y=actor.y, }},
  })
  EoHS.put_unit(actor, {immediate=true})
  if target_x then
    wesnoth.scroll_to_tile(target_x, target_y, true)
  end
end

EoHS.finish_casting = function(actor_id)
  local actor = EoHS.get_unit(actor_id)
  -- In rare cases, the spell might have killed the caster, so only proceed if they can be found:
  if actor then
    EoHS.set_unit_variable(actor, "is_casting_a_spell")
    EoHS.update_unit_graphics(actor)
    EoHS.put_unit(actor, {immediate=true})
    wesnoth.fire("animate_unit", {
      flag = "EoHS_stop_casting",
      with_bars = true,
      { "filter", { x=actor.x, y=actor.y, }},
    })
  end
end

EoHS.make_action = function(id, action)
  if (type(action.image) ~= "string") or not (string.match(action.image, "attacks/") or string.match(action.image, "icons/")) then
    action.image = EoHS.collapse_image_aggregate(EoHS.image_aggregates_combined(
      "attacks/blank-attack.png",
      EoHS.image_aggregate_cropped(action.image, {size={x=50,y=50},offset={x=0,y=0}})
    ), "image_modded")
  end
  EoHS.actions[id] = action
end

>>)}
