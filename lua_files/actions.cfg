this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- actions.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

local w111 = wesnoth.compare_versions(wesnoth.game_config.version, ">=", "1.11.0")

EoHS.unit_has_actions = function(unit)
  return EoHS.get_unit_variable(unit, "is_wizard") or EoHS.has_unit_variable("is_mounted") or EoHS.has_unit_variable("num_scrolls") or (EoHS.has_unit_variable("is_summon") and ((unit.type == "Fire Dragon") or (unit.type == "Yeti")))
end
EoHS.soon(function() EoHS.unit_has_actions_filter = {"and",{
  EoHS.has_unit_variable("is_wizard"),
  {"or",{
    EoHS.has_unit_variable("is_mounted"),
  }},
  {"or",{
    EoHS.has_unit_variable("num_scrolls"),
  }},
  {"or",{
    EoHS.has_unit_variable("is_summon"),
    type = "Fire Dragon,Yeti"
  }},
}} end)

EoHS.unit_has_action = function(unit, id)
  local actions = EoHS.unit_actions(unit)
  for i,id2 in ipairs(actions) do
    if id2 == id then return true end
  end
  return false
end

EoHS.unit_actions = function(unit)
  local result = {}
  if EoHS.get_unit_variable(unit, "ritual") then
    table.insert(result, "cancel_ritual")
  end
  if EoHS.get_unit_variable(unit, "spiritform") then
    table.insert(result, "end_spiritform")
  end
  if EoHS.get_unit_variable(unit, "is_mounted") then
    table.insert(result, "dismount")
  end
  if EoHS.get_unit_variable(unit, "touch_enchantment") == "dispelling_touch" then
    table.insert(result, "use_dispelling_touch")
  end
  if EoHS.get_unit_variable(unit, "touch_enchantment") == "reanimating_touch" then
    table.insert(result, "use_reanimating_touch")
  end
  if EoHS.get_unit_variable(unit, "touch_enchantment") == "mud_touch" then
    table.insert(result, "use_mud_touch")
  end
  if EoHS.get_unit_skill(unit, "mentor") and EoHS.get_wizard_setting(unit, "can_recruit") then
    table.insert(result, "train_apprentice")
  end
  if EoHS.get_unit_variable(unit, "is_summon") then
    if unit.type == "Yeti" then
      table.insert(result, "earthworks")
    end
    if unit.type == "Fire Dragon" then
      table.insert(result, "dragon_breath")
    end
  end
  if EoHS.get_unit_variable(unit, "is_wizard") then
    if EoHS.get_resummonable_wunits(unit)[1] then table.insert(result, "resummon") end
    for i,spell_id in ipairs(EoHS.spells_known_from_skillset(EoHS.get_unit_skillset(unit))) do
      table.insert(result, spell_id)
      if spell_id == "summon_skeleton" then table.insert(result, "summon_skeleton_archer") end
      if spell_id == "summon_vampire_bat" then table.insert(result, "absorb_bats") end
      if spell_id == "vex_dragon_bones" then table.insert(result, "command_dragon_bones") end
    end
    --table.insert(result, "summon_wolf")
  end
  return result
end

local standard_action_aspects = {
  "ap","mana","range","target",
}
local g = function(contents) return { "grid", contents } end
local r = function(contents) return { "row", contents } end
local c = function(contents) return { "column", contents } end
local spacer = { "spacer", {}}

EoHS.action_list_entry_canvas = function(strings, image)
  local result = {}
  
  local texts = {
    { w = 200, },
    { w = 25, },
    { w = 45, },
    { w = 50, },
    { w = 90, },
  }
  for i,string in ipairs(strings) do
    local text = texts[i]
    text.y = EoHS.macros.GUI__TEXT_VERTICALLY_CENTRED
    if texts[i-1] then
      text.x = texts[i-1].x + texts[i-1].w + 3
    else
      text.x = 6
    end
    text.h = "(text_height)"
    text.font_size = 14
    text.color = EoHS.validity_color(string[1])
    text.text = string[2]
  end
  for i,text in ipairs(texts) do
    text.x = "("..(text.x+text.w).."-text_width)"
    table.insert(result, {"text",text})
  end
  if image then
    table.insert(result, {"image",{
      x=0,y=0,w="(height)",h="(height)",
      name=image,
    }})
  end
  
  return result
end
local action_list_entry_size_str = "mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm\nm"

EoHS.restrict_validity = function(v1,v2)
  if (v1 == "impossible") or (v2 == "impossible") then return "impossible" end
  if (v1 == "undesirable") or (v2 == "undesirable") then return "undesirable" end
  return "valid"
end

EoHS.action_dialog_stuff = function(dialog_context, parameters, ghost_distance_to_target, list_entry_only, selected, switch_func_func)
  local action = EoHS.actions[parameters.action_id]
  
  local cost = EoHS.action_cost(parameters)
  local range = EoHS.action_range(parameters)
  local whole_action_validity = "valid"
  local whole_action_scroll_validity = "valid"
  local actor
  local action_image = action.image
  local action_name = action.name
  if parameters.actor_id then
    actor = EoHS.get_unit(parameters.actor_id)
    action_image = EoHS.mod_all_component_images(action_image, EoHS.TC_image_mod(actor.side, "magenta"))
  end
  if parameters.scroll_id then
    action_image = "attacks/blank-attack.png~O(0)~BLIT(icons/scroll_red.png~SCALE(40,40),0,0)~BLIT("..action_image.."~SCALE(40,40),20,20)"
    action_name = EoHS.substitute(_"Scroll of $1|", {action_name})
  end
  
  local standard_aspects = {}
  local extra_aspects = {}
  local make_aspect = function(s)
    if not s.validity then s.validity = "valid" end
    whole_action_validity = EoHS.restrict_validity(whole_action_validity, s.validity)
    if not s.doesnt_affect_scribing then
      whole_action_scroll_validity = EoHS.restrict_validity(whole_action_scroll_validity, s.validity)
    end
    if list_entry_only then
      if s.standard_aspect_index then standard_aspects[s.standard_aspect_index] = { s.validity, s.value } end
    else
      local    type_widget = EoHS.label_with_validity(dialog_context, s.validity, {label=(s.type or "")}, "right")
      local   value_widget = EoHS.label_with_validity(dialog_context, s.validity, {label=(s.value or "")}, "left")
      local details_widget = {"label",{wrap=true,characters_per_line=40,label=(s.details or "")}}
      local row = r{
        c{horizontal_grow=true, border="right", border_size=9, type_widget},
        c{horizontal_grow=true, border="right", border_size=9, value_widget},
        c{horizontal_grow=true, border="right", border_size=9, details_widget},
      }
      if s.standard_aspect_index then standard_aspects[s.standard_aspect_index] = row
      else table.insert(extra_aspects, row) end
    end
  end
  
  local target_type = action.target_type and action.target_type(parameters)
  
  if action.is_spell and (EoHS.get_unit_variable(actor, "spiritform")) or (EoHS.get_unit_variable(actor, "ogre_fury")) then
    make_aspect({type=_"Transformed:", details=_"You can't cast spells while transformed.", validity="impossible"})
  end
  if target_type and EoHS.location_is_enemy_circle_of_protection(parameters.target_x, parameters.target_y, actor.side) then
    make_aspect({
      type=_"Circle of protection:",
      details=_"You can't target any action at an enemy circle of protection.",
      validity="impossible",
      doesnt_affect_scribing = true,
    })
  end
  if cost.action_points then
    make_aspect({
      type=_"AP:",
      value=""..cost.action_points,
      validity=(EoHS.get_unit_action_points(actor) >= cost.action_points) and "valid" or "impossible",
      standard_aspect_index = "ap",
    })
  end
  if cost.mana then
    local s = {
      type=_"Mana cost:",
      value=""..cost.mana,
      standard_aspect_index = "mana",
    }
    local mana = math.max(0, EoHS.get_unit_variable(actor, "mana"))
    if mana >= cost.mana then
      -- ... 
    elseif EoHS.get_wizard_setting(actor, "can_spend_gold_on_spells") and (mana+wesnoth.sides[actor.side].gold >= cost.mana) then
      s.details = EoHS.substitute(_"You will transmute $1| gold into mana", {cost.mana-mana})
    else
      s.validity = "impossible"
    end
    make_aspect(s)
  end
  if cost.gold then
    make_aspect({
      type=_"Gold cost:",
      value=""..cost.gold,
      validity=(wesnoth.sides[actor.side].gold >= cost.gold) and "valid" or "impossible",
    })
  end
  if target_type then
    make_aspect({
      type=_"Target type:",
      value=list_entry_only and target_type.short_name or target_type.name,
      details=target_type.details,
      validity=target_type.validity,
      standard_aspect_index = "target",
      doesnt_affect_scribing = true,
    })
    
    if range then
      make_aspect({
        type=_"Range:",
        value=""..range,
        validity=(ghost_distance_to_target and (ghost_distance_to_target <= range)) and "valid" or "impossible",
        standard_aspect_index = "range",
        doesnt_affect_scribing = true,
      })
    end
  end
  if action.make_extra_attributes then
    -- backwards compatibility...
    action.make_extra_attributes(parameters, setmetatable({
      type_value_and_details = function(t,v,d,va) make_aspect({
        type=t,
        value=v,
        details=d,
        validity=va,
      }) end,
      type_and_details = function(t,d,va) make_aspect({
        type=t,
        details=d,
        validity=va,
      }) end,
    }, {__call=function(f,s) make_aspect(s) end}), list_entry_only)
  end
  
  if list_entry_only then
    local strings = {
      { whole_action_validity, action_name },
    }
    for i,id in ipairs(standard_action_aspects) do
      table.insert(strings, standard_aspects[id] or {"valid", ""})
    end
    --TODO damage entry
    
    return r{c{EoHS.fake_listbox_entry(dialog_context, action_list_entry_size_str, EoHS.action_list_entry_canvas(strings, action_image), selected, switch_func_func(parameters.action_id, parameters.scroll_id))}}, whole_action_validity, whole_action_scroll_validity, target_type
  else
    local aspect_rows = {}
    for i,id in ipairs(standard_action_aspects) do
      if standard_aspects[id] then
        table.insert(aspect_rows, standard_aspects[id])
      end
    end
    for i,aspect in ipairs(extra_aspects) do
      table.insert(aspect_rows, aspect)
    end
    
    local rows = {}
    if action.extra_parameters_dialog_grid then
      local grid = action.extra_parameters_dialog_grid(dialog_context, parameters)
      if grid then table.insert(rows, r{c{grid}}) end
    end
    table.insert(rows, r{c{ horizontal_grow=true, border="all",border_size=9, 
        g{r{
          c{ vertical_alignment="top",border="right",border_size=4, {"image",{label=action_image}} },
          c{ horizontal_grow=true,grow_factor=2, g{
            r{c{horizontal_alignment="left",{"label",{label=action_name,definition="title"}} }},
            r{c{horizontal_alignment="left",border="all",border_size=9, {"label",{wrap=true,characters_per_line=70,label=action.description}} }}
          }}
        }}
      }})
    table.insert(rows, r{c{g(aspect_rows)}})
    return g(rows), whole_action_validity, whole_action_scroll_validity, target_type
  end
end

EoHS.actions_grid = function(dialog_context, parameters, subjects_grid, target_grid_func, switch_func_func, scribe_func)
  local actor = EoHS.get_unit(parameters.actor_id)
  local ghost_distance_to_target
  if parameters.target_x then
    ghost_distance_to_target = EoHS.distance_between(
          actor.       x,      actor.       y,
     parameters.target_x, parameters.target_y,
     EoHS.known_passable_only(actor.side), 100)
  end
  local cost = (parameters.action_id and EoHS.action_cost(parameters)) or {}
  local resource_rows = {}
  local make_resource_row = function(name, amount, spent)
    local validity = (spent and (amount < spent)) and "impossible" or "valid"
    local cols = {
      c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, validity, { definition = "default_large", label = name   }, "right") },
      c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, "valid" , { definition = "default_large", label = amount }, "right") },
    }
    if spent then
      table.insert(cols, c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, "undesirable", { definition = "default_large", label = " - "          }, "right") })
      table.insert(cols, c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, "undesirable", { definition = "default_large", label = spent          }, "right") })
      table.insert(cols, c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, validity,      { definition = "default_large", label = " = "          }, "right") })
      table.insert(cols, c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, validity,      { definition = "default_large", label = (amount-spent) }, "right") })
    else
      table.insert(cols, c{ {"spacer",{}} })
      table.insert(cols, c{ {"spacer",{}} })
      table.insert(cols, c{ {"spacer",{}} })
      table.insert(cols, c{ {"spacer",{}} })
    end
    table.insert(resource_rows, r(cols))
  end
  
  local mana = EoHS.get_unit_variable(actor, "mana")
  local can_spend_gold_on_spells = EoHS.get_wizard_setting(actor, "can_spend_gold_on_spells")
  make_resource_row(_"Mana: ", mana, (can_spend_gold_on_spells and cost.mana) and math.min(mana,cost.mana) or cost.mana)
  if can_spend_gold_on_spells or cost.gold then
    local gold = wesnoth.sides[actor.side].gold
    make_resource_row(_"Gold: ", gold, (cost.mana or cost.gold) and ((cost.gold or 0) + math.max(0, (cost.mana or 0) - mana)))
    if can_spend_gold_on_spells then
      make_resource_row(_"Total: ", mana+gold, (cost.mana or cost.gold) and ((cost.mana or 0) + (cost.gold or 0)))
    end
  end
  make_resource_row(_"AP: ", EoHS.get_unit_action_points(actor), cost.action_points)
  
  -- TODO: display ghost_distance_to_target vs. range
  
  local actions_you_have_grid
  local target_grid
  if parameters.action_id then
    local standard_action_aspect_names = {
      ap=_"AP",mana=_"Mana",target=_"Target",range=_"Range",
    }
    local key_strings = {{"valid",""}}
    for i,id in ipairs(standard_action_aspects) do
      table.insert(key_strings, { "valid", standard_action_aspect_names[id] })
    end
    --TODO damage entry
    local key_label = {"label",{id = dialog_context.make_unique_id(), label="mmmmmmmmm"}}
    dialog_context.preshow(function()
      wesnoth.set_dialog_canvas(1, EoHS.action_list_entry_canvas(key_strings), key_label[2].id)
    end)
    
    local main_action_parameters = parameters
    local rows = {}
    
    local literal_variables = EoHS.get_subtag(actor, "variables")
    for scroll in helper.child_range(literal_variables, "EoHS_scroll") do
      local scroll_use_parameters = EoHS.deep_copy(scroll)
      scroll_use_parameters.actor_id = parameters.actor_id
      scroll_use_parameters.src_x = parameters.src_x
      scroll_use_parameters.src_y = parameters.src_y
      scroll_use_parameters.target_x = parameters.target_x
      scroll_use_parameters.target_y = parameters.target_y
      if scroll_use_parameters.scroll_id==parameters.scroll_id then main_action_parameters = scroll_use_parameters end
      local row = EoHS.action_dialog_stuff(dialog_context, scroll_use_parameters, ghost_distance_to_target, true, scroll_use_parameters.scroll_id==parameters.scroll_id, switch_func_func)
      table.insert(rows, row)
    end
    
    local rolling_parameters = EoHS.deep_copy(parameters)
    rolling_parameters.scroll_id = nil
    local actions = EoHS.unit_actions(actor)
    --TODO: "all actions / known actions / usable actions"
    for i,id in ipairs(actions) do
      rolling_parameters.action_id = id
      local row = EoHS.action_dialog_stuff(dialog_context, rolling_parameters, ghost_distance_to_target, true, (rolling_parameters.action_id==parameters.action_id) and not parameters.scroll_id, switch_func_func)
      table.insert(rows, row)
    end
    local list_grid
    if #rows > 7 then
      list_grid = g{r{c{ {"spacer",{height=190}} },c{vertical_grow=true, g{
        r{c{horizontal_grow=true, border="bottom", border_size=3, key_label}},
        r{ grow_factor=2, c{vertical_grow=true, {"scrollbar_panel",{ horizontal_scrollbar_mode="never", {"definition", rows } }} }}
      }} }}
    else
      list_grid = g{
        r{c{horizontal_grow=true, border="bottom", border_size=3, key_label}},
        r{ grow_factor=2, c{vertical_grow=true, g(rows) }}
      }
    end
  
    local action = EoHS.actions[main_action_parameters.action_id]
    local grid, current_action_validity, current_action_scroll_validity, target_type = EoHS.action_dialog_stuff(dialog_context, main_action_parameters, ghost_distance_to_target)
    local cast_str
    local thumbnail_size_str = "mmmmmmm"
    local button_size_str
    local use = _"Use"
    local target_unit = EoHS.get_seen_unit(main_action_parameters.target_x, main_action_parameters.target_y, actor.side)
    if action.is_spell then use = _"Cast" end
    if action.is_ritual then use = _"Start casting" end
    if target_type then
      local target_str
      if target_unit then
           cast_str = EoHS.substitute(_"$use| <b>$1|</b> at <b>$4|</b> ($2|,$3|)", {use=use, action.name, main_action_parameters.target_x, main_action_parameters.target_y, EoHS.unit_appellation(target_unit)})
      else cast_str = EoHS.substitute(_"$use| <b>$1|</b> at ($2|,$3|)",            {use=use, action.name, main_action_parameters.target_x, main_action_parameters.target_y}) end
      button_size_str = cast_str..thumbnail_size_str
    else
      cast_str = EoHS.substitute(_"$use| <b>$1|</b>", {use=use, action.name})
      button_size_str = cast_str
    end
    button_size_str = string.gsub(button_size_str, "%b<>", "")
    -- lolhack: account for the fact that the button-sizing is based on a different size of text than what I write in afterwards
    button_size_str = button_size_str..string.rep("m",math.ceil(string.len(button_size_str)/7))
    -- Hack: obs and off-turn can't *cast* spells, but display the rest of the dialog accurately.
    if (actor.side ~= wesnoth.current.side) or (wesnoth.sides[actor.side].controller ~= "human") then
      current_action_validity = "impossible"
    end
    local canvas = { {"text",{
      x = target_type and EoHS.macros.GUI__TEXT_HORIZONTALLY_CENTRED or "(width-text_width-12)",
      y = EoHS.macros.GUI__TEXT_VERTICALLY_CENTRED,
      w = "(text_width)",
      h = "(text_height)",
      font_size = 14,
      color = EoHS.validity_color(current_action_validity),
      text = cast_str,
      text_markup = true
    }} }
    if target_type then
      EoHS.add_hex_canvas(canvas, main_action_parameters.target_x, main_action_parameters.target_y, actor.side, {
        x = "(width-(10+image_width))",
        y = "((height/2)-(image_height/2))",
        w = "(if(height<58,height,58))",
        h = "(if(height<58,height,58))",
      })
    end
    button_size_str = "m\nm\n"..thumbnail_size_str..button_size_str.."\nm\nm"
    EoHS.add_hex_canvas(canvas, actor.x, actor.y, actor.side, {
      x = "10",
      y = "((height/2)-(image_height/2))",
      w = "(if(height<58,height,58))",
      h = "(if(height<58,height,58))",
    })
    local cast_button = {"button",{id="ok",label=button_size_str}}
    dialog_context.preshow(function()
      EoHS.set_canvas_over_button(canvas, "ok")
    end)
    if current_action_validity == "impossible" then
      dialog_context.preshow(function() wesnoth.set_dialog_active(false, "ok") end)
    end
    local actions_you_have_rows = {
      r{ c{ border="all", border_size=4, list_grid }, },
      r{ c{ cast_button, } },
    }
    if main_action_parameters.scroll_id or (action.is_spell and EoHS.get_unit_skill(actor, "scribe")) then
      local scribe_str
      local scribe_validity = "impossible"
      if target_unit and not (main_action_parameters.scroll_id and target_unit == actor)then
        scribe_validity = wesnoth.is_enemy(actor.side, target_unit.side) and "undesirable" or "valid"
      end
      if main_action_parameters.scroll_id then
        local info = _"1 AP"
        if main_action_parameters.given_recently then
          info = _"can't - it was already given this turn"
          scribe_validity = "impossible"
        end
        if target_unit and target_unit ~= actor then
          scribe_str = EoHS.substitute(_"Give this scroll to <b>$1|</b> ($2|)", {EoHS.unit_appellation(target_unit), info})
        else
          scribe_str = EoHS.substitute(_"Give this scroll ($1|)", {info})
        end
      else
        scribe_validity = EoHS.restrict_validity(scribe_validity, current_action_scroll_validity)
        if target_unit then
          --[[if target_unit == actor then
            scribe_str = EoHS.substitute(_"Create a scroll of <b>$1|</b> and keep it for yourself.", {action.name})
          else]]
            scribe_str = EoHS.substitute(_"Create a scroll of <b>$1|</b> for <b>$2|</b>", {action.name, EoHS.unit_appellation(target_unit)})
          --end
        else
          scribe_str = EoHS.substitute(_"Create a scroll of <b>$1|</b>", {action.name})
        end
      end
      if EoHS.distance_between(main_action_parameters.src_x, main_action_parameters.src_y, main_action_parameters.target_x, main_action_parameters.target_y) > 1 then
        scribe_validity = "impossible"
      end
      local scribe_size_str = string.gsub(scribe_str, "%b<>", "")
      -- lolhack: account for the fact that the button-sizing is based on a different size of text than what I write in afterwards
      scribe_size_str = scribe_size_str..string.rep("m",math.ceil(string.len(button_size_str)/14))
      scribe_size_str = "m\nmmmmm"..scribe_size_str
      table.insert(actions_you_have_rows, r{ c{ border="top", border_size=4, dialog_context.button({label=scribe_size_str, id="scribe_button"}, scribe_func) }})
      local scribe_canvas = { {"text",{
        x = EoHS.macros.GUI__TEXT_HORIZONTALLY_CENTRED,
        y = EoHS.macros.GUI__TEXT_VERTICALLY_CENTRED,
        w = "(text_width)",
        h = "(text_height)",
        font_size = 12,
        color = EoHS.validity_color(scribe_validity),
        text = scribe_str,
        text_markup = true
      }},
      {"image",{
        x = 10,
        w = "(height)",
        h = "(height)",
        name = "icons/scroll_red.png"
      }} }
      dialog_context.preshow(function()
        EoHS.set_canvas_over_button(scribe_canvas, "scribe_button")
      end)
      if scribe_validity == "impossible" then
        dialog_context.preshow(function() wesnoth.set_dialog_active(false, "scribe_button") end)
      end
    end
    table.insert(actions_you_have_rows, r{ c{ border="top", border_size=4, grid }, })
    actions_you_have_grid = g(actions_you_have_rows)
    
    local target_icon = function(name)
      return {"image",{
        x="((width-image_width)/2)",
        y="((height-image_height)/2)",
        w="(if(width<image_original_width,width,image_original_width))",
        h="(if(height<image_original_height,height,image_original_height))",
        name=name
      }}
    end
    local affected_hexes = action.affected_hexes and action.affected_hexes(main_action_parameters, "known") or {}
    local hex_image_mods_and_canvas_extras_map = {}
    for i,hex in ipairs(affected_hexes) do
      local idx = hex.x..","..hex.y
      if hex.visual == "harm" then
        local canvas = { target_icon("misc/new-battle.png~O(0.8)") }
        EoHS.add_canvas_hex_border_25x25(canvas, "255, 0, 0, 255", 2)
        hex_image_mods_and_canvas_extras_map[idx] = { "~CS(50,0,0)", canvas }
      end
      if hex.visual == "help" then
        local canvas = { target_icon("misc/capture.png~CROP(40,51,13,13)~O(0.8)") }
        EoHS.add_canvas_hex_border_25x25(canvas, "0, 255, 0, 255", 2)
        hex_image_mods_and_canvas_extras_map[idx] = { "~CS(0,50,0)", canvas }
      end
      if hex.visual == "change" then
        local canvas = { target_icon("misc/reloaded.png~O(0.8)") }
        EoHS.add_canvas_hex_border_25x25(canvas, "255, 255, 0, 255", 2)
        hex_image_mods_and_canvas_extras_map[idx] = { "~CS(40,40,0)", canvas }
      end
    end
    --[[local actor_idx = actor.x..","..actor.y
    if not hex_image_mods_and_canvas_extras_map[actor_idx] then
      local canvas = {}
      EoHS.add_canvas_hex_border_25x25(canvas, "0, 200, 255, 255", 2)
      hex_image_mods_and_canvas_extras_map[actor_idx] = { "~CS(0,40,50)", canvas }--{ "", { target_icon("misc/zoc.png~CROP(26,51,20,18)~O(0.8)") } }
    end]]
    target_grid = target_grid_func(function(x,y)
      local stuff = hex_image_mods_and_canvas_extras_map[x..","..y]
      if stuff then
        return unpack(stuff)
      end
    end)
  else
    actions_you_have_grid = g{r{c{ border="all", border_size=14, {"label",{label=_"You have no actions to use."}} }}}
    target_grid = target_grid_func(function(x,y) return end)
  end
  return g{
    r{c{horizontal_grow=true, g{r{c{ border="all", border_size=12, g(resource_rows) },c{horizontal_grow=true, grow_factor=2, vertical_alignment="top", subjects_grid}}}}},
    r{c{g{r{c{actions_you_have_grid},c{vertical_alignment="top", target_grid}}}}},
  }
end
  
EoHS.sides_who_can_see_action = function(parameters, affected_hexes)
  local sides_who_can_see_action = {}
  for side in ipairs(wesnoth.sides) do
    if not wesnoth.is_enemy(side, parameters.side) then sides_who_can_see_action[side] = true end
    if parameters.src_x and not sides_who_can_see_action[side] then
      if EoHS.hex_is_unfogged(parameters.src_x, parameters.src_y, side) then
        sides_who_can_see_action[side] = true
      end
    end
    if affected_hexes and not sides_who_can_see_action[side] then
      for i,hex in ipairs(affected_hexes) do
        if not hex.hidden_from_enemies then
          if EoHS.hex_is_unfogged(hex.x, hex.y, side) then
            sides_who_can_see_action[side] = true
            break
          end
        end
      end
    end
  end
  return sides_who_can_see_action
end

EoHS.for_those_who_see = function(parameters, sides_who_can_see_action, func)
  -- disunified: each client displays its own cast message
  local local_client_can_see = false
  local local_client_controls_any_side = false
  EoHS.disunified(function()
    for side in ipairs(wesnoth.sides) do
      if (wesnoth.sides[side].controller == "human") or (wesnoth.sides[side].controller == "human_ai") then
        local_client_controls_any_side = true
        if sides_who_can_see_action[side] then local_client_can_see = true end
      end
      if local_client_can_see then break end
    end
    if not local_client_controls_any_side then local_client_can_see = true end -- observers get to see everything
    if local_client_can_see then
      local seen_target_unit = EoHS.get_unit(parameters.target_x, parameters.target_y)
      if local_client_controls_any_side and seen_target_unit then
        seen_target_unit = nil
        for side in ipairs(wesnoth.sides) do
          if (wesnoth.sides[side].controller == "human") or (wesnoth.sides[side].controller == "human_ai") then
            seen_target_unit = EoHS.get_seen_unit(parameters.target_x, parameters.target_y, side)
          end
          if seen_target_unit then break end
        end
      end
      func(seen_target_unit)
    end
  end)
end

EoHS.unfog_for_those_who_see = function(sides_who_can_see_action, x, y)
  -- Make the caster visible for sides who can see
  if w111 then
    local sides_list = {}
    for side,can in ipairs(sides_who_can_see_action) do if can then table.insert(sides_list,side) end end
    wesnoth.fire("lift_fog", {
      x = x, y = y,
      { "filter_side", { side=table.concat(sides_list,",") } },
    })
  else
    -- In 1.10, we can't clear just a single hex.
    -- Instead, clear as little as possible: that hex plus every adjacent hex.
    -- Nixed because it caused unavoidable graphical glitches in *normal* situations (unit ellipse cycles color oddly),
    -- while the alternative is to cause glitches in *strange* situations (e.g. getting fireballed from fog)
    --[[
    local old_max_moves = actor.max_moves
    actor.max_moves = 0
    EoHS.put_unit(actor, {immediate=true})
    local wunit = wesnoth.get_unit(actor.x,actor.y)
    for side,can in ipairs(sides_who_can_see_action) do
      if can and (side ~= actor.side) then
        wunit.side = side
        wesnoth.fire("redraw",{clear_shroud=true,side=side})
      end
    end
    actor.max_moves = old_max_moves
    EoHS.put_unit(actor, {immediate=true})]]
  end
end

EoHS.do_action = function(parameters)
  local action = EoHS.actions[parameters.action_id]
  local actor = EoHS.get_unit(parameters.actor_id)
  local cost = EoHS.action_cost(parameters)
  local affected_hexes = action.affected_hexes and action.affected_hexes(parameters, "actual") or {}
  for i,hex in ipairs(affected_hexes) do
    if hex.require_no_invisible_enemy then
      local unit = EoHS.get_unit(hex.x,hex.y)
      if unit and wesnoth.is_enemy(unit.side, actor.side) then
        EoHS.do_only_on_client_controlling_side(actor.side, function()
          EoHS.message(EoHS.substitute(_"Your action ($3|) was disrupted by an invisible unit at ($1|,$2|). Try again.", {hex.x,hex.y,action.name}))
        end)
        return
      end
    end
  end
  EoHS.pay_action_cost(parameters, cost)
  if parameters.scroll_id then EoHS.remove_scroll(actor, parameters) end
  
  -- Wizards cannot be invisible while casting!
  EoHS.set_unit_status_immediate(actor, "uncovered", true)
  
  local sides_who_can_see_action = EoHS.sides_who_can_see_action(parameters, affected_hexes)
    
  -- disunified: each client displays its own cast message
  local local_client_can_see = false
  EoHS.for_those_who_see(parameters, sides_who_can_see_action, function(seen_target_unit)
    local_client_can_see = true
    local use_message, extra_values = action.use_message
    if type(use_message) == "function" then use_message, extra_values = use_message(parameters) end
    if not use_message then
      if action.target_type then
        if seen_target_unit then
              use_message = _"$actor_name| ($actor.x|,$actor.y|) $uses| $action.name| at $target_name| ($target.x|,$target.y|)."
        else use_message = _"$actor_name| ($actor.x|,$actor.y|) $uses| $action.name| at ($target_x|,$target_y|)." end
      else
        use_message = _"$actor_name| ($actor.x|,$actor.y|) $uses| $action.name|."
      end
    end
    EoHS.action_message(parameters, use_message, extra_values)
  end)
  
  EoHS.unfog_for_those_who_see(sides_who_can_see_action, actor.x, actor.y)
  
  local extras = {
    do_on_clients_who_see = function(func) EoHS.disunified(function() if local_client_can_see then func() end end) end,
    cost_paid = helper.get_child(parameters, "cost_paid") or cost,
  }
  
  EoHS.disunified(function() if local_client_can_see then EoHS.lock_view()   end end)
  EoHS.during_action = true
  EoHS.actions[parameters.action_id].happen(parameters, extras)
  EoHS.during_action = nil -- TODO decide whether actions can be nested
  EoHS.disunified(function() if local_client_can_see then EoHS.unlock_view() end end)
end

EoHS.update_scroll_overlays = function(unit)
  local variables = EoHS.force_unit_variables(unit)
  local literal_variables = EoHS.get_subtag(unit, "variables")
  if variables.scroll_overlays then
    unit.overlays = string.gsub(unit.overlays, EoHS.lua_pattern_escape(variables.scroll_overlays), "", 1)
  end
  local any
  local scroll_overlays = "misc/blank-hex.png~BLIT(icons/scroll_red.png~SCALE(12,12),46,2)"
  local offsy = 14
  for scroll in helper.child_range(literal_variables, "EoHS_scroll") do
    any = true
    local action = EoHS.actions[scroll.action_id]
    scroll_overlays = EoHS.image_aggregates_combined(scroll_overlays, {image_modded=action.image.."~SCALE(12,12)", offset={x=21,y=offsy-36}})
    offsy = 66-math.floor(((66-offsy)*5)/6)
  end
  variables.scroll_overlays = any and EoHS.collapse_image_aggregate("image_modded", scroll_overlays) or nil
  if any then unit.overlays = unit.overlays..","..variables.scroll_overlays end
end

EoHS.soon(function()
  EoHS.at_turn_refresh("num_scrolls", function(units)
    for i,unit in ipairs(units.with_variable.num_scrolls or {}) do
      local literal_variables = EoHS.get_subtag(unit, "variables")
      for scroll in helper.child_range(literal_variables, "EoHS_scroll") do
        scroll.given_recently = false
      end
      EoHS.put_unit(unit)
    end
  end)
end)

EoHS.add_scroll = function(unit, parameters)
  local variables = EoHS.force_unit_variables(unit)
  local literal_variables = EoHS.get_subtag(unit, "variables")
  table.insert(literal_variables, {"EoHS_scroll",parameters})
  variables.num_scrolls = (variables.num_scrolls or 0) + 1
  EoHS.update_scroll_overlays(unit)
end

EoHS.remove_scroll = function(unit, parameters)
  local variables = EoHS.force_unit_variables(unit)
  local literal_variables = EoHS.get_subtag(unit, "variables")
  local num_left = 0
  local removed = EoHS.remove_subtags(literal_variables, "EoHS_scroll", function(scroll)
    if scroll.scroll_id == parameters.scroll_id then return true else num_left = num_left + 1 end
  end)
  EoHS.assert(removed == 1, "EoHS.remove_scroll related bug...?")
  if num_left == 0 then variables.num_scrolls = nil else variables.num_scrolls = num_left end
  EoHS.update_scroll_overlays(unit)
end

EoHS.make_new_scroll_id = function()
  EoHS.assert(EoHS.context.unison, "EoHS.make_new_unit_id used in an disunified context")
  local id = EoHS.get_variable("next_scroll_id")
  EoHS.set_variable("next_scroll_id", id + 1)
  return id
end

EoHS.scribe_scroll = function(parameters)
  -- hack
  if parameters.scroll_id then return EoHS.give_scroll(parameters) end
  
  local actor = EoHS.get_unit(parameters.actor_id)
  local target = EoHS.get_unit(parameters.target_x, parameters.target_y)
  local cost = EoHS.action_cost(parameters)
  EoHS.pay_action_cost(parameters, cost)
  
  -- Wizards cannot be invisible while casting!
  EoHS.set_unit_status_immediate(actor, "uncovered", true)
  
  local sides_who_can_see_action = EoHS.sides_who_can_see_action(parameters, {x=parameters.target_x,y=parameters.target_y})
  
  EoHS.for_those_who_see(parameters, sides_who_can_see_action, function(seen_target_unit)
    if seen_target_unit then
      EoHS.action_message(parameters, _"$actor_name| ($actor.x|,$actor.y|) creates a scroll of $action.name| for $target_name| ($target.x|,$target.y|).")
    else
      EoHS.action_message(parameters, _"$actor_name| ($actor.x|,$actor.y|) creates a scroll of $action.name| for a unit you can't see ($target.x|,$target.y|).")
    end
  end)
  
  EoHS.unfog_for_those_who_see(sides_who_can_see_action, actor.x, actor.y)
  
  parameters.scroll_id = EoHS.make_new_scroll_id()
  parameters.scroll_AP_cost = cost.action_points
  table.insert(parameters, {"cost_paid", cost})
  parameters.given_recently = (actor ~= target)
  EoHS.add_scroll(target, parameters)
  EoHS.put_unit(target)
end

EoHS.give_scroll = function(parameters)
  local actor = EoHS.get_unit(parameters.actor_id)
  local target = EoHS.get_unit(parameters.target_x, parameters.target_y)
  
  EoHS.pay_action_cost(parameters, {action_points=1})
  parameters.given_recently = true
  EoHS.remove_scroll(actor, parameters)
  EoHS.add_scroll(target, parameters)
  EoHS.put_unit(actor)
  EoHS.put_unit(target)
end

EoHS.pay_action_cost = function(parameters, cost)
  if cost.gold then
    local actor = EoHS.get_unit(parameters.actor_id)
    wesnoth.sides[actor.side].gold = wesnoth.sides[actor.side].gold - cost.gold
  end
  if cost.mana then
    local mana_paid, gold_paid = EoHS.deduct_mana_andor_gold(parameters.actor_id, cost.mana)
    cost.mana = mana_paid
    cost.gold = (cost.gold or 0) + gold_paid
  end
  if cost.action_points then
    local actor = EoHS.get_unit(parameters.actor_id)
    EoHS.set_unit_action_points_immediate(actor, EoHS.get_unit_action_points(actor) - cost.action_points)
    -- and if it uses action points then it's tiring
    EoHS.set_unit_attribute_immediate(actor, "resting", false)
  end
end

EoHS.attack_AP_cost = function(unit)
  if unit.max_attacks == 0 then return 1000 end
  if unit.max_attacks == 1 then return 6 end
  if unit.max_attacks == 2 then return 4 end
  return 3
  --return EoHS.get_unit_variable(unit, "is_lich") and 4 or 6
end

EoHS.unit_base_action_points = function(unit)
  if EoHS.is_building(unit) then return 0 end
  local attack = EoHS.attack_AP_cost(unit)
  local min = attack * unit.max_attacks
  local max = attack * unit.max_attacks + (attack-1)
  if max < 11 then return max end
  if min > 11 then return min end
  return 11
end

EoHS.get_unit_action_points = function(unit)
  return (EoHS.attack_AP_cost(unit)*unit.attacks_left) + (EoHS.get_unit_variable(unit, "extra_action_points") or 5)
end

EoHS.set_unit_action_points_immediate = function(unit, amount)
  local attack_AP_cost = EoHS.attack_AP_cost(unit)
  EoHS.set_unit_attribute_immediate(unit, "attacks_left", math.floor(amount / attack_AP_cost))
  EoHS.set_unit_variable_immediate(unit, "extra_action_points", amount % attack_AP_cost)
  EoHS.update_orb(unit)
end

EoHS.deduct_mana_andor_gold = function(unit_id, amount)
  local unit = EoHS.get_unit(unit_id)
  local mana = EoHS.get_unit_variable(unit, "mana")
  if mana <= 0 then
    wesnoth.sides[unit.side].gold = wesnoth.sides[unit.side].gold - amount
    return 0, amount
  elseif mana < amount then
    EoHS.set_unit_variable_immediate(unit, "mana", 0)
    wesnoth.sides[unit.side].gold = wesnoth.sides[unit.side].gold + mana - amount
    return mana, amount - mana
  else
    EoHS.set_unit_variable_immediate(unit, "mana", mana - amount)
    return amount, 0
  end
end

EoHS.unit_mana_income = function(unit)
  if EoHS.get_unit_variable(unit, "is_wizard") then
    return EoHS.get_wizard_setting(unit, "mana_income_at_level_0") + 
           EoHS.get_wizard_setting(unit, "mana_income_per_level")*unit.level +
           (EoHS.get_unit_variable(unit, "soul_bind_mana_income") or 0)
  end
  if EoHS.get_unit_variable(unit, "is_summon") then
    if unit.type == "Fire Dragon" then return 2*unit.level end
  end
end
EoHS.unit_mana_cap = function(unit)
  if EoHS.get_unit_variable(unit, "is_wizard") then
    local setting = EoHS.get_wizard_setting(unit, "mana_capacity_per_level")
    if setting == "infinite" then return nil end
    return setting*unit.level
  end
end
EoHS.earn_mana = function(unit, amount)
  local mcap = EoHS.unit_mana_cap(unit)
  local old_mana = EoHS.get_unit_variable(unit, "mana") or 0
  if (not mcap) or (old_mana < mcap) then
    local new_mana = old_mana + amount
    if mcap and (new_mana > mcap) then
      new_mana = mcap
    end
    EoHS.set_unit_variable_immediate(unit, "mana", new_mana)
  end
end
EoHS.earn_mana_income = function(unit)
  if wesnoth.current.turn > 1 then -- parallel to built-in rule about gold income
    local mincome = EoHS.unit_mana_income(unit)
    if mincome and (mincome > 0) then
      EoHS.earn_mana(unit, mincome)
    end
  end
end

EoHS.action_cost = function(parameters)
  if parameters.scroll_id then return { action_points = parameters.scroll_AP_cost } end
  local action = EoHS.actions[parameters.action_id]
  local cost
  if type(action.base_cost) == "function" then
    cost = action.base_cost(parameters)
  else
    cost = EoHS.deep_copy(action.base_cost)
  end
  cost = cost or {}
  
  local actor = EoHS.get_unit(parameters.actor_id)
  if actor and action.is_summon then
    if cost.action_points and EoHS.get_unit_skill(actor, "summoner") and not action.is_ritual then
      cost.action_points = cost.action_points - 2
    end
    local multiplier = EoHS.get_wizard_setting(actor, "summon_cost_multiplier")
    if cost.mana and multiplier then
      cost.mana = math.ceil(cost.mana * multiplier / 100)
    end
  end
  if cost.mana and action.is_spell and EoHS.get_unit_skill(actor, "efficiency") then
    cost.mana = math.floor((cost.mana*8+5)/10)
  end
  if cost.action_points and EoHS.get_unit_skill(actor, "enchanter") and action.is_enchantment and not action.is_ritual then
    cost.action_points = cost.action_points - 2
  end
  return cost
end

EoHS.apply_farseer = function(number, parameters)
  return parameters.farseer and (number*2) or number
end

EoHS.action_range = function(parameters)
  local action = EoHS.actions[parameters.action_id]
  local actor = EoHS.get_unit(parameters.actor_id)
  local range
  if type(action.base_range) == "function" then
    range = action.base_range(parameters)
  else
    range = action.base_range
  end
  if not range then return nil end
  
  if action.is_spell then
    range = EoHS.apply_farseer(range, parameters)
  end
  return range
end

EoHS.target_types = {
  hex = function(parameters) return {
    short_name = _"hex",
    name = _"Any hex",
    details = "",
    -- Not a side-specific check - we'll deal with that elsewhere, not in the target type
    validity = EoHS.location_is_passable(parameters.target_x, parameters.target_y) and "valid" or "impossible"
  } end,
  direction = function(parameters) return {
    short_name = _"direction",
    name = _"Direction",
    details = "",
    validity = "valid"
  } end,
  empty_hex = function(parameters)
    local actor = EoHS.get_unit(parameters.actor_id)
    local unit = EoHS.get_seen_unit(parameters.target_x,parameters.target_y,actor.side)
    local unfogged = EoHS.hex_is_unfogged(parameters.target_x,parameters.target_y)
    return {
      short_name = _"empty hex",
      name = _"Empty hex",
      details = ((not unfogged) and _"You can't tell if that hex is occupied." or ""),
      validity = (unfogged and not unit) and "valid" or "impossible"
    }
  end,
  recruit = function(parameters)
    local actor = EoHS.get_unit(parameters.actor_id)
    local keep = wesnoth.get_terrain_info(wesnoth.get_terrain(actor.x, actor.y)).keep
    local unit = EoHS.get_seen_unit(parameters.target_x,parameters.target_y,actor.side)
    local path = EoHS.find_path(actor.x,actor.y,parameters.target_x,parameters.target_y,function(x,y) return wesnoth.get_terrain_info(wesnoth.get_terrain(x, y)).castle and 1 or nil end)
    local unfogged = EoHS.hex_is_unfogged(parameters.target_x,parameters.target_y)
    -- Intentionally allowing impassable
    return {
      short_name = _"recruit hex",
      name = _"Recruit hex",
      details = ((not unfogged) and _"You can't tell if that hex is occupied." or ""),
      validity = (keep and path[1] and unfogged and not unit) and "valid" or "impossible"
    }
  end,
  unit = function(parameters)
    local actor = EoHS.get_unit(parameters.actor_id)
    local unit = EoHS.get_seen_unit(parameters.target_x,parameters.target_y,actor.side)
    local unfogged = EoHS.hex_is_unfogged(parameters.target_x,parameters.target_y)
    return {
      short_name = _"unit",
      name = _"Any unit",
      details = ((not unfogged) and _"You can't tell if there is a unit there." or ""),
      validity = (unit and unfogged) and "valid" or "impossible"
    }
  end,
  unit_probably_enemy = function(parameters)
    local actor = EoHS.get_unit(parameters.actor_id)
    local unit = EoHS.get_seen_unit(parameters.target_x,parameters.target_y,actor.side)
    local unfogged = EoHS.hex_is_unfogged(parameters.target_x,parameters.target_y)
    local is_enemy = unit and wesnoth.is_enemy(unit.side, actor.side)
    return {
      short_name = _"unit",
      name = _"Unit (probably enemy)",
      details = ((not unfogged) and _"You can't tell if there is a unit there." or ((unit and not is_enemy) and _"You probably don't want to cast that at an ally." or "")),
      validity = ((unit and unfogged)
        and (is_enemy and "valid" or "undesirable")
        or "impossible")
    }
  end,
  unit_probably_ally = function(parameters)
    local actor = EoHS.get_unit(parameters.actor_id)
    local unit = EoHS.get_seen_unit(parameters.target_x,parameters.target_y,actor.side)
    local unfogged = EoHS.hex_is_unfogged(parameters.target_x,parameters.target_y)
    local is_enemy = unit and wesnoth.is_enemy(unit.side, actor.side)
    return {
      short_name = _"unit",
      name = _"Unit (probably ally)",
      details = ((not unfogged) and _"You can't tell if there is a unit there." or ((unit and is_enemy) and _"You probably don't want to cast that at an enemy." or "")),
      validity = ((unit and unfogged)
        and (is_enemy and "undesirable" or "valid")
        or "impossible")
    }
  end,
}

EoHS.action_message = function(parameters, string, extra_values)
  local values = EoHS.deep_copy(parameters)
  if extra_values then for k,v in pairs(extra_values) do values[k] = v end end
  local action = EoHS.actions[parameters.action_id]
  values.action = {}
  for k,v in pairs(action) do
    if (type(k) == "string") and (type(v) ~= "function") and (type(v) ~= "table") then values.action[k] = v end
  end
  if parameters.actor_id then
    values.actor = EoHS.get_unit(parameters.actor_id)
    if values.actor then values.actor_name = EoHS.unit_appellation(values.actor) end
  end
  if parameters.target_x then
    values.target = EoHS.get_unit(parameters.target_x, parameters.target_y)
    if values.target then values.target_name = EoHS.unit_appellation(values.target) end
  end
  values.uses = _"uses"
  if action.is_spell then values.uses = _"casts" end
  if action.is_ritual then values.uses = _"starts casting" end
  EoHS.message(EoHS.substitute(string, values))
end

EoHS.begin_casting = function(actor_id, target_x, target_y)
  local actor = EoHS.get_unit(actor_id)
  if actor then
    wesnoth.scroll_to_tile(actor.x, actor.y, true)

    if target_x then
      EoHS.face_towards(actor, target_x, target_y)
    end

    EoHS.set_unit_attribute_immediate(actor, "facing", actor.facing)
    wesnoth.fire("redraw")
    EoHS.set_unit_variable_immediate(actor, "is_casting_a_spell", true)
    EoHS.animate_unit({
      flag = "EoHS_start_casting",
      with_bars = true,
      { "filter", { x=actor.x, y=actor.y, }},
    }, {dont_redraw_first=true})
  end
  if target_x then
    wesnoth.scroll_to_tile(target_x, target_y, true)
  end
end

EoHS.finish_casting = function(actor_id)
  local actor = EoHS.get_unit(actor_id)
  -- In rare cases, the spell might have killed the caster, so only proceed if they can be found:
  if actor then
    wesnoth.fire("redraw")
    EoHS.set_unit_variable_immediate(actor, "is_casting_a_spell")
    EoHS.animate_unit({
      flag = "EoHS_stop_casting",
      with_bars = true,
      { "filter", { x=actor.x, y=actor.y, }},
    }, {dont_redraw_first=true})
  end
end

EoHS.actions = {}
EoHS.make_action = function(id, action)
  if (type(action.image) ~= "string") or not (string.match(action.image, "attacks/") or string.match(action.image, "icons/")) then
    action.image = EoHS.collapse_image_aggregate("image_modded", EoHS.image_aggregates_combined(
      "attacks/blank-attack.png",
      EoHS.image_aggregate_cropped(action.image, {size={x=50,y=50},offset={x=0,y=0}})
    ))
  end
  action.id = id
  EoHS.actions[id] = action
end

EoHS.make_spell = function(id, action)
  action.is_spell = true
  EoHS.make_action(id, action)
end

EoHS.make_touch_enchantment = function(id, action)
  action.is_enchantment = true
  if not action.affected_hexes then action.affected_hexes = function(parameters)
    local actor = EoHS.get_unit(parameters.actor_id)
    return {{x=actor.x,y=actor.y,visual="help"}}
  end end
  if not action.make_extra_attributes then action.make_extra_attributes = function(parameters, make_aspect)
    local actor = EoHS.get_unit(parameters.actor_id)
    local touch_enchantment = EoHS.get_unit_variable(actor, "touch_enchantment")
    local details = ""
    local validity = "valid"
    if touch_enchantment == id then
      validity = "impossible"
      details = _"You already have that spell active."
    elseif touch_enchantment then
      validity = "undesirable"
      details = _"Replaces your current touch enchantment"
    end
      
    make_aspect.type_and_details(_"Touch enchantment", details, validity)
  end end
  if not action.happen then action.happen = function(parameters, extras)
    EoHS.begin_casting(parameters.actor_id)
    local actor = EoHS.get_unit(parameters.actor_id)
    EoHS.set_unit_variable(actor, "touch_enchantment", id)
    EoHS.update_all_type_adjustments(actor)
    if action.sound then extras.do_on_clients_who_see(function() wesnoth.fire("sound", { name = action.sound }) end) end
    EoHS.put_unit(actor, {immediate=true})
    EoHS.finish_casting(parameters.actor_id)
  end end
  
  EoHS.make_spell(id, action)
end

local ritual_desc = _"This spell takes $1| turns (counting the turn you start it), and takes effect at the beginning of its last turn. Once you start casting this spell, you cannot move, attack, or cast other spells, or earn mana until after its last turn (or the turn when you cancel it)."
EoHS.make_ritual = function(id, action)
  local ritual_turns = function(parameters)
    local result = action.turns
    local actor = EoHS.get_unit(parameters.actor_id)
    if action.is_summon and EoHS.get_unit_skill(actor, "summoner") then
      result = result - 1
    end
    if action.is_enchantment and EoHS.get_unit_skill(actor, "enchanter") then
      result = result - 1
    end
    return result
  end
  
  action.is_ritual = true
  
  if type(action.base_cost) == "table" then action.base_cost.action_points = 11
  elseif type(action.base_cost) == "function" then 
    local old_func = action.base_cost
    action.base_cost = function(parameters)
      local result = old_func(parameters)
      result.action_points = 11
      return result
    end
  else
    action.base_cost = { action_points = 11 }
  end
    
  local old_make_extra_attributes = action.make_extra_attributes
  action.make_extra_attributes = function(parameters, make_aspect)
    local turns = ritual_turns(parameters)
    make_aspect.type_value_and_details(_"Ritual:", EoHS.substitute(_"$1| turns", {turns}), EoHS.substitute(ritual_desc, {turns}))
    if old_make_extra_attributes then old_make_extra_attributes(parameters, make_aspect) end
  end
  action.happen = function(parameters)
    local actor = EoHS.get_unit(parameters.actor_id)
    EoHS.begin_casting(parameters.actor_id, parameters.target_x, parameters.target_y)
    EoHS.set_unit_variable(actor, "ritual", id)
    EoHS.set_unit_variable(actor, "ritual_runes", ritual_turns(parameters))
    EoHS.set_unit_variable(actor, "ritual_runes_lit", 1)
    local ritual_parameters = EoHS.get_fake_subtag(EoHS.force_unit_variables(actor), "ritual_parameters")
    for k,v in pairs(parameters) do ritual_parameters[k] = v end -- TODO can we rely on this making a valid WML table?
    actor.moves = 0
    EoHS.set_unit_action_points_immediate(actor, 0)
    EoHS.update_all_type_adjustments(actor)
    EoHS.put_unit(actor)
  end
  
  EoHS.make_spell(id, action)
end

EoHS.soon(function()
  EoHS.make_action("cancel_ritual", {
    image = "scenery/tent-ruin-1.png",
    name = _"Cancel Ritual",
    description = _"You abandon your current ritual. You don't recover any of the cost, and you still can't move this turn, but you'll be able to move next turn.",
    
    affected_hexes = function(parameters)
      local actor = EoHS.get_unit(parameters.actor_id)
      return {{x=actor.x,y=actor.y,visual="change"}}
    end,
    
    use_message = function(parameters)
      local actor = EoHS.get_unit(parameters.actor_id)
      return _"$actor_name| ($actor.x|,$actor.y|) stops casting $ritual|.", {ritual=EoHS.actions[EoHS.get_unit_variable(actor, "ritual")].name}
    end,
    
    happen = function(parameters)
      local actor = EoHS.get_unit(parameters.actor_id)
      EoHS.set_unit_variable(actor, "ritual")
      EoHS.update_all_type_adjustments(actor)
      EoHS.put_unit(actor)
      EoHS.finish_casting(parameters.actor_id)
    end,
  })
end)

EoHS.skill_attack_func = function(realm, func)
  return function(actor)
    for attack in helper.child_range(actor, "attack") do
      if attack.name == "EoHS_"..realm.."_skill_ranged_attack" then
        local result = EoHS.deep_copy(attack)
        EoHS.remove_subtags(result, "specials.*", "EoHS_lightning_paralysis")
        EoHS.remove_subtags(result, "specials.*", "EoHS_just_teleported_1")
        EoHS.remove_subtags(result, "specials.*", "EoHS_just_teleported_2")
        func(result)
        return result
      end
    end
  end
end

EoHS.copy_skill_attack = function(actor, realm)
  for attack in helper.child_range(actor, "attack") do
    if attack.name == "EoHS_"..realm.."_skill_ranged_attack" then
      return EoHS.deep_copy(attack)
    end
  end
end

EoHS.make_attack_attribute = function(make_aspect, list_entry_only, attacker, defender_x, defender_y, get_attack_func, viewing_side)
  if not viewing_side then viewing_side = attacker.side end
  local defender = EoHS.get_seen_unit(defender_x, defender_y, viewing_side)
  if defender then
    local value,details,validity="","","valid"
    local name = EoHS.unit_appellation(defender)
    if EoHS.unit_is_immune_to_direct_spell_damage(defender) then
      value = _"None"
      details = EoHS.unit_is_immune_to_direct_spell_damage_description(defender)
    else
      if not wesnoth.is_enemy(defender.side, viewing_side) then validity = "undesirable" end
      if not list_entry_only then
        local attack = get_attack_func(attacker)
        local attack_context = EoHS.game_action_simulations.fleshed_out_attack_context({
          attacker={x=attacker.x,y=attacker.y,attack=attack},
          defender={x=defender.x,y=defender.y}})
        if attack_context then
          value = attack_context.attacker.damage.."-"..attack_context.attacker.attacks
        else
          EoHS.err("attack context failed in EoHS.make_attack_attribute")
          value = _"None"
          details = _"It doesn't work for some reason..."
        end
      end
    end
    make_aspect.type_value_and_details(EoHS.substitute(_"Damage to $1|", {name}), value, details, validity)
  end
end
EoHS.spell_attack_info = function(attacker, defender_x, defender_y, get_attack_func)
  if EoHS.get_unit(defender_x,defender_y) then
    local attacker_id = EoHS.unit_id(attacker)
    return {context={
      attacker={x=attacker.x,y=attacker.y},
      defender={x=defender_x,y=defender_y}
    }, extras={is_spell = true, spend_moves_and_attacks = false, update_context_func = function(attack_context)
      local attacker = EoHS.get_unit(attacker_id)
      attack_context.attacker.attack = attacker and get_attack_func(attacker)
    end}}
  end
end
EoHS.ensure_attack_allowed = function(make_aspect, attacker, get_attack_func)
  if not get_attack_func(attacker) then
    make_aspect.type_and_details(_"Can't cast:", _"You don't have the relevant attack right now.", "impossible")
    return false
  end
  return true
end

-->>)}
