{EOHS_LUA_FILE (<<-- actions.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

EoHS.unit_has_actions = function(unit)
  return EoHS.get_unit_variable(unit, "is_wizard")
end

EoHS.unit_has_action = function(unit, id)
  local actions = EoHS.unit_actions(unit)
  for i,id2 in ipairs(actions) do
    if id2 == id then return true end
  end
  return false
end

EoHS.unit_actions = function(unit)
  local result = {}
  if EoHS.get_unit_variable(unit, "is_wizard") then
    table.insert(result, "summon_wolf")
  end
  return result
end

local standard_action_aspects = {
  "ap","mana","range","target",
}
local g = function(contents) return { "grid", contents } end
local r = function(contents) return { "row", contents } end
local c = function(contents) return { "column", contents } end
local spacer = { "spacer", {}}

EoHS.action_list_entry_canvas = function(strings, image)
  local result = {}
  
  local texts = {
    { w = 200, },
    { w = 25, },
    { w = 45, },
    { w = 50, },
    { w = 90, },
  }
  for i,string in ipairs(strings) do
    local text = texts[i]
    text.y = EoHS.macros.GUI__TEXT_VERTICALLY_CENTRED
    if texts[i-1] then
      text.x = texts[i-1].x + texts[i-1].w + 3
    else
      text.x = 6
    end
    text.h = "(text_height)"
    text.font_size = 14
    text.color = EoHS.validity_color(string[1])
    text.text = string[2]
  end
  for i,text in ipairs(texts) do
    text.x = "("..(text.x+text.w).."-text_width)"
    table.insert(result, {"text",text})
  end
  if image then
    table.insert(result, {"image",{
      x=0,y=0,w="(height)",h="(height)",
      name=image,
    }})
  end
  
  return result
end
local action_list_entry_size_str = "mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm\nm"


EoHS.action_dialog_stuff = function(dialog_context, parameters, list_entry_only, selected, switch_func_func)
  local action = EoHS.actions[parameters.action_id]
  
  local cost = EoHS.action_cost(parameters)
  local range = EoHS.action_range(parameters)
  local whole_action_validity = "valid"
  local actor
  if parameters.actor_id then
    actor = EoHS.get_unit(parameters.actor_id)
  end
  
  local standard_aspects = {}
  local extra_aspects = {}
  local make_aspect = function(type_label, value_label, details_label, validity, index)
    if validity == "impossible" then whole_action_validity = "impossible" end
    if validity == "undesirable" and whole_action_validity == "valid" then whole_action_validity = "undesirable" end
    if list_entry_only then
      if index then standard_aspects[index] = { validity, value_label } end
    else
      local    type_widget = EoHS.label_with_validity(dialog_context, validity, {label=    type_label}, "right")
      local   value_widget = EoHS.label_with_validity(dialog_context, validity, {label=   value_label}, "left")
      local details_widget = EoHS.label_with_validity(dialog_context, validity, {label= details_label}, "left")
      local row = r{
        c{horizontal_grow=true, border="right", border_size=9, type_widget},
        c{horizontal_grow=true, border="right", border_size=9, value_widget},
        c{horizontal_grow=true, border="right", border_size=9, details_widget},
      }
      if index then standard_aspects[index] = row
      else table.insert(extra_aspects, row) end
    end
  end
  if cost.action_points then
    make_aspect(_"AP:", ""..cost.action_points, "", (EoHS.unit_action_points(actor) >= cost.action_points) and "valid" or "impossible", "ap")
  end
  if cost.mana then
    local mana = math.max(0, EoHS.get_unit_variable(actor, "mana"))
    local validity = "valid"
    local label
    local details = ""
    if mana >= cost.mana then
      label = ""..cost.mana
    elseif EoHS.get_wizard_setting(actor, "can_spend_gold_on_spells") and (mana+wesnoth.sides[actor.side].gold >= cost.mana) then
      details = EoHS.substitute(_"You will transmute $1| gold into mana", {cost.mana-mana})
    else
      validity = "impossible"
    end
    make_aspect(_"Mana cost:", ""..cost.mana, details, validity, "mana")
  end
  if action.target_type then
    local target_type = action.target_type(parameters, list_entry_only)
    make_aspect(_"Target type:", target_type.name, target_type.details, target_type.validity, "target")
    
    if range then
      local dist = EoHS.distance_between(
             actor.       x,      actor.       y,
        parameters.target_x, parameters.target_y,
        EoHS.known_passable_only(), range)
      make_aspect(_"Range:", ""..range, "", (dist and (dist <= range)) and "valid" or "impossible", "range")
    end
  end
  if action.extra_restrictions then
    action.extra_restrictions(make_aspect, parameters)
  end
  
  if list_entry_only then
    local strings = {
      { whole_action_validity, action.name },
    }
    for i,id in ipairs(standard_action_aspects) do
      table.insert(strings, standard_aspects[id] or "")
    end
    --TODO damage entry
    
    return r{c{EoHS.fake_listbox_entry(dialog_context, action_list_entry_size_str, EoHS.action_list_entry_canvas(strings, action.image), selected, switch_func_func(parameters.action_id))}}, whole_action_validity
  else
    local aspect_rows = {}
    for i,id in ipairs(standard_action_aspects) do
      if standard_aspects[id] then
        table.insert(aspect_rows, standard_aspects[id])
      end
    end
    for i,aspect in ipairs(extra_aspects) do
      table.insert(aspect_rows, aspect)
    end
    
    local rows = {
      r{c{ horizontal_grow=true, border="all",border_size=9, 
        g{r{
          c{ vertical_alignment="top",border="right",border_size=4, {"image",{label=action.image}} },
          c{ horizontal_grow=true,grow_factor=2, g{
            r{c{horizontal_alignment="left",{"label",{label=action.name,definition="title"}} }},
            r{c{horizontal_alignment="left",border="all",border_size=9, {"label",{wrap=true,label=action.description(parameters)}} }}
          }}
        }}
      }},
      r{c{g(aspect_rows)}},
    }
    
    if action.parameters_dialog_grid then
      table.insert(rows, r{c{action.parameters_dialog_grid(dialog_context, parameters)}})
    end
    return g(rows), whole_action_validity
  end
end

EoHS.actions_grid = function(dialog_context, parameters, switch_func_func)
  local standard_action_aspect_names = {
    ap=_"AP",mana=_"Mana",target=_"Target",range=_"Range",
  }
  local key_strings = {{"valid",""}}
  for i,id in ipairs(standard_action_aspects) do
    table.insert(key_strings, { "valid", standard_action_aspect_names[id] })
  end
  --TODO damage entry
  local key_label = {"label",{id = dialog_context.make_unique_id(), label=action_list_entry_size_str}}
  dialog_context.preshow(function()
    wesnoth.set_dialog_canvas(1, EoHS.action_list_entry_canvas(key_strings), key_label[2].id)
  end)
  
  local rows = {r{c{key_label}}}
  local rolling_parameters = EoHS.deep_copy(parameters)
  local actor = EoHS.get_unit(parameters.actor_id)
  local actions = EoHS.unit_actions(actor)
  --TODO: "all actions / known actions / usable actions"
  for i,id in ipairs(actions) do
    rolling_parameters.action_id = id
    local row, validity = EoHS.action_dialog_stuff(dialog_context, rolling_parameters, true, rolling_parameters.action_id==parameters.action_id, switch_func_func)
    table.insert(rows, row)
  end
  
  local action = EoHS.actions[parameters.action_id]
  grid, current_action_validity = EoHS.action_dialog_stuff(dialog_context,parameters)
  local cast_button = {"button",{id="ok",label=EoHS.substitute(_" \nCast $1|\n ", {action.name})}}
  local cast_widget = cast_button
  if action.target_type then
    local target_unit = EoHS.get_unit(parameters.target_x, parameters.target_y)
    local target_str
    if target_unit then target_str = EoHS.substitute(_" at $3| ($1|,$2|) ", {parameters.target_x, parameters.target_y, ((target_unit.name == "") and target_unit.language_name or target_unit.name)})
    else target_str = EoHS.substitute(_" at ($1|,$2|) ", {parameters.target_x, parameters.target_y}) end
    cast_widget = g{r{
      c{cast_button},
      c{ {"label",{label=target_str}} },
      c{ {"image",{label="misc/blank-hex.png~SCALE(58,58)",id="action_target_view"}} },
    }}
    dialog_context.preshow(function()
      wesnoth.set_dialog_canvas(1, EoHS.hex_canvas(parameters.target_x, parameters.target_y, actor.side), "action_target_view")
    end)
  end
  if current_action_validity == "impossible" then dialog_context.preshow(function() wesnoth.set_dialog_active(false, "ok") end) end
  return g{
    r{ c{ border="all", border_size=14, {"scrollbar_panel",{ {"definition", rows } }} }, },
    r{ c{ border="all", border_size=14, grid }, },
    r{ c{ border="top", border_size=14, cast_widget, } },
  }
end

EoHS.do_action = function(parameters)
  local action = EoHS.actions[parameters.action_id]
  local cost = EoHS.action_cost(parameters)
  EoHS.pay_action_cost(parameters, cost)
  EoHS.actions[parameters.action_id].happen(parameters, cost)
end

EoHS.pay_action_cost = function(parameters, cost)
  if cost.mana then
    EoHS.deduct_mana_andor_gold(parameters.actor_id, cost.mana)
  end
  if cost.action_points then
    local actor = EoHS.get_unit(parameters.actor_id)
    EoHS.modify_action_points(actor, -cost.action_points)
    -- and if it uses action points then it's tiring
    actor.resting = false
    EoHS.put_unit(actor)
  end
end

EoHS.unit_action_points = function(unit)
  return (6*unit.attacks_left) + EoHS.get_unit_variable(unit, "extra_action_points")
end

EoHS.modify_action_points = function(unit, amount)
  local extra_action_points = EoHS.get_unit_variable(unit, "extra_action_points")
  extra_action_points = extra_action_points + amount
  while extra_action_points < 0 do
    unit.attacks_left = unit.attacks_left - 1
    extra_action_points = extra_action_points + 6
  end
  while extra_action_points >= 6 do
    unit.attacks_left = unit.attacks_left + 1
    extra_action_points = extra_action_points - 6
  end
  EoHS.set_unit_variable(unit, "extra_action_points", extra_action_points)
end

EoHS.deduct_mana_andor_gold = function(unit_id, amount)
  local unit = EoHS.get_unit(unit_id)
  local mana = EoHS.get_unit_variable(unit, "mana")
  if mana <= 0 then
    wesnoth.sides[unit.side].gold = wesnoth.sides[unit.side].gold - amount
  elseif mana < amount then
    EoHS.set_unit_variable(unit, "mana", 0)
    wesnoth.sides[unit.side].gold = wesnoth.sides[unit.side].gold + mana - amount
  else
    EoHS.set_unit_variable(unit, "mana", mana - amount)
  end
  EoHS.put_unit(unit)
end

EoHS.unit_mana_income = function(unit)
  if EoHS.get_unit_variable(unit, "is_wizard") then
    return EoHS.get_wizard_setting(unit, "mana_income_per_level")*unit.level
  end
end
EoHS.unit_mana_cap = function(unit)
  if EoHS.get_unit_variable(unit, "is_wizard") then
    local setting = EoHS.get_wizard_setting(unit, "mana_capacity_per_level")
    if setting == "infinite" then return nil end
    return setting*unit.level
  end
end
EoHS.earn_mana_income = function(unit)
  if wesnoth.current.turn > 1 then -- parallel to built-in rule about gold income
    local mincome = EoHS.unit_mana_income(unit)
    if mincome and (mincome > 0) then
      local mcap = EoHS.unit_mana_cap(unit)
      local old_mana = EoHS.get_unit_variable(unit, "mana")
      if (not mcap) or (old_mana < mcap) then
        local new_mana = old_mana + mincome
        if mcap and (new_mana > mcap) then
          new_mana = mcap
        end
        EoHS.set_unit_variable(unit, "mana", new_mana)
        return true
      end
    end
  end
  return false
end

EoHS.action_cost = function(parameters)
  local action = EoHS.actions[parameters.action_id]
  local cost
  if type(action.base_cost) == "function" then
    cost = action.base_cost(parameters)
  else
    cost = EoHS.deep_copy(action.base_cost)
  end
  
  local actor = EoHS.get_unit(parameters.actor_id)
  if actor and action.is_summon then
    if cost.action_points and EoHS.get_unit_skill(actor, "summoner") then
      cost.action_points = math.ceil(cost.action_points * 0.6)
    end
    local multiplier = EoHS.get_wizard_setting(actor, "summon_cost_multiplier")
    if cost.mana and multiplier then
      cost.mana = math.ceil(cost.mana * multiplier / 100)
    end
  end
  if cost.mana and EoHS.get_unit_skill(actor, "efficiency") then
    cost.mana = math.ceil(cost.mana * 0.8)
  end
  if cost.action_points and EoHS.get_unit_skill(actor, "enchanter") and action.is_enchantment then
    cost.action_points = math.ceil(cost.action_points * 0.6)
  end
  return cost
end

EoHS.action_range = function(parameters)
  local action = EoHS.actions[parameters.action_id]
  local range
  if type(action.base_range) == "function" then
    range = action.base_range(parameters)
  else
    range = action.base_range
  end
  if not range then return nil end
  
  local actor = EoHS.get_unit(parameters.actor_id)
  if EoHS.get_unit_skill(actor, "farseer") then
    range = range * 2
  end
  return range
end

EoHS.target_types = {
  location = function(parameters, list_entry_only) return {
    name = list_entry_only and _"hex" or _"Any hex",
    details = "",
    validity = EoHS.location_is_on_the_map(parameters.target_x,parameters.target_y) and "valid" or "impossible"
  } end,
  empty_location = function(parameters, list_entry_only)
    local unit = EoHS.get_unit(parameters.target_x,parameters.target_y)
    local unfogged = EoHS.hex_is_unfogged(parameters.target_x,parameters.target_y)
    return {
      name = list_entry_only and _"empty hex" or _"Empty hex",
      details = ((not unfogged) and _"You can't tell if that hex is occupied" or ""),
      validity = (unfogged and not unit) and "valid" or "impossible"
    }
  end,
  unit = function(parameters, list_entry_only)
    local unit = EoHS.get_unit(parameters.target_x,parameters.target_y)
    local unfogged = EoHS.hex_is_unfogged(parameters.target_x,parameters.target_y)
    return {
      name = list_entry_only and _"unit" or _"Any unit",
      details = ((not unfogged) and _"You can't tell if there is a unit there" or ""),
      validity = (unit and unfogged) and "valid" or "impossible"
    }
  end,
  unit_probably_enemy = function(parameters, list_entry_only)
    local unit = EoHS.get_unit(parameters.target_x,parameters.target_y)
    local unfogged = EoHS.hex_is_unfogged(parameters.target_x,parameters.target_y)
    local is_enemy = unit and wesnoth.is_enemy(unit.side, wesnoth.current.side)
    return {
      name = list_entry_only and _"enemy" or _"Any unit",
      details = ((not unfogged) and _"You can't tell if there is a unit there" or ((unit and not is_enemy) and _"You probably don't want to cast that at an ally" or "")),
      validity = ((unit and unfogged)
        and (is_enemy and "valid" or "undesirable")
        or "impossible")
    }
  end,
  unit_probably_ally = function(parameters, list_entry_only)
    local unit = EoHS.get_unit(parameters.target_x,parameters.target_y)
    local unfogged = EoHS.hex_is_unfogged(parameters.target_x,parameters.target_y)
    local is_enemy = unit and wesnoth.is_enemy(unit.side, wesnoth.current.side)
    return {
      name = list_entry_only and _"ally" or _"Any unit",
      details = ((not unfogged) and _"You can't tell if there is a unit there" or ((unit and is_enemy) and _"You probably don't want to cast that at an enemy" or "")),
      validity = ((unit and unfogged)
        and (is_enemy and "undesirable" or "valid")
        or "impossible")
    }
  end,
}

EoHS.action_message = function(parameters, string)
  local values = EoHS.deep_copy(parameters)
  values.action = {}
  for k,v in pairs(EoHS.actions[parameters.action_id]) do
    if (type(k) == "string") and (type(v) ~= "function") then values.action[k] = v end
  end
  if parameters.actor_id then
    values.actor = EoHS.get_unit(parameters.actor_id)
    if values.actor and (values.actor.name == "") then
      values.actor.name = values.actor.language_name
    end
  end
  if parameters.target_x then
    values.target = EoHS.get_unit(parameters.target_x, parameters.target_y)
    if values.target and (values.target.name == "") then
      values.target.name = values.target.language_name
    end
  end
  EoHS.message(EoHS.substitute(string, values), parameters.actor_id)
end
EoHS.cast_message_no_target = function(parameters)
  EoHS.action_message(parameters,
    _"$actor.name| ($actor.x|,$actor.y|) casts $action.name|.")
end
EoHS.cast_message_location_target = function(parameters)
  EoHS.action_message(parameters,
    _"$actor.name| ($actor.x|,$actor.y|) casts $action.name| at ($target_x|,$target_y|).")
end
EoHS.cast_message_unit_target = function(parameters)
  EoHS.action_message(parameters,
    _"$actor.name| ($actor.x|,$actor.y|) casts $action.name| at $target.name| ($target.x|,$target.y|).")
end

EoHS.begin_casting = function(actor_id, target_x, target_y)
  local actor = EoHS.get_unit(actor_id)
  wesnoth.scroll_to_tile(actor.x, actor.y, true)

  if target_x then
    EoHS.face_towards(actor, target_x, target_y)
  end

  EoHS.set_unit_variable(actor, "is_casting_a_spell", true)
  EoHS.update_unit_graphics(actor)
  wesnoth.fire("animate_unit", {
    flag = "EoHS_start_casting",
    with_bars = true,
    { "filter", { x=actor.x, y=actor.y, }},
  })
  EoHS.put_unit(actor, {immediate=true})
  if target_x then
    wesnoth.scroll_to_tile(target_x, target_y, true)
  end
end

EoHS.finish_casting = function(actor_id)
  local actor = EoHS.get_unit(actor_id)
  -- In rare cases, the spell might have killed the caster, so only proceed if they can be found:
  if actor then
    EoHS.set_unit_variable(actor, "is_casting_a_spell")
    EoHS.update_unit_graphics(actor)
    EoHS.put_unit(actor, {immediate=true})
    wesnoth.fire("animate_unit", {
      flag = "EoHS_stop_casting",
      with_bars = true,
      { "filter", { x=actor.x, y=actor.y, }},
    })
  end
end

EoHS.give_random_traits = function(unit, trait_list, num_traits)
  local modifications = EoHS.force_subtag(unit, "modifications")
  EoHS.assert(#trait_list >= num_traits, "trying to give more traits than are available")
  local remaining_traits = EoHS.deep_copy(trait_list)
  while num_traits > 0 do
    local idx = EoHS.random("1.."..#remaining_traits)
    table.insert(modifications, EoHS.macros["TRAIT_"..remaining_traits[idx]][1])
    table.remove(remaining_traits, idx)
  end
end

EoHS.update_summon_trability_info = function(unit, is_after_turn_end_event)
  local summoner = EoHS.get_unit(EoHS.get_unit_variable(unit, "summoner_id"))
  local set_name_and_desc = function(trability)
    if trability.id == "EoHS_summon" then
      local disappears_after_turns = EoHS.get_unit_variable(unit, "disappears_after_turns")
      if disappears_after_turns then
        trability.name = EoHS.substitute(_"summon($1|)", {disappears_after_turns + (is_after_turn_end_event and 1 or 0)})
        trability.description = EoHS.substitute(_"Zero upkeep, gives summoner $1|% of its XP, disappears at the end of your turn $2|",
          {EoHS.get_wizard_setting(summoner,"summon_experience_transfer"), wesnoth.current.turn+disappears_after_turns + (is_after_turn_end_event and 1 or 0)})
      else
        trability.name = _"summon"
        trability.description = EoHS.substitute(_"Zero upkeep, gives summoner $1|% of its XP",
          {EoHS.get_wizard_setting(summoner,"summon_experience_transfer")})
      end
    end
  end
  for i,subtag in ipairs(EoHS.get_subtags(unit, "modifications.trait"                         )) do set_name_and_desc(subtag) end
  for i,subtag in ipairs(EoHS.get_subtags(unit, "modifications.advance.effect.abilities.dummy")) do set_name_and_desc(subtag) end
  for i,subtag in ipairs(EoHS.get_subtags(unit, "abilities.dummy"                             )) do set_name_and_desc(subtag) end
end

EoHS.max_summon_duration_overlays = 7
local summon_overlay = "misc/loyal-icon.png~CS(-50,80,100)"

EoHS.summon_unit = function(summon_prototype, x, y, summoner)
  local unit = EoHS.deep_copy(summon_prototype)

  unit.x = x
  unit.y = y
  unit.side = summoner.side
  unit.moves = 0
  unit.attacks_left = 0
  unit.upkeep = 0
  EoHS.set_unit_variable(unit, "is_summon", true)
  EoHS.set_unit_variable(unit, "summoner_id", summoner.underlying_id)
  local duration = EoHS.get_wizard_setting(summoner, "summon_duration")
  if type(duration) == "number" then EoHS.set_unit_variable(unit, "disappears_after_turns", duration) end
  local type_cfg = EoHS.get_unit_type(unit.type)
  local num_traits = type_cfg.num_traits or wesnoth.races[type_cfg.race].num_traits or 0
  -- Monsters should have traits anyway...
  if EoHS.get_unit_type(unit.type).race == "monster" then
    EoHS.give_random_traits(unit, {"STRONG","INTELLIGENT","QUICK","RESILIENT"}, 2)
    num_traits = 2
  end
  
  local modifications = EoHS.force_subtag(unit, "modifications")
  if num_traits < 2 then
    table.insert(modifications, {"trait",{
      id = "EoHS_summon",
    }})
  else
    table.insert(modifications, {"advance",{ {"effect",{ apply_to = "new_ability", {"abilities",{ {"dummy",{
      id = "EoHS_summon",
    }} }} }} }})
  end
  EoHS.update_summon_trability_info(unit)
  
  --TODO if complete_cost_paid.gold_or_mana then set_unit_variable(summon, "price_originally_summoned_for", complete_cost_paid.gold_or_mana) end
  --local wizard_symbol = helper.get_child(circumstances.caster, "variables").wizard_symbol
  --local image_width, image_height = image_dimensions(wizard_symbol)
  --add_overlay(summon, "misc/blank-hex.png~BLIT("..wizard_symbol..","..math.floor(20 - (image_width / 2))..",12)")
  
  if type(duration) == "number" then
    for i=math.min(duration, EoHS.max_summon_duration_overlays-1),1,-1 do
      unit.overlays = (unit.overlays and unit.overlays.."," or "").."misc/blank-hex.png~BLIT("..summon_overlay.."~SCALE(43,72)~CROP(0,0,43,"..(72-5*i).."),10,"..(5*i)..")"
    end
  end
  unit.overlays = (unit.overlays and unit.overlays.."," or "")..summon_overlay

  EoHS.fake_recruit(unit)
end

EoHS.remove_a_summon_duration_overlay = function(unit)
  unit.overlays = string.gsub(unit.overlays, EoHS.lua_pattern_escape("misc/blank-hex.png~BLIT("..summon_overlay.."~SCALE(43,72)~CROP(0,0,43,").."%d+%),10,%d+%)", "", 1)
end

EoHS.fake_recruit = function(unit)
  EoHS.put_unit(unit, {immediate=true})
  unit = EoHS.get_unit(unit.x, unit.y)
  wesnoth.fire("capture_village", {x=unit.x,y=unit.y,side=unit.side})
  EoHS.fire_event("prerecruit", unit.x, unit.y)
  unit = EoHS.get_unit(unit.underlying_id)
  if unit then
    wesnoth.fire("animate_unit", {
      flag = "recruited",
      { "filter", { x=unit.x, y=unit.y }}
    })
    EoHS.fire_event("recruit", unit.x, unit.y)

    unit = EoHS.get_unit(unit.underlying_id)
    if unit then
      wesnoth.fire("redraw", { side = unit.side })
    end
  end
end

EoHS.make_action = function(id, action)
  if (type(action.image) ~= "string") or not (string.match(action.image, "attacks/") or string.match(action.image, "icons/")) then
    action.image = EoHS.collapse_image_aggregate(EoHS.image_aggregates_combined(
      "attacks/blank-attack.png",
      EoHS.image_aggregate_cropped(action.image, {size={x=50,y=50},offset={x=0,y=0}})
    ), "image_modded")
  end
  EoHS.actions[id] = action
end

EoHS.make_summoning_spell = function(id, prototype, action)
  action.is_summon = true
  if not action.image then
    
  end
  EoHS.make_action(id, action)
end

>>)}
