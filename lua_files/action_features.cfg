this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- action_features.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil


EoHS.must_target_unit = function (parameters, stuff)
  local unit = EoHS.get_seen_unit (parameters.target_x, parameters.target_y, parameters.side)
  if not unit then
    table.insert (stuff, {"label", {
      x= parameters.target_x, y= parameters.target_y,
      text =_"You must target a unit.",
      forbidden = true,
    }})
  end
end

EoHS.simple_location_enchantment = function(get, visual, warning)
  return function()
    local result = {}
    table.insert (result, {"item", {
      x= parameters.target_x, y= parameters.target_y, halo = visual,
    }})
    if get(parameters.target_x, parameters.target_y) then
      table.insert (result, {"label", {
        x= parameters.target_x, y= parameters.target_y,
        text = warning,
        forbidden = true,
      }})
    end
    return result
  end
end

EoHS.simple_unit_enchantment = function(visual, restrictions)
  return function(parameters)
    local result = {}
    table.insert (result, {"item", {
      x= parameters.target_x, y= parameters.target_y, halo = visual,
    }})
    local unit = EoHS.get_seen_unit (parameters.target_x, parameters.target_y, parameters.side)
    EoHS.must_target_unit (parameters, result)
    local restriction = unit and restrictions and restrictions(unit, parameters, result)
    if restriction then
      table.insert (result, {"label", {
        x= parameters.target_x, y= parameters.target_y,
        text = restriction,
        forbidden = true,
      }})
    end
    return result
  end
end

EoHS.target_types = {
  recruit = function(parameters, known_or_actual)
    local actor = EoHS.get_unit(parameters.actor_id)
    local keep = wesnoth.get_terrain_info(wesnoth.get_terrain(actor.x, actor.y)).keep
    local unit = EoHS.get_seen_unit(parameters.target_x,parameters.target_y,actor.side)
    local path = EoHS.find_path(actor.x,actor.y,parameters.target_x,parameters.target_y,function(x,y) return wesnoth.get_terrain_info(wesnoth.get_terrain(x, y)).castle and 1 or nil end)
    local unfogged = EoHS.hex_is_unfogged(parameters.target_x,parameters.target_y)
    -- Intentionally allowing impassable
    return {
      short_name = _"recruit hex",
      name = _"Recruit hex",
      details = ((not unfogged) and _"You can't tell if that hex is occupied." or ""),
      validity = (keep and path[1] and unfogged and not unit) and "valid" or "impossible"
    }
  end,
}

EoHS.make_touch_enchantment = function(id, action)
  action.is_enchantment = true
  if not action.target_independent_stuff then action.target_independent_stuff = function(parameters)
    local actor = EoHS.get_unit(parameters.actor_id)
    local touch_enchantment = EoHS.get_unit_variable(actor, "touch_enchantment")
    if touch_enchantment == id then
      return {{"text",{forbidden = true, text =_"You already have this touch enchantment active."}}}
    elseif touch_enchantment then
      return {{"text",{color = EoHS.mediocre_color, text =_"You will replace your current touch enchantment."}}}
    end
    
    return {}
  end end
  if not action.happen then action.happen = function(parameters, extras)
    EoHS.begin_casting(parameters.actor_id)
    local actor = EoHS.get_unit(parameters.actor_id)
    EoHS.set_unit_variable(actor, "touch_enchantment", id)
    EoHS.update_all_type_adjustments(actor)
    if action.sound then extras.do_on_clients_who_see(function() wesnoth.fire("sound", { name = action.sound }) end) end
    EoHS.put_unit(actor, {immediate=true})
    EoHS.finish_casting(parameters.actor_id)
  end end
  
  EoHS.make_spell(id, action)
end

local ritual_desc = _"This spell takes $1| turns (counting the turn you start it), and takes effect at the beginning of its last turn. Once you start casting this spell, you cannot move, attack, or cast other spells, or earn mana until after its last turn (or the turn when you cancel it)."
EoHS.make_ritual = function(id, action)
  local ritual_turns = function(parameters)
    local result = action.turns
    local actor = EoHS.get_unit(parameters.actor_id)
    if action.is_summon and EoHS.get_unit_skill(actor, "summoner") then
      result = result - 1
    end
    if action.is_enchantment and EoHS.get_unit_skill(actor, "enchanter") then
      result = result - 1
    end
    return result
  end
  
  action.is_ritual = true
  
  if type(action.base_cost) == "table" then action.base_cost.action_points = 11
  elseif type(action.base_cost) == "function" then 
    local old_func = action.base_cost
    action.base_cost = function(parameters)
      local result = old_func(parameters)
      result.action_points = 11
      return result
    end
  else
    action.base_cost = { action_points = 11 }
  end
    
  local old_make_extra_attributes = action.make_extra_attributes
  action.target_independent_stuff = function(parameters, extras)
    local result = old_make_extra_attributes(parameters, extras)
    local turns = ritual_turns(parameters)
    table.insert (result, {kind =_"Ritual:", value = EoHS.substitute(_"$1| turns", {turns}), because = EoHS.substitute(ritual_desc, {turns})})
    return result
  end
  action.happen = function(parameters)
    local actor = EoHS.get_unit(parameters.actor_id)
    EoHS.begin_casting(parameters.actor_id, parameters.target_x, parameters.target_y)
    EoHS.set_unit_variable(actor, "ritual", id)
    EoHS.set_unit_variable(actor, "ritual_runes", ritual_turns(parameters))
    EoHS.set_unit_variable(actor, "ritual_runes_lit", 1)
    table.insert(EoHS.force_subtag(actor, "variables"), {"ritual_parameters",parameters})
    
    -- for graphics' sake:
    local ritual_parameters_fake = EoHS.get_fake_subtag(EoHS.force_unit_variables(actor), "ritual_parameters")
    for k,v in pairs(parameters) do if type(k) == "string" then ritual_parameters_fake[k] = v end end
    
    actor.moves = 0
    EoHS.set_unit_action_points_immediate(actor, 0)
    EoHS.update_all_type_adjustments(actor)
    EoHS.put_unit(actor)
  end
  
  EoHS.make_spell(id, action)
end

EoHS.soon(function()
  EoHS.make_action("cancel_ritual", {
    image = "scenery/tent-ruin-1.png",
    name = _"Cancel Ritual",
    description = _"You abandon your current ritual. You don't recover any of the cost, and you still can't move this turn, but you'll be able to move next turn.",
    
    use_message = function(parameters)
      local actor = EoHS.get_unit(parameters.actor_id)
      return _"$actor_name| ($actor.x|,$actor.y|) stops casting $ritual|.", {ritual=EoHS.actions[EoHS.get_unit_variable(actor, "ritual")].name}
    end,
    
    happen = function(parameters)
      local actor = EoHS.get_unit(parameters.actor_id)
      EoHS.set_unit_variable(actor, "ritual")
      EoHS.update_all_type_adjustments(actor)
      EoHS.put_unit(actor)
      EoHS.finish_casting(parameters.actor_id)
    end,
  })
end)

EoHS.skill_attack = function(actor, realm)
  for attack in helper.child_range(actor, "attack") do
    if attack.name == "EoHS_"..realm.."_skill_ranged_attack" then
        local result = EoHS.deep_copy(attack)
        EoHS.remove_subtags(result, "specials.*", "EoHS_lightning_paralysis")
        EoHS.remove_subtags(result, "specials.*", "EoHS_just_teleported_1")
        EoHS.remove_subtags(result, "specials.*", "EoHS_just_teleported_2")
        EoHS.remove_subtags(result, "specials.*", "EoHS_liminal_compensation")
        if EoHS.get_unit_skill (actor, "forceful") then
          result.damage = math.floor ((result.damage*15+5)/10)
          -- not using specials because it has unfavorable math (see bug #21620)
          -- table.insert (EoHS.force_subtag (result, "specials"), {"damage", {id = "EoHS_forceful", name =_"forceful", multiply = "1.5"}}) 
        end
        result.is_spell = true
        return result
    end
  end
end

EoHS.skill_attack_func = function(realm, func)
  return function(actor)
    local result = EoHS.skill_attack(actor, realm)
    if result then
      func(result)
      return result
    end
  end
end

EoHS.make_attack_attribute = function(make_aspect, list_entry_only, attacker, defender_x, defender_y, attack, viewing_side)
  if not viewing_side then viewing_side = attacker.side end
  local defender = EoHS.get_seen_unit(defender_x, defender_y, viewing_side)
  if defender then
    local value,details,validity="","","valid"
    local name = EoHS.unit_appellation(defender)
    if EoHS.unit_is_immune_to_direct_spell_damage(defender) then
      value = _"None"
      details = EoHS.unit_is_immune_to_direct_spell_damage_description(defender)
    else
      if not wesnoth.is_enemy(defender.side, viewing_side) then validity = "undesirable" end
      if not list_entry_only then
        local attack_context = EoHS.game_action_simulations.fleshed_out_attack_context({
          attacker={x=attacker.x,y=attacker.y,attack=attack},
          defender={x=defender.x,y=defender.y}})
        if attack_context then
          value = attack_context.attacker.damage.."-"..attack_context.attacker.attacks
        else
          EoHS.err("attack context failed in EoHS.make_attack_attribute")
          value = _"None"
          details = _"It doesn't work for some reason..."
        end
      end
    end
    make_aspect({
      type=EoHS.substitute(_"Damage to $1|", {name}),
      value=value,
      details=details,
      validity=validity,
      doesnt_affect_scribing = true,
    })
  end
end
EoHS.spell_attack_info = function(attacker, defender_x, defender_y, attack)
  local attack_spec = EoHS.deep_copy(attack)
  attack_spec.name = "EoHS_action_attack"
  if EoHS.get_unit(defender_x,defender_y) then
    local attacker_id = EoHS.unit_id(attacker)
    return {context={
      attacker={x=attacker.x,y=attacker.y,attack=attack_spec},
      defender={x=defender_x,y=defender_y}
    }, extras={spend_moves_and_attacks = false}}
  end
end
EoHS.attack_missing_aspect = function(make_aspect)
  make_aspect.type_and_details(_"Can't cast:", _"You don't have the relevant attack right now.", "impossible")
end
EoHS.ensure_attack_allowed = function(make_aspect, attack)
  if not attack then
    EoHS.attack_missing_aspect(make_aspect)
    return false
  end
  return true
end

local path_types =
  {{1,1,1,1,1,1},
   {1,1,2,1,1,2},
   {1,2,1,2,1,2},}

EoHS.get_6hex_path_directions = function(x1,y1,x2,y2)
  for d,dir1 in ipairs({"n","ne","se","s","sw","nw"}) do
    for d,dir2 in ipairs({EoHS.direction_clockwise_from(dir1),EoHS.direction_counterclockwise_from(dir1)}) do
      for d,path_type in ipairs(path_types) do
        local x,y = x1,y1
        for pass = 1, math.ceil(helper.distance_between(x1,y1,x2,y2)/6) do
          for i=1,6 do
            x,y = EoHS.get_loc_in_direction(x,y,(path_type[i]==1) and dir1 or dir2)
            if (x==x2) and (y==y2) then
              local result = {}
              for j=1,6 do table.insert(result,(path_type[j]==1) and dir1 or dir2) end
              return result
            end
          end
        end
      end
    end
  end
end

EoHS.get_6hex_path_hexes = function(parameters, known_or_actual, allowed_hexes_func)
  local dirs = EoHS.get_6hex_path_directions(parameters.src_x,parameters.src_y,parameters.target_x,parameters.target_y)
  if not dirs then return {} end
  local x,y = parameters.src_x,parameters.src_y
  local result = {}
  for i=0,(EoHS.apply_farseer(5, parameters) - 1) do
    x,y = EoHS.get_loc_in_direction(x,y,dirs[1+(i%6)])
    if not EoHS.location_is_known_or_actual_passable(x,y,parameters.side,known_or_actual) then break end
    if allowed_hexes_func and not allowed_hexes_func(x,y) then break end
    table.insert(result, {x=x,y=y, previous_direction = dirs[1+(i%6)], next_direction = dirs[1+((i+1)%6)]})
  end
  return result
end

EoHS.get_6hex_path_targeting_range = function (parameters)
  local range = EoHS.apply_farseer(5, parameters)
  local found_hexes = {}
  local result = {}
  for d,dir1 in ipairs({"n","ne","se","s","sw","nw"}) do
    for d,dir2 in ipairs({EoHS.direction_clockwise_from(dir1),EoHS.direction_counterclockwise_from(dir1)}) do
      for d,path_type in ipairs(path_types) do
        local x,y = parameters.src_x,parameters.src_y
        for i=0,range - 1 do
          x,y = EoHS.get_loc_in_direction(x,y,dirs[1+(i%6)])
          -- Note: do NOT block at impassable hexes, because that could restrict the directions you can fire
          local index = x..","..y
          if not found_hexes [index] then
            found_hexes [index] = true
            table.insert (result, {x=x,y=y})
          end
        end
      end
    end
  end
  return result
end

-->>)}
