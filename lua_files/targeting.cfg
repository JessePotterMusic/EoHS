this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- targeting.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack,xpcall = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack,xpcall
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

local independent = "independent"
local dependent = "dependent"

EoHS.action_specific_stuff = function (kind, parameters, extras)
  local action = EoHS.actions [parameters.action_id]
  local stuff = action["target_"..kind.."_stuff"]
  if stuff then return stuff(parameters, extras) end
  return {}
end
EoHS.all_action_stuff = function (kind, parameters, extras)
  -- you can omit the "kind" parameter if you want everything
  if type (kind) == "table" then
    local result = EoHS.all_action_stuff (independent, kind, parameters)
    for index, thing in ipairs (EoHS.all_action_stuff (dependent, kind, parameters)) do
      table.insert (result, thing)
    end
    return result
  end
  
  extras = extras or {}
  local result = {}
  local range = EoHS.action_range (parameters)
  
  if range and not extras.ignore_range then
    if kind == independent then
      table.insert (result, {"aspect", {
        kind= _"Range",
        value= tostring(range),
      }})
    else
      local distance = EoHS.distance_between (
        parameters.src_x, parameters.src_y,
        parameters.target_x, parameters.target_y,
        EoHS.known_passable_only (parameters.side), 100)
      local valid = distance and distance <= range
      if not (distance and distance <= 100) then distance = "Unreachable" end
      table.insert (result, {"text", {
        text = EoHS.substitute (_"Distance: $1|", {distance}),
        forbidden = not valid,
      }})
    end
  end
  
  if kind == independent then
    local action = EoHS.actions [parameters.action_id]
    local cost = EoHS.action_cost(parameters)
    local actor = EoHS.get_unit(parameters.actor_id)
  
    if cost.action_points then
      table.insert (result, {"aspect", {
        kind=_"AP",
        value=tostring(cost.action_points),
        forbidden = EoHS.get_unit_action_points(actor) < cost.action_points,
        standard_aspect_index = "ap",
      }})
    end
    if cost.once_per_turn then
      if EoHS.get_unit_variable (actor, "used_"..parameters.action_id) then
        table.insert (result, {"text", {
          text=_"You already cast this spell this turn.",
          forbidden = true,
        }})
      end
    end
    local mana = math.max(0, EoHS.get_unit_variable(actor, "mana") or 0)
    local total_mana_available = mana
    if EoHS.get_wizard_setting(actor, "can_spend_gold_on_spells") then
      total_mana_available = total_mana_available + math.max(0, wesnoth.sides[actor.side].gold)
    end
    if (cost.mana or 0) + EoHS.scroll_cost > total_mana_available then
      whole_action_scroll_validity = "impossible"
    end
    if cost.mana then
      local s = {
        kind=_"Mana cost",
        value=""..cost.mana,
        standard_aspect_index = "mana",
      }
      if mana >= cost.mana then
        -- ... 
      elseif EoHS.get_wizard_setting(actor, "can_spend_gold_on_spells") and (mana+wesnoth.sides[actor.side].gold >= cost.mana) then
        s.details = EoHS.substitute(_"You will transmute $1| gold into mana.", {cost.mana-mana})
      else
        s.forbidden = true
      end
      table.insert (result, {"aspect", s})
    end
  
    if cost.gold then
      table.insert (result, {"aspect", {
        kind=_"Gold cost",
        value=""..cost.gold,
        forbidden = wesnoth.sides[actor.side].gold < cost.gold,
      }})
    end
    
    if (action.is_spell and not parameters.scroll_id) and (EoHS.get_unit_variable(actor, "spiritform")) or (EoHS.get_unit_variable(actor, "ogre_fury")) then
      table.insert (result, {"text", {
        text=_"You can't cast spells while transformed.",
        forbidden = true,
      }})
    end
    if parameters.given_recently then
      table.insert (result, {"text", {
        text=_"A unit can't use a scroll it was given on the same turn.",
        forbidden = true,
      }})
    end
  end
  
  if extras and extras.list_entry_only then
    extras = EoHS.deep_copy (extras)
    extras.validity_only = true
  end
  for index, thing in ipairs (EoHS.action_specific_stuff (kind, parameters, extras)) do
    table.insert (result, thing)
  end
  return result
end

EoHS.targeting_elements = function (kind, stuff, parameters, extras)
  local action = EoHS.actions [parameters.action_id]
  local result = {}
  local do_text = function (thing)
    local text
    if thing [1] == "text" then
      text = thing [2].text
    elseif thing [1] == "aspect" then
      text = EoHS.substitute (_"$kind|$value|$details|", {
        kind= thing [2].kind and thing [2].kind..":" or "",
        value= thing [2].value and " "..thing [2].value or "",
        details= thing [2].details and "\n  ("..thing [2].details..")" or "",
      })
    end
    if text then
      local color = thing [2].color
      if not color then
        color = EoHS.validity_color (not thing [2].forbidden)
      end
      if type(color) == "table" then
        color = EoHS.element_color (color)
      end
      text = EoHS.wrap_text (tostring (text), 22, {subsequent_indentation = 2})
      table.insert (result, {"element", {
        text = '<span color="'..color ..'">'..text..'</span>\n',
      }})
    end
  end
  
  if kind == independent then
    do_text ({"text", {
      text = EoHS.substitute (_"\nCasting $1|\n  Right-click to choose a target. Right-click off the map to cancel.", {action.name})
    }})
  end
  for index, thing in ipairs (stuff) do
    do_text (thing)
  end
  return result
end

EoHS.target_is_valid = function (parameters, extras)
  extras = EoHS.deep_copy (extras) or {}
  extras.validity_only = true
  for index, thing in ipairs (EoHS.all_action_stuff (dependent, parameters, extras)) do
    if thing [2].forbidden then
      return false
    end
  end
  return true
end

EoHS.action_is_valid = function (parameters, extras)
  extras = EoHS.deep_copy (extras) or {}
  extras.validity_only = true
  for index, thing in ipairs (EoHS.all_action_stuff (dependent, parameters, extras)) do
    if thing [2].forbidden then
      return false
    end
  end
  return extras.ignore_target or EoHS.target_is_valid (parameters, extras)
end



EoHS.choose_target = function (parameters)
  EoHS.assert (not EoHS.context.unison, "choose_target should only happen for one player")
  local action = EoHS.actions [parameters.action_id]
  local actor = EoHS.get_unit (parameters.actor_id)
  local range = EoHS.action_range (parameters)
  local info = {
    parameters = parameters,
    legal_targets_map = {},
    no_choice = false,
    done = false,
    stuff = {
      independent = {},
      dependent = {},
    },
    elements = {
      independent = {},
      dependent = {},
    },
  }
  if not (range or action.targeting_range_override) then
    info.no_choice = true
  else
    local legal_targets_array =  action.targeting_range_override and  action.targeting_range_override(parameters) or EoHS.find_reach (parameters.src_x, parameters.src_y, EoHS.known_passable_only (parameters.side), range)
    EoHS.filter (legal_targets_array, function(target)
      parameters.target_x = target.x
      parameters.target_y = target.y
      return EoHS.target_is_valid (parameters, {ignore_range = true})
    end)
    
    for index, target in ipairs (legal_targets_array) do
      info.legal_targets_map [target.x..","..target.y] = target
    end
  end
  
  
  local init_stuff = function(kind)
    for item in helper.child_range (info.stuff [kind], "item") do
      EoHS.place_item (item)
    end
    for label in helper.child_range (info.stuff [kind], "label") do
      local label = EoHS.deep_copy (label)
      -- only one client can see the labels anyway, but making them team labels
      -- means they DON'T override regular labels, which is good for map compatibility.
      if not label.color then
        label.color = EoHS.label_color (EoHS.validity_color (not label.forbidden))
      end
      label.team_name = wesnoth.sides [info.parameters.side].team_name
      wesnoth.fire ("label", label)
    end
    info.elements [kind] = EoHS.targeting_elements (kind, info.stuff [kind], parameters)
  end
  local clear_stuff = function (kind)
    for item in helper.child_range (info.stuff [kind], "item") do
      EoHS.remove_item (item)
    end
    for label in helper.child_range (info.stuff [kind], "label") do
      wesnoth.fire ("label", {
        x=label.x,
        y=label.y,
        team_name = wesnoth.sides [info.parameters.side].team_name,
        text="",
        immutable = false,
      })
    end
    info.stuff [kind] = {}
  end
  local change_target = function (x, y)
    clear_stuff (dependent)
    info.parameters.target_x,info.parameters.target_y = x,y
    if x then
      info.stuff [dependent] = EoHS.all_action_stuff (dependent, parameters)
      init_stuff (dependent)
    end
    wesnoth.fire ("redraw")
  end
  
  
  info.stuff [independent] = EoHS.all_action_stuff (independent, parameters)
  local width, height = wesnoth.get_map_size()
  for something = 0, width+1 do for whatever = 0, height+1 do
    if (not info.no_choice) and (not info.legal_targets_map [something..","..whatever]) then
      table.insert (info.stuff [independent], {"item",{x= something,y= whatever, halo = "terrain/darken.png"}})
    end
  end end
  
  init_stuff (independent)
  
  info.change_target = change_target
  
  EoHS.current_targeting_info = info
  
  wesnoth.select_hex (parameters.src_x, parameters.src_y, false, false)
  
  -- suppress footsteps
  local old_moves = actor.max_moves
  local old_attacks = actor.attacks_left
  actor.max_moves = 0
  actor.attacks_left = 0
  wesnoth.put_unit (actor)
  wesnoth.fire ("redraw")
  
  while not info.done do
    wesnoth.fire ("delay", {time = 10})
    --wesnoth.fire ("redraw")
  end  
  
  clear_stuff (dependent)
  clear_stuff (independent)
  actor.max_moves = old_moves
  actor.attacks_left = old_attacks
  wesnoth.put_unit (actor)
  EoHS.redraw()
end


--[[EoHS.soon (function() EoHS.on_click (function(x,y)
  local info = EoHS.current_targeting_info
  if false and info and not info.done then
    if info.no_choice or info.legal_targets_map [x..","..y] then
      info.parameters.target_x,info.parameters.target_y = x,y
      info.done = true
    else
      --
    end
  end
end) end)]]

EoHS.soon (function() EoHS.on_deselect (function(x,y)
  local info = EoHS.current_targeting_info
  if info and not info.done then
    if not (info.no_choice or (info.parameters.target_x and info.legal_targets_map [info.parameters.target_x..","..info.parameters.target_y])) then
      info.parameters.target_x,info.parameters.target_y = nil,nil
    end
    info.done = true
  end
end) end)

EoHS.soon (function() EoHS.on_mouse_move (function(x,y)
  local info = EoHS.current_targeting_info
  if info and not info.done then
    info.change_target (x,y)
  end
end) end)

--[[EoHS.soon (function() EoHS.frequently (100, function()
  local info = EoHS.current_targeting_info
  if info and not info.done then
    local do_item = function (item)
      if item.float_label then
        wesnoth.fire ("label", {
          x=item.x,
          y=item.y,
          text=item.float_label,
          -- only one client can see the labels anyway, but making them team labels
          -- means they DON'T override regular labels, which is good for map compatibility.
          team_name = wesnoth.sides [info.parameters.side].team_name,
          visible_in_shroud = true,
          immutable = false,
        })
      end
    end
    for index, item in ipairs (info.stuff [independent]) do
      do_item(item)
    end
    for index, item in ipairs (info.items [dependent]) do
      do_item(item)
    end
  end
end) end)]]


-->>)}
