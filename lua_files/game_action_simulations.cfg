{EOHS_LUA_FILE (<<-- game_action_simulations.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery

EoHS.game_action_simulations = {
  --unit get_advanced_unit(const unit &u, const std::string& advance_to)
  --{
  advance_unit_internal = function(unit, advance_to)
    if type(advance_to) == "table" then
      --support AMLA here?
      EoHS.err("TODO")
    end
    --const unit_type *new_type = unit_types.find(advance_to);
    local new_type = wesnoth.unit_types[advance_to]
    
    --if (!new_type) {
    if not new_type then
      --throw game::game_error("Could not find the unit being advanced"
      --  " to: " + advance_to);
      EoHS.err("Could not find the unit being advanced to: "..advance_to)
    --}
    end
    --unit new_unit(u);
    --new_unit.set_experience(new_unit.experience() - new_unit.max_experience());
    unit.experience = unit.experience - unit.max_experience
    --new_unit.advance_to(new_type);
    EoHS.transform_unit(unit, advance_to)
    unit.hitpoints = unit.max_hitpoints
    --new_unit.set_state(unit::STATE_POISONED, false);
    EoHS.set_subtag_attribute(unit, "status.poisoned", false)
    --new_unit.set_state(unit::STATE_SLOWED, false);
    EoHS.set_subtag_attribute(unit, "status.slowed", false)
    --new_unit.set_state(unit::STATE_PETRIFIED, false);e
    EoHS.set_subtag_attribute(unit, "status.petrified", false)
    --new_unit.set_user_end_turn(false);
    --new_unit.set_hidden(false);
    EoHS.set_subtag_attribute(unit, "status.uncovered", true)
    --return new_unit;
  --}
  end,
  
  advance_unit_on_map = function(x, y, advance_to, animate, fire_event)
    EoHS.assert(EoHS.location_is_on_the_map(x,y), "EoHS.game_action_simulations.advance_unit_on_map with off-map unit")
    local unit = EoHS.get_unit(x, y)
    EoHS.assert(unit, "EoHS.game_action_simulations.advance_unit_on_map no unit")
    EoHS.assert(unit.experience >= unit.max_experience, "EoHS.game_action_simulations.advance_unit_on_map with unit that shouldn't advance")
    
    if animate then
      wesnoth.fire("animate_unit", {
        { "filter", { x=x, y=y }},
        flag="levelout"
      })
    end
    
    if fire_event then
      local original_type = unit.type
      wesnoth.fire_event("advance", x, y)
      -- Note: In 1.10.7 there appears to be a bug where AMLA (and only AMLA) overwrites the results of an advance event.
      -- I have no desire to faithfully replicate this bug, since no scenario should rightly rely on it.
      unit = EoHS.get_unit(x, y)
      if not (unit and (unit.experience >= unit.max_experience) and (unit.type == original_type)) then return end
    end
    
    EoHS.game_action_simulations.advance_unit_internal(unit, advance_to)
    EoHS.put_unit(unit)
    
    if fire_event then
      wesnoth.fire_event("post_advance", x, y)
      unit = EoHS.get_unit(x, y)
      if not unit then return end
    end
    
    if animate then
      wesnoth.fire("animate_unit", {
        { "filter", { x=x, y=y }},
        flag="levelin"
      })
    end
  end,
  
  

  --void attack_unit(const map_location &attacker, const map_location &defender,
  --        int attack_with, int defend_with, bool update_display)
  --{
  attack_unit = function(ax, ay, dx, dy, a_weapon_index_zero_based, d_weapon_index_zero_based)
    --attack dummy(attacker, defender, attack_with, defend_with, update_display);
    --attack::attack(const map_location &attacker, const map_location &defender,
    --            int attack_with,
    --            int defend_with,
    --            bool update_display) :
    --    bc_(0),
    --    a_stats_(0),
    --    d_stats_(0),
    --    abs_n_attack_(0),
    --    abs_n_defend_(0),
    --    update_att_fog_(false),
    --    update_def_fog_(false),
    --    update_minimap_(false),
    --    a_(attacker, attack_with, *resources::units),
    --    d_(defender, defend_with, *resources::units),
    --    units_(*resources::units),
    --    errbuf_(),
    --    update_display_(update_display),
    --    OOS_error_(false)
    --{
    --}
    local load_unit = function(x, y, weapon_index_zero_based)
      local unit = EoHS.get_unit(x, y)
      local attacks = {}
      for i,subtag in ipairs(unit) do
        if subtag[1] == "attack" then
          table.insert(attacks, subtag[2])
          attacks[subtag[2].id] = #attacks
        end
      end
      return {
        unit = unit,
        attacks = attacks,
        attack = attacks[weapon_index_zero_based+1],
      }
    end
    local a = load_unit(ax, ay)
    local d = load_unit(dx, dy)
    --dummy.perform();
    --void attack::perform()
    --{
      --// Stop the user from issuing any commands while the units are fighting
      --const events::command_disabler disable_commands;

        --if(!a_.valid() || !d_.valid()) {
        --        return;
        --}
        if (not a.unit) or (not d.unit) then return end

        --// no attack weapon => stop here and don't attack
        --if (a_.weapon_ < 0) {
        if a_weapon_index_zero_based < 0 then
                --a_.get_unit().set_attacks(a_.get_unit().attacks_left()-1);
          a.unit.attacks_left = a.unit.attacks_left - 1
                --a_.get_unit().set_movement(-1);
          a.unit.moves = 0
                --return;
          return
        --}
        end

        --a_.get_unit().set_attacks(a_.get_unit().attacks_left()-1);
        a.unit.attacks_left = a.unit.attacks_left - 1
        --VALIDATE(a_.weapon_ < static_cast<int>(a_.get_unit().attacks().size()),
        --        _("An invalid attacker weapon got selected."));
        EoHS.assert(a.attacks[a_weapon_index_zero_based+1], "EoHS.game_action_simulations.attack_unit An invalid attacker weapon got selected.")
        --a_.get_unit().set_movement(a_.get_unit().movement_left() -
        --        a_.get_unit().attacks()[a_.weapon_].movement_used());
        a.unit.moves = a.unit.moves - (a.attack.movement_used or 100000) -- accurate to hard-coded value in unit_types.hpp:62 (1.10.7)
        --a_.get_unit().set_state(unit::STATE_NOT_MOVED,false);
        --a_.get_unit().set_resting(false);
        --d_.get_unit().set_resting(false);
        a.unit.resting = false
        d.unit.resting = false

        --// If the attacker was invisible, she isn't anymore!
        --a_.get_unit().set_state(unit::STATE_UNCOVERED, true);
        EoHS.set_subtag_attribute(a.unit, "status.uncovered", true)

        --bc_ = new battle_context(units_, a_.loc_, d_.loc_, a_.weapon_, d_.weapon_);
        --a_stats_ = &bc_->get_attacker_stats();
        --d_stats_ = &bc_->get_defender_stats();
        --if(a_stats_->weapon) {
        --        a_.weap_id_ = a_stats_->weapon->id();
        --}
        --if(d_stats_->weapon) {
        --        d_.weap_id_ = d_stats_->weapon->id();
        --}

        --try {
        --        fire_event("attack");
        --} catch (attack_end_exception) {
        --        return;
        --}
        fire_event("attack")
        --refresh_bc();

        --DBG_NG << "getting attack statistics\n";
        --statistics::attack_context attack_stats(a_.get_unit(), d_.get_unit(), a_stats_->chance_to_hit, d_stats_->chance_to_hit);

        --{
                // Calculate stats for battle
                combatant attacker(bc_->get_attacker_stats());
                combatant defender(bc_->get_defender_stats());
                attacker.fight(defender,false);
                const double attacker_inflict = static_cast<double>(d_.get_unit().hitpoints()) - defender.average_hp();
                const double defender_inflict = static_cast<double>(a_.get_unit().hitpoints()) - attacker.average_hp();

                attack_stats.attack_expected_damage(attacker_inflict,defender_inflict);
        }

        a_.orig_attacks_ = a_stats_->num_blows;
        d_.orig_attacks_ = d_stats_->num_blows;
        a_.n_attacks_ = a_.orig_attacks_;
        d_.n_attacks_ = d_.orig_attacks_;
        a_.xp_ = d_.get_unit().level();
        d_.xp_ = a_.get_unit().level();

        bool defender_strikes_first = (d_stats_->firststrike && !a_stats_->firststrike);
        unsigned int rounds = std::max<unsigned int>(a_stats_->rounds, d_stats_->rounds) - 1;
        const int attacker_side = a_.get_unit().side();
        const int defender_side = d_.get_unit().side();

        static const std::string poison_string("poison");

        LOG_NG << "Fight: (" << a_.loc_ << ") vs (" << d_.loc_ << ") ATT: " << a_stats_->weapon->name() << " " << a_stats_->damage << "-" << a_stats_->num_blows << "(" << a_stats_->chance_to_hit << "%) vs DEF: " << (d_stats_->weapon ? d_stats_->weapon->name() : "none") << " " << d_stats_->damage << "-" << d_stats_->num_blows << "(" << d_stats_->chance_to_hit << "%)" << (defender_strikes_first ? " defender first-strike" : "") << "\n";

        // Play the pre-fight animation
        unit_display::unit_draw_weapon(a_.loc_,a_.get_unit(),a_stats_->weapon,d_stats_->weapon,d_.loc_,&d_.get_unit());

        for (;;)
        {
                DBG_NG << "start of attack loop...\n";
                ++abs_n_attack_;

                if (a_.n_attacks_ > 0 && !defender_strikes_first) {
                        if (!perform_hit(true, attack_stats)) break;
                }

                // If the defender got to strike first, they use it up here.
                defender_strikes_first = false;
                ++abs_n_defend_;

                if (d_.n_attacks_ > 0) {
                        if (!perform_hit(false, attack_stats)) break;
                }

                // Continue the fight to death; if one of the units got petrified,
                // either n_attacks or n_defends is -1
                if(rounds > 0 && d_.n_attacks_ == 0 && a_.n_attacks_ == 0) {
                        a_.n_attacks_ = a_.orig_attacks_;
                        d_.n_attacks_ = d_.orig_attacks_;
                        --rounds;
                        defender_strikes_first = (d_stats_->firststrike && ! a_stats_->firststrike);
                }

                if (a_.n_attacks_ <= 0 && d_.n_attacks_ <= 0) {
                        fire_event("attack_end");
                        refresh_bc();
                        break;
                }
        }

        // TODO: if we knew the viewing team, we could skip some of these display update
        if (update_att_fog_ && (*resources::teams)[attacker_side - 1].uses_fog())
        {
                recalculate_fog(attacker_side);
                if (update_display_) {
                        resources::screen->invalidate_all();
                        resources::screen->recalculate_minimap();
                }
        }
        if (update_def_fog_ && (*resources::teams)[defender_side - 1].uses_fog())
        {
                recalculate_fog(defender_side);
                if (update_display_) {
                        resources::screen->invalidate_all();
                        resources::screen->recalculate_minimap();
                }
        }

        if (update_minimap_ && update_display_) {
                resources::screen->recalculate_minimap();
        }

        if (a_.valid()) {
                unit &u = a_.get_unit();
                u.set_standing();
                u.set_experience(u.experience() + a_.xp_);
        }

        if (d_.valid()) {
                unit &u = d_.get_unit();
                u.set_standing();
                u.set_experience(u.experience() + d_.xp_);
        }

        unit_display::unit_sheath_weapon(a_.loc_,a_.valid()?&a_.get_unit():NULL,a_stats_->weapon,
                        d_stats_->weapon,d_.loc_,d_.valid()?&d_.get_unit():NULL);

        if (update_display_){
                resources::screen->invalidate_unit();
                resources::screen->invalidate(a_.loc_);
                resources::screen->invalidate(d_.loc_);
                resources::screen->draw(true, true);
        }

        if(OOS_error_) {
                replay::process_error(errbuf_.str());
        }
}

  --}
  end,
}

>>)}
