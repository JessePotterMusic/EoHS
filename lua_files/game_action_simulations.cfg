this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- game_action_simulations.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

--[[

combatant = { unit=,weapon_index_zero_based= number, -1 for no attack, or "choose" }
attack_context = {
  attacker = combatant
  defender = combatant
}

]]

EoHS.game_action_simulations = {
  advance_unit_internal = function(unit, advance_to) -- unit get_advanced_unit(const unit &u, const std::string& advance_to) {
    if type(advance_to) == "table" then
      --support AMLA here?
      EoHS.err("TODO")
    end
   
    if not wesnoth.unit_types[advance_to] then                            -- const unit_type *new_type = unit_types.find(advance_to); if (!new_type) {
      EoHS.err("Could not find the unit being advanced to: "..advance_to) -- throw game::game_error("Could not find the unit being advanced" " to: " + advance_to);
    end                                                                   -- }
                                                               -- unit new_unit(u); 
    unit.experience = unit.experience - unit.max_experience    -- new_unit.set_experience(new_unit.experience() - new_unit.max_experience());
   
    EoHS.transform_unit(unit, advance_to)                      -- new_unit.advance_to(new_type);
    unit.hitpoints = unit.max_hitpoints
    EoHS.set_subtag_attribute(unit, "status.poisoned" , false) -- new_unit.set_state(unit::STATE_POISONED, false);
    EoHS.set_subtag_attribute(unit, "status.slowed"   , false) -- new_unit.set_state(unit::STATE_SLOWED, false);
    EoHS.set_subtag_attribute(unit, "status.petrified", false) -- new_unit.set_state(unit::STATE_PETRIFIED, false);
                                                               -- new_unit.set_user_end_turn(false);
    EoHS.set_subtag_attribute(unit, "status.uncovered", true ) -- new_unit.set_hidden(false);
                                                               -- return new_unit; }
  end,
  
  advance_unit_on_map = function(x, y, advance_to, animate, fire_event)
    EoHS.assert(EoHS.location_is_on_the_map(x,y,true), "EoHS.game_action_simulations.advance_unit_on_map with off-map unit")
    local unit = EoHS.get_unit(x, y)
    EoHS.assert(unit, "EoHS.game_action_simulations.advance_unit_on_map no unit")
    EoHS.assert(unit.experience >= unit.max_experience, "EoHS.game_action_simulations.advance_unit_on_map with unit that shouldn't advance")
    
    if animate then
      wesnoth.fire("animate_unit", {
        { "filter", { x=x, y=y }},
        flag="levelout"
      })
    end
    
    if fire_event then
      local original_type = unit.type
      EoHS.fire_event("advance", x, y)
      -- Note: In 1.10.7 there appears to be a bug where AMLA (and only AMLA) overwrites the results of an advance event.
      -- I have no desire to faithfully replicate this bug, since no scenario should rightly rely on it.
      unit = EoHS.get_unit(x, y)
      if not (unit and (unit.experience >= unit.max_experience) and (unit.type == original_type)) then return end
    end
    
    EoHS.game_action_simulations.advance_unit_internal(unit, advance_to)
    EoHS.put_unit(unit)
    
    if fire_event then
      EoHS.fire_event("post_advance", x, y)
      unit = EoHS.get_unit(x, y)
      if not unit then return end
    end
    
    if animate then
      wesnoth.fire("animate_unit", {
        { "filter", { x=x, y=y }},
        flag="levelin"
      })
    end
  end,
  
  attack_matches_filter = function(attack, filter)
    if not attack then return false end
    -- TODO 1.11: special
    if filter.name   and (attack.name   ~= filter.name  ) then return false end
    if filter.type   and (attack.type   ~= filter.type  ) then return false end
    if filter.range  and (attack.range  ~= filter.range ) then return false end
    if filter.damage and (attack.damage ~= filter.damage) then return false end
    return true
  end,
  
  special_active = function(combatant, special)
    if (combatant.role == "attacker") and (special.active_on == "defense") then return false end
    if (combatant.role == "defender") and (special.active_on == "offense") then return false end
    local filter_combatant = function(c, fname)
      local filter = EoHS.get_subtag(special, fname)
      if filter then
        if not wesnoth.match_unit(c.wunit, filter) then return false end
        local filter_weapon = EoHS.get_subtag(filter, "filter_weapon")
        if filter_weapon and not EoHS.game_action_simulations.attack_matches_filter(c.attack, filter_weapon) then return false end
      end
      return true
    end
    if not filter_combatant(combatant         , "filter_self"    ) then return false end
    if not filter_combatant(combatant.opponent, "filter_opponent") then return false end
    local attacker = (combatant.role == "attacker") and combatant or combatant.opponent
    if not filter_combatant(attacker          , "filter_attacker") then return false end
    local defender = (combatant.role == "defender") and combatant or combatant.opponent
    if not filter_combatant(defender          , "filter_defender") then return false end
    
    for filter_adjacent in helper.child_range(special, "filter_adjacent") do
      for dir in EoHS.comma_separated_values(filter_adjacent.adjacent) do
        local adj_wunit = wesnoth.get_unit(EoHS.get_loc_in_direction(combatant.x, combatant.y, dir))
        if not adj_wunit then return false end
        if not wesnoth.match_unit(adj_wunit, filter_adjacent) then return false end
      end
    end
    for filter_adjacent_location in helper.child_range(special, "filter_adjacent_location") do
      for dir in EoHS.comma_separated_values(filter_adjacent_location.adjacent) do
        if not wesnoth.match_location(EoHS.get_loc_in_direction(combatant.x, combatant.y, dir), filter_adjacent_location) then return false end
      end
    end

    return true
  end,
  
  special_affects_self = function(combatant, special)
    local a = special.apply_to or "self"
    return (a == "self") or (a == "both") or (a == combatant.role)
  end,
  special_affects_opponent = function(combatant, special)
    local a = special.apply_to or "self"
    return (a == "opponent") or (a == "both") or (a == combatant.opponent.role)
  end,
  
  ability_active = function(wunit, ability)
    local filter = EoHS.get_subtag(ability, "filter")
    if filter and not wesnoth.match_unit(wunit, filter) then return false end
    
    -- Replicating undocumented behavior of filter_adjacent and filter_adjacent_location
    -- working as in weapon specials. TODO ask devs and document on wiki
    for filter_adjacent in helper.child_range(ability, "filter_adjacent") do
      for dir in EoHS.comma_separated_values(filter_adjacent.adjacent) do
        local adj_wunit = wesnoth.get_unit(EoHS.get_loc_in_direction(wunit.x, wunit.y, dir))
        if not adj_wunit then return false end
        if not wesnoth.match_unit(adj_wunit, filter_adjacent) then return false end
      end
    end
    for filter_adjacent_location in helper.child_range(ability, "filter_adjacent_location") do
      for dir in EoHS.comma_separated_values(filter_adjacent_location.adjacent) do
        if not wesnoth.match_location(EoHS.get_loc_in_direction(wunit.x, wunit.y, dir), filter_adjacent_location) then return false end
      end
    end

    return true
  end,
  
  ability_affects_adjacent = function(wunit, able_unit, ability)
    if not ability[wesnoth.is_enemy(wunit.side, able_unit.side) and "affect_enemies" or "affect_allies"] then return false end
    for affect_adjacent in helper.child_range(ability, "affect_adjacent") do
      for dir in EoHS.comma_separated_values(affect_adjacent.adjacent) do
        local x,y = wesnoth.get_unit(EoHS.get_loc_in_direction(able_unit.x, able_unit.y, dir))
        if (x==wunit.x) and (y==wunit.y) then
          local filter = EoHS.get_subtag(affect_adjacent, "filter")
          if (not filter) or wesnoth.match_unit(wunit, filter) then return true end
        end
      end
    end

    return false
  end,

  ability_affects_self = function(wunit, ability)
    if not ability.affect_self then return false end
    local filter = EoHS.get_subtag(ability, "filter_self")
    if (not filter) or wesnoth.match_unit(wunit, filter) then return true end
    return false
  end,

  abilities_affecting_unit_wunit = function(unit, wunit)
    local result = {}
    local abilities = EoHS.get_subtag(unit, "abilities")
    if abilities then for i,ability in ipairs(abilities) do
      if EoHS.game_action_simulations.ability_active(wunit, ability[2]) and EoHS.game_action_simulations.ability_affects_self(wunit, ability[2]) then
        table.insert(result, ability)
      end
    end end
    for x,y in helper.adjacent_tiles(unit.x,unit.y) do
      local aunit = EoHS.get_unit(x,y)
      if aunit then
        local awunit = wesnoth.get_unit(x,y)
        local aabilities = EoHS.get_subtag(aunit, "abilities")
        if aabilities then for i,ability in ipairs(aabilities) do
          if EoHS.game_action_simulations.ability_active(awunit, ability[2]) and EoHS.game_action_simulations.ability_affects_adjacent(wunit, aunit, ability[2]) then
            table.insert(result, ability)
          end
        end end
      end
    end
    return result
  end,
  
  unit_wunit_is_hidden = function(unit, wunit, viewing_side)
    if viewing_side and not wesnoth.is_enemy(unit.side, viewing_side) then return false end
    if EoHS.get_subtag_attribute(unit, "status.uncovered") then return false end
    for x,y in helper.adjacent_tiles(unit.x,unit.y) do
      local aunit = EoHS.get_unit(x,y)
      if aunit and wesnoth.is_enemy(unit.side, aunit.side) then return false end
    end
    for i,ability in ipairs(EoHS.game_action_simulations.abilities_affecting_unit_wunit(unit, wunit)) do
      if ability[1] == "hides" then return true end
    end
    return false
  end,
  
  backstab_check = function(a,d)
    local ox,oy = EoHS.same_relative_location(d.x,d.y,a.x,a.y,d.x,d.y)
    local o = wesnoth.get_unit(ox,oy)
    if o and wesnoth.is_enemy(d.side, o.side) then return true end
    return false
  end,
  
  fleshed_out_attack_context = function(attack_context, options)
    -- TODO evaluate best copying rules
    -- local result = {attacker=EoHS.shallow_copy(attack_context.attacker),defender=EoHS.shallow_copy(attack_context.defender)}
    local result = EoHS.deep_copy(attack_context)
    
    result.attacker.role = "attacker"
    result.defender.role = "defender"
    result.attacker.opponent = result.defender
    result.defender.opponent = result.attacker
    result[1] = result.attacker
    result[2] = result.defender
    for i,combatant in ipairs(result) do
      if combatant.unit then
        combatant.x = combatant.unit.x
        combatant.y = combatant.unit.y
      end
      local map_unit = EoHS.get_unit(combatant.x, combatant.y)
      if not combatant.unit then
        combatant.unit = map_unit
      end
      if not combatant.unit then
        return nil
      end
      if EoHS.get_subtag_attribute(combatant.unit, "status.petrified") then return nil end
      combatant.on_map = map_unit and (map_unit.underlying_id == combatant.unit.underlying_id)
      combatant.wunit = EoHS.create_wunit(combatant.unit)
      combatant.not_living = EoHS.get_subtag_attribute(combatant.unit, "status.not_living")
      if not combatant.terrain      then combatant.terrain = wesnoth.get_terrain(combatant.unit.x, combatant.unit.y) end
      if not combatant.lawful_bonus then combatant.lawful_bonus = EoHS.get_time_of_day(combatant.x, combatant.y).lawful_bonus end
      if combatant.attack and not (combatant.attack.damage and combatant.attack.number) then combatant.attack = nil end
      if combatant.weapon_index_zero_based == "choose" then
      -- Can I replicate the complex rules about choosing defender weapons?
      -- You know what, I just don't care.
        local attack_counter = 0
        local choice
        local best_goodness
        for i,attack in ipairs(EoHS.get_subtags(combatant.unit, "attack")) do
          -- Hack - assume only defender can be "choose" and that the attacker's stuff has already been found
          if (attack.range == combatant.opponent.attack.range) and ((attack.defense_weight or 1) > 0) then
            local goodness
            if combatant.on_map then
              local att_stats,def_stats = wesnoth.simulate_combat(combatant.opponent.wunit, combatant.opponent.weapon_index_zero_based+1, combatant.wunit, attack_counter+1)
              goodness = (
                (att_stats.hp_chance[0] - def_stats.hp_chance[0])*100*(combatant.unit.max_hitpoints+combatant.opponent.unit.max_hitpoints)
                + (att_stats.poisoned*wesnoth.game_config.poison_amount-att_stats.average_hp)
                - (def_stats.poisoned*wesnoth.game_config.poison_amount-def_stats.average_hp)
                )
            else
              -- TODO: Any problem if we temporarily put it on the map so the behavior is the same?
              local try_attack_context = EoHS.deep_copy(attack_context)
              try_attack_context.defender.weapon_index_zero_based = attack_counter
              try_attack_context = EoHS.game_action_simulations.fleshed_out_attack_context(try_attack_context)
              goodness = ((try_attack_context.defender.attacks * try_attack_context.defender.attacks * try_attack_context.defender.damage) +
                (try_attack_context.defender.slows   and (not EoHS.get_subtag_attribute(combatant.opponent.unit, "status.slowed"  )) and 20 or 0) + 
                (try_attack_context.defender.poisons and (not EoHS.get_subtag_attribute(combatant.opponent.unit, "status.poisoned")) and 8 or 0))
            end
            if (not choice) or (goodness > best_goodness) then
              choice = attack_counter
              best_goodness = goodness
            end
          end
          attack_counter = attack_counter + 1
        end
        combatant.weapon_index_zero_based = choice
      end
      if type(combatant.weapon_index_zero_based) == "number" then
        local attack_counter = combatant.weapon_index_zero_based
        for i,attack in ipairs(EoHS.get_subtags(combatant.unit, "attack")) do
          attack_counter = attack_counter - 1
          if attack_counter < 0 then
            combatant.attack = attack
            break
          end
        end
      end
      if combatant.attack then
        combatant.all_owned_specials = EoHS.get_subtag(combatant.attack, "specials")
        if type(combatant.weapon_index_zero_based) ~= "number" then
          local attack_counter = 0
          for i,attack in ipairs(EoHS.get_subtags(combatant.unit, "attack")) do
            if attack.name == combatant.attack.name then
              combatant.weapon_index_zero_based = attack_counter
              break
            end
            attack_counter = attack_counter + 1
          end
        end
      end
      if (combatant.role == "attacker") and not combatant.attack then
        return nil
      end
    end
    for i,combatant in ipairs(result) do
      if combatant.attack then
        combatant.active_specials = {}
        combatant.backstab = (combatant.role == "attacker") and EoHS.game_action_simulations.backstab_check(combatant.unit, combatant.opponent.unit)
        local special_infos = { attacks = {def=combatant.attack.number}, damage = {def=combatant.attack.damage}, chance_to_hit = {def=wesnoth.unit_defense(combatant.opponent.wunit, combatant.opponent.terrain)} }
        local handle_special = function(special)
          table.insert(combatant.active_specials, special)
          local info = special_infos[special[1]]
          if not info then info = {}; special_infos[special[1]] = info end
          if not info.add then info.add=0 end
          if not info.multiply then info.multiply=1 end
                       -- if (!backstab && cfg["backstab"].to_bool()) continue; -- TODO just include backstab in the activity checks
                --  if (!filter_base_matches(cfg, def)) continue; -- TODO
          if special[2].value then -- if (const config::attribute_value *v = cfg.get("value")) { int value = *v; bool cumulative = cfg["cumulative"].to_bool();
            if (not info.value_set) and not special[2].cumulative then         -- if (!value_is_set && !cumulative) {
              info.value_set = special[2].value -- value_set = value; set_effect.set(SET, value, i->first, i->second);
            else            -- } else {
              if special[2].cumulative then info.value_set = math.max(info.value_set or info.def, info.def) end  -- if (cumulative) value_set = std::max<int>(value_set, def);
              if special[2].value > info.value_set then info.value_set = special[2].value end          --if (value > value_set) { value_set = value; set_effect.set(SET, value, i->first, i->second); }
            end        -- } value_is_set = true;
          end -- }
          if special[2].add then
            info.add = info.add + special[2].add
          end
          if special[2].sub then
            info.add = info.add - special[2].sub
          end
          if special[2].multiply then
            info.multiply = info.multiply * special[2].multiply
          end
          if special[2].divide then
            info.multiply = info.multiply / special[2].divide
          end
          if special[2].swarm_attacks_min then info.swarm_attacks_min = math.max(info.swarm_attacks_min or -math.huge, special[2].swarm_attacks_min) end
          if special[2].swarm_attacks_max then info.swarm_attacks_max = math.max(info.swarm_attacks_max or -math.huge, special[2].swarm_attacks_max) end
        end
        if combatant.         all_owned_specials then for i,special in ipairs(combatant.         all_owned_specials) do
          if EoHS.game_action_simulations.special_active          (combatant, special[2])          and
             EoHS.game_action_simulations.special_affects_self    (combatant, special[2])          then handle_special(special) end
        end end
        if combatant.opponent.all_owned_specials then for i,special in ipairs(combatant.opponent.all_owned_specials) do
          if EoHS.game_action_simulations.special_active          (combatant.opponent, special[2]) and
             EoHS.game_action_simulations.special_affects_opponent(combatant.opponent, special[2]) then handle_special(special) end
        end end
        combatant.slows        = special_infos.slow        and true or false
        combatant.petrifies    = special_infos.petrifies   and true or false
        combatant.firststrike  = special_infos.firststrike and true or false
        combatant.drains       = special_infos.drains      and (not combatant.opponent.not_living) or false
        combatant.poisons      = special_infos.poisons     and (not combatant.opponent.not_living) or false
        combatant.rounds       = (special_infos.berserk and special_infos.berserk.value_set) or 1
        
        -- Why do specials round down, given that alignment, resistances, and leadership round to nearest-favoring-original-value?
        local special_value = function(name) return math.floor(((special_infos[name].value_set or special_infos[name].def) + (special_infos[name].add or 0)) * (special_infos[name].multiply or 1)) end
        combatant.base_damage   = special_value("damage")
        combatant.chance_to_hit = special_value("chance_to_hit")
        if special_infos.swarm then
          combatant.attacks = math.floor(special_infos.swarm.swarm_attacks_min + (special_infos.swarm.swarm_attacks_max - special_infos.swarm.swarm_attacks_min) * combatant.unit.hitpoints / combatant.unit.max_hitpoints)
        else
          combatant.attacks = special_value("attacks")
        end
        
                -- // Get the damage multiplier applied to the base damage of the weapon.
        local damage_multiplier = 100        -- int damage_multiplier = 100;

        local tod_bonus = 0 -- // Time of day bonus.
        if combatant.unit.alignment == "chaotic" then tod_bonus = -combatant.lawful_bonus end
        if combatant.unit.alignment == "lawful"  then tod_bonus =  combatant.lawful_bonus end
        if combatant.unit.alignment == "liminal" then tod_bonus = -math.abs(combatant.lawful_bonus) end
        if tod_bonus < 0 and EoHS.is_fearless(combatant.unit) then tod_bonus = 0 end
        damage_multiplier = damage_multiplier + tod_bonus      -- damage_multiplier += combat_modifier(u_loc, u.alignment(), u.is_fearless());

                -- // Leadership bonus.
        local leader_bonus -- int leader_bonus = 0;
        for i,leadership_ability in ipairs(EoHS.get_subtags(EoHS.game_action_simulations.abilities_affecting_unit_wunit(combatant.unit, combatant.wunit), "leadership")) do -- if (under_leadership(units, pu_loc, &leader_bonus).valid())
          if (not leader_bonus) or (leadership_ability.value > leader_bonus) then leader_bonus = leadership_ability.value end
        end
        if leader_bonus then damage_multiplier = damage_multiplier + leader_bonus end --         damage_multiplier += leader_bonus;
               
                -- // Resistance modifier.
        damage_multiplier = math.floor(damage_multiplier * wesnoth.unit_resistance(combatant.opponent.wunit, combatant.attack.type, (combatant.role ~= "attacker"), combatant.opponent.x, combatant.opponent.y)) -- damage_multiplier *= opp.damage_from(*weapon, !attacking, opp_loc);

        local round_damage = function(base,mult,div)
          local unrounded = base * mult / div
          if unrounded < base then return math.max(1, math.floor(unrounded + 0.5))
          else                     return math.max(1, math.ceil (unrounded - 0.5)) end
        end
                -- // Compute both the normal and slowed damage. For the record,
                -- // drain = normal damage / 2 and slow_drain = slow_damage / 2.
        combatant.damage      = round_damage(combatant.base_damage, damage_multiplier, 10000) -- damage = round_damage(base_damage, damage_multiplier, 10000);
        combatant.slow_damage = round_damage(combatant.base_damage, damage_multiplier, 20000) -- slow_damage = round_damage(base_damage, damage_multiplier, 20000);
        combatant.slowed = EoHS.get_subtag_attribute(combatant.unit, "status.slowed")
        if combatant.slowed then combatant.damage = combatant.slow_damage end -- if (is_slowed) damage = slow_damage;
        combatant.next_drains_damage = math.min(math.floor(combatant.damage / 2), combatant.unit.max_hitpoints - combatant.unit.hitpoints, math.floor(combatant.opponent.unit.hitpoints / 2))
      end
    end
    return result
  end,

  --void attack_unit(const map_location &attacker, const map_location &defender,
  --        int attack_with, int defend_with, bool update_display)
  --{
  attack_unit = function(attack_context, extras)
    --attack dummy(attacker, defender, attack_with, defend_with, update_display);
    --attack::attack(const map_location &attacker, const map_location &defender,
    --            int attack_with,
    --            int defend_with,
    --            bool update_display) :
    --    bc_(0),
    --    a_stats_(0),
    --    d_stats_(0),
    --    abs_n_attack_(0),
    --    abs_n_defend_(0),
    --    update_att_fog_(false),
    --    update_def_fog_(false),
    --    update_minimap_(false),
    --    a_(attacker, attack_with, *resources::units),
    --    d_(defender, defend_with, *resources::units),
    --    units_(*resources::units),
    --    errbuf_(),
    --    update_display_(update_display),
    --    OOS_error_(false)
    --{
    --}
    --dummy.perform();
    --void attack::perform()
    --{
    --// Stop the user from issuing any commands while the units are fighting
    --const events::command_disabler disable_commands;

    --if(!a_.valid() || !d_.valid()) {
    --        return;
    --}
    local animate = not (extras and (extras.animate == false))
    local fleshed_out_attack_context
    local a,d = {},{}
    a.s = attack_context.attacker
    d.s = attack_context.defender
    local valid = true
    local load_ac = function()
      if extras and extras.update_context_func then extras.update_context_func() end
      local next_context = EoHS.game_action_simulations.fleshed_out_attack_context(attack_context)
      if next_context and ((not a.f) or
             ((next_context.attacker.x == a.f.x) and (next_context.attacker.y == a.f.y) and (next_context.attacker.unit.underlying_id == a.f.unit.underlying_id)
          and (next_context.defender.x == d.f.x) and (next_context.defender.y == d.f.y) and (next_context.defender.unit.underlying_id == d.f.unit.underlying_id))) then
        fleshed_out_attack_context = next_context
        a.f = fleshed_out_attack_context.attacker
        d.f = fleshed_out_attack_context.defender
        a.unit = a.s.unit or a.f.unit
        d.unit = d.s.unit or d.f.unit
      else
        valid = false
        a.unit = a.s.unit or EoHS.get_unit(a.s.x, a.s.y)
        d.unit = d.s.unit or EoHS.get_unit(d.s.x, d.s.y)
      end
    end
    local fired_attack_end = false
    local fire_event = function(name)
      if name == "attack_end" then
        if fired_attack_end then EoHS.err("Firing attack end twice"); return end
        fired_attack_end = true
      end
      EoHS.fire_event(name, a.unit.x, a.unit.y, d.unit.x, d.unit.y, a.f.attack, d.f.attack)
      load_ac()
    end
    local do_animation = function(h, v, name)
      if animate then
        wesnoth.fire("animate_unit", {
          flag = name,
          with_bars = true,
          { "filter", { x=h.unit.x, y=h.unit.y, }},
          { "primary_attack", { name = h.f.attack.name }},
        })
      end
    end
    local put = function(c) if c.f.on_map then EoHS.put_unit(c.unit) end end
    load_ac()
    if (not a.unit) or (not d.unit) then return end

    --// no attack weapon => stop here and don't attack
    if a.f.weapon_index_zero_based < 0 then --if (a_.weapon_ < 0) {
      if not (extras and (extras.spend_moves_and_attacks == false)) then
        a.unit.attacks_left = a.unit.attacks_left - 1 --a_.get_unit().set_attacks(a_.get_unit().attacks_left()-1);
        a.unit.moves = 0 --a_.get_unit().set_movement(-1);
      end
      return --return;
    end --}

    EoHS.assert(a.f.attack, "EoHS.game_action_simulations.attack_unit An invalid attacker weapon got selected.")
    if not (extras and (extras.spend_moves_and_attacks == false)) then
      a.unit.attacks_left = a.unit.attacks_left - 1 --a_.get_unit().set_attacks(a_.get_unit().attacks_left()-1);
      --VALIDATE(a_.weapon_ < static_cast<int>(a_.get_unit().attacks().size()),
      --        _("An invalid attacker weapon got selected."));
      --a_.get_unit().set_movement(a_.get_unit().movement_left() -
      --        a_.get_unit().attacks()[a_.weapon_].movement_used());
      a.unit.moves = a.unit.moves - (a.f.attack.movement_used or 100000) -- accurate to hard-coded value in unit_types.hpp:62 (1.10.7)
      --a_.get_unit().set_state(unit::STATE_NOT_MOVED,false);
    end
    a.unit.resting = false --a_.get_unit().set_resting(false);
    d.unit.resting = false --d_.get_unit().set_resting(false);

    --// If the attacker was invisible, she isn't anymore!
    EoHS.set_subtag_attribute(a.unit, "status.uncovered", true) --a_.get_unit().set_state(unit::STATE_UNCOVERED, true);

    put(a); put(d)
    fire_event("attack")
    if not valid then fire_event("attack_end"); return end
      
    local defender_strikes_first = d.f.firststrike and not a.f.firststrike
    local extra_rounds = math.max(a.f.rounds, d.f.rounds or 1) - 1;
    do_animation(a, d, "draw_weapon")

    --bc_ = new battle_context(units_, a_.loc_, d_.loc_, a_.weapon_, d_.weapon_);
    --a_stats_ = &bc_->get_attacker_stats();
    --d_stats_ = &bc_->get_defender_stats();
    --if(a_stats_->weapon) {
    --        a_.weap_id_ = a_stats_->weapon->id();
    --}
    --if(d_stats_->weapon) {
    --        d_.weap_id_ = d_stats_->weapon->id();
    --}

    --try {
    --        fire_event("attack");
    --} catch (attack_end_exception) {
    --        return;
    --}
    --refresh_bc();

    --DBG_NG << "getting attack statistics\n";
    --statistics::attack_context attack_stats(a_.get_unit(), d_.get_unit(), a_stats_->chance_to_hit, d_stats_->chance_to_hit);

    --[[{
            // Calculate stats for battle
            combatant attacker(bc_->get_attacker_stats());
            combatant defender(bc_->get_defender_stats());
            attacker.fight(defender,false);
            const double attacker_inflict = static_cast<double>(d_.get_unit().hitpoints()) - defender.average_hp();
            const double defender_inflict = static_cast<double>(a_.get_unit().hitpoints()) - attacker.average_hp();

            attack_stats.attack_expected_damage(attacker_inflict,defender_inflict);
    }

    a_.orig_attacks_ = a_stats_->num_blows;
    d_.orig_attacks_ = d_stats_->num_blows;
    a_.n_attacks_ = a_.orig_attacks_;
    d_.n_attacks_ = d_.orig_attacks_;
    a_.xp_ = d_.get_unit().level();
    d_.xp_ = a_.get_unit().level();

    bool defender_strikes_first = (d_stats_->firststrike && !a_stats_->firststrike);
    unsigned int rounds = std::max<unsigned int>(a_stats_->rounds, d_stats_->rounds) - 1;
    const int attacker_side = a_.get_unit().side();
    const int defender_side = d_.get_unit().side();

    static const std::string poison_string("poison");

    LOG_NG << "Fight: (" << a_.loc_ << ") vs (" << d_.loc_ << ") ATT: " << a_stats_->weapon->name() << " " << a_stats_->damage << "-" << a_stats_->num_blows << "(" << a_stats_->chance_to_hit << "%) vs DEF: " << (d_stats_->weapon ? d_stats_->weapon->name() : "none") << " " << d_stats_->damage << "-" << d_stats_->num_blows << "(" << d_stats_->chance_to_hit << "%)" << (defender_strikes_first ? " defender first-strike" : "") << "\n";

    // Play the pre-fight animation
    unit_display::unit_draw_weapon(a_.loc_,a_.get_unit(),a_stats_->weapon,d_stats_->weapon,d_.loc_,&d_.get_unit());]]
    
    local perform_hit = function(h, v)
      local hits = EoHS.random("0..99") < h.f.chance_to_hit
      if hits then
        wesnoth.set_variable("damage_inflicted", h.f.damage)
      end
      
      if animate then
        -- TODO proper textdomain
        if hits and h.f.poisons and not EoHS.get_subtag_attribute(v.unit, "status.poisoned") then
          wesnoth.float_label(v.unit.x, v.unit.y, '<span color="#ff0000">'..(v.unit.gender=="female" and _"female^poisoned" or _"poisoned")..'</span>')
        end
        if hits and h.f.slows   and not EoHS.get_subtag_attribute(v.unit, "status.slowed"  ) then
          wesnoth.float_label(v.unit.x, v.unit.y, '<span color="#ff0000">'..(v.unit.gender=="female" and _"female^slowed"   or _"slowed"  )..'</span>')
        end
        if hits and h.f.petrifies then
          wesnoth.float_label(v.unit.x, v.unit.y, '<span color="#ff0000">'..(v.unit.gender=="female" and _"female^petrified" or _"petrified")..'</span>')
        end
        -- TODO proper handling for attacks the unit doesn't have - which won't match the filter
        local anim_hits = hits and ((h.f.damage >= v.unit.hitpoints) and "kill" or "hit") or "miss"
        EoHS.face_towards(h.unit, v.unit.x, v.unit.y)
        EoHS.face_towards(v.unit, h.unit.x, h.unit.y) -- These are different behavior than canon, but I like them better
        if h.f.on_map then EoHS.set_unit_attribute_immediate(h.unit, "facing", h.unit.facing) end
        if v.f.on_map then EoHS.set_unit_attribute_immediate(v.unit, "facing", v.unit.facing) end
        wesnoth.fire("animate_unit", {
          flag="attack",
          {"filter",{x=h.unit.x,y=h.unit.y}},
          {"primary_attack",{name=h.f.attack.name}},
          {"secondary_attack",{name=v.f.attack and v.f.attack.name}},
          hits = anim_hits,
          with_bars = true,
          text = hits and h.f.drains and h.f.next_drains_damage or nil,
          red=0,green=255,blue=0,
          {"animate",{
            flag="defend",
            {"filter",{x=v.unit.x,y=v.unit.y}},
            {"primary_attack",{name=h.f.attack.name}},
            {"secondary_attack",{name=v.f.attack and v.f.attack.name}},
            hits = anim_hits,
            text = hits and h.f.damage or nil,
            red=255,green=0,blue=0,
            with_bars = true,
          }}
        })
      end

      -- I have NO idea why this is computed before events and applied after events,
      -- but it's not difficult for me to be faithful to that behavior, so I guess I will.
      local drains_damage = 0
      if h.f.drains then
              -- // don't drain so much that the attacker gets more than his maximum hitpoints
              -- drains_damage = std::min<int>(damage / 2, attacker.get_unit().max_hitpoints() - attacker.get_unit().hitpoints());
              -- // don't drain more than the defenders remaining hitpoints
              -- drains_damage = std::min<int>(drains_damage, defender.get_unit().hitpoints() / 2);
        drains_damage = math.min(math.floor(h.f.damage / 2), h.unit.max_hitpoints - h.unit.hitpoints, math.floor(v.unit.hitpoints / 2))
      end

      if hits then v.unit.hitpoints = v.unit.hitpoints - h.f.damage end
      local dies = v.unit.hitpoints <= 0
      put(v) -- TODO use _immediate functions in this code

      fire_event(h.f.role..(hits and "_hits" or "_misses"))
      if not valid then fire_event("attack_end"); return end

      if drains_damage > 0 then
        h.unit.hitpoints = h.unit.hitpoints + drains_damage
      end
      
      if dies then
        h.xp_gained = EoHS.kill_experience(v.unit.level)
        v.xp_gained = 0
        local undead_variation = v.unit.undead_variation
        fire_event("attack_end")
        load_ac()
        if not valid then return end
        fire_event("last_breath")
        load_ac()
        if not valid then return end
        if v.unit.hitpoints > 0 then return end
        wesnoth.fire("animate_unit", {
          flag="death",
          {"filter",{x=v.unit.x,y=v.unit.y}},
          {"primary_attack",{name=h.f.attack.name}},
          {"secondary_attack",{name=v.f.attack and v.f.attack.name}},
          with_bars = false,
        })
        fire_event("die")
        load_ac()
        if not valid then return end
        if v.unit.hitpoints > 0 then return end
        if v.f.on_map then
          EoHS.remove_unit(v.unit.x,v.unit.y)
          v.unit = nil
          -- TODO plague
          --[[    if (attacker.valid() && attacker_stats->plagues)
              {
                      // plague units make new units on the target hex
                      LOG_NG << "trying to reanimate " << attacker_stats->plague_type << '\n';
                      const unit_type *reanimator =
                              unit_types.find(attacker_stats->plague_type);
                      if (reanimator)
                      {
                              LOG_NG << "found unit type:" << reanimator->id() << '\n';
                              unit newunit(reanimator, attacker.get_unit().side(),
                                      true, unit_race::MALE);
                              newunit.set_attacks(0);
                              newunit.set_movement(0);
                              // Apply variation
                              if (undead_variation != "null")
                              {
                                      config mod;
                                      config &variation = mod.add_child("effect");
                                      variation["apply_to"] = "variation";
                                      variation["name"] = undead_variation;
                                      newunit.add_modification("variation",mod);
                                      newunit.heal_all();
                              }
                              units_.add(death_loc, newunit);
                              preferences::encountered_units().insert(newunit.type_id());
                              if (update_display_) {
                                      resources::screen->invalidate(death_loc);
                              }
                      }
              }]]
        end
        return
      end

      if hits then
        if h.f.poisons then EoHS.set_subtag_attribute(v.unit, "status.poisoned", true); put(v) end
        if h.f.slows   then EoHS.set_subtag_attribute(v.unit, "status.slowed"  , true); put(v) end
        if h.f.petrifies then
          EoHS.set_subtag_attribute(v, "status.petrified", true); put(v)
          fire_event("petrified")
          return false
        end
      end
      
      return true
    end
    
    local a_orig_attacks = a.f.attacks
    local d_orig_attacks = d.f.attacks or 0
    local a_n_attacks = a_orig_attacks
    local d_n_attacks = d_orig_attacks
    a.xp_gained = d.unit.level
    d.xp_gained = a.unit.level
    while true do -- for (;;) {
            -- DBG_NG << "start of attack loop...\n";
           -- ++abs_n_attack_;

      if (a_n_attacks > 0) and not defender_strikes_first then      -- if (a_.n_attacks_ > 0 && !defender_strikes_first) {
        if not perform_hit(a,d) then break end    --         if (!perform_hit(true, attack_stats)) break;
        a_n_attacks = a_n_attacks - 1
      end      -- }
      if not valid then break end

            -- // If the defender got to strike first, they use it up here.
      defender_strikes_first = false      -- defender_strikes_first = false;
            -- ++abs_n_defend_;
      if d_n_attacks > 0 then      -- if (d_.n_attacks_ > 0) {
        if not perform_hit(d,a) then break end    --         if (!perform_hit(false, attack_stats)) break;
        d_n_attacks = d_n_attacks - 1
      end      -- }
      if not valid then break end

            -- // Continue the fight to death; if one of the units got petrified,
            -- // either n_attacks or n_defends is -1
      if (extra_rounds > 0) then     -- if(rounds > 0 && d_.n_attacks_ == 0 && a_.n_attacks_ == 0) {
        a_n_attacks = a_orig_attacks    --         a_.n_attacks_ = a_.orig_attacks_;
        d_n_attacks = d_orig_attacks    --         d_.n_attacks_ = d_.orig_attacks_;
        extra_rounds = extra_rounds - 1    --         --rounds;
        defender_strikes_first = d.f.firststrike and not a.f.firststrike    --         defender_strikes_first = (d_stats_->firststrike && ! a_stats_->firststrike);
      end      -- }

      if (a_n_attacks <= 0) and (d_n_attacks <= 0) then    -- if (a_.n_attacks_ <= 0 && d_.n_attacks_ <= 0) {
        fire_event("attack_end")
        break    --         fire_event("attack_end");
      end      --         refresh_bc();
            --         break;
            -- }
    end -- }

    if a.unit then
      a.unit.experience = a.unit.experience + a.xp_gained
      put(a)
    end
    if d.unit then
      d.unit.experience = d.unit.experience + d.xp_gained
      put(d)
    end
    do_animation(a, d, "sheath_weapon")
    --[[// TODO: if we knew the viewing team, we could skip some of these display update
    if (update_att_fog_ && (*resources::teams)[attacker_side - 1].uses_fog())
    {
            recalculate_fog(attacker_side);
            if (update_display_) {
                    resources::screen->invalidate_all();
                    resources::screen->recalculate_minimap();
            }
    }
    if (update_def_fog_ && (*resources::teams)[defender_side - 1].uses_fog())
    {
            recalculate_fog(defender_side);
            if (update_display_) {
                    resources::screen->invalidate_all();
                    resources::screen->recalculate_minimap();
            }
    }

    if (update_minimap_ && update_display_) {
            resources::screen->recalculate_minimap();
    }

    if (a_.valid()) {
            unit &u = a_.get_unit();
            u.set_standing();
            u.set_experience(u.experience() + a_.xp_);
    }

    if (d_.valid()) {
            unit &u = d_.get_unit();
            u.set_standing();
            u.set_experience(u.experience() + d_.xp_);
    }

    unit_display::unit_sheath_weapon(a_.loc_,a_.valid()?&a_.get_unit():NULL,a_stats_->weapon,
                    d_stats_->weapon,d_.loc_,d_.valid()?&d_.get_unit():NULL);

    if (update_display_){
            resources::screen->invalidate_unit();
            resources::screen->invalidate(a_.loc_);
            resources::screen->invalidate(d_.loc_);
            resources::screen->draw(true, true);
    }

    if(OOS_error_) {
            replay::process_error(errbuf_.str());
    }
}
]]
  --}
  end,
}

-->>)}
