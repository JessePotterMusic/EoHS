{EOHS_LUA_FILE (<<-- persistence.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery

local get_persistent_variable__stored = function(side, name)
  return EoHS.get_side_variable(side, "persistent_variables."..name)
end

local set_persistent_variable__stored = function(side, name, value)
  EoHS.set_side_variable(side, "persistent_variables."..name, value)
end

local get_persistent_variable__network = function(side, name)
  EoHS.err(debug.traceback())
  if not EoHS.synchronized then EoHS.err("get_persistent_variable__network used in an unsynchronized context") end
  wesnoth.fire("get_global_variable", {
     namespace = "EoHS_Era_of_High_Sorcery",
     from_global = name,
     to_local = "EoHS.LUA_TEMP",
     side = side })
  local result = wesnoth.get_variable("EoHS.LUA_TEMP")
  wesnoth.set_variable("EoHS.LUA_TEMP")
  EoHS.err("safe!")
  return result
end

local set_persistent_variable__network = function(side, name, value, allow_unsafe)
  if not (EoHS.synchronized or allow_unsafe) then EoHS.err("set_persistent_variable__network used in an unsynchronized context") end
  
  if value == nil then
    wesnoth.fire("clear_global_variable", {
      namespace = "EoHS_Era_of_High_Sorcery",
      global = name,
      immediate = true,
      side = side })
  else
    wesnoth.set_variable("EoHS.LUA_TEMP", value)
    wesnoth.fire("set_global_variable", {
      namespace = "EoHS_Era_of_High_Sorcery",
      to_global = name,
      from_local = "EoHS.LUA_TEMP",
      immediate = true,
      side = side })
    wesnoth.set_variable("EoHS.LUA_TEMP")
  end
end

local function set_persistent_variable__both(side, name, value, allow_unsafe)
  if name ~= "attribute_list" then
    local old = get_persistent_variable__stored(side, name)
    if (old == nil) and (value ~= nil) then
      local new_list = (get_persistent_variable__stored(side, "attribute_list") or "")..","..name
      set_persistent_variable__both(side, "attribute_list", new_list, allow_unsafe)
    end
    if (old ~= nil) and (value == nil) then
      local new_list,repls = string.gsub(get_persistent_variable__stored(side, "attribute_list"), ","..EoHS.lua_pattern_escape(name), "")
      EoHS.assert(repls == 1, "Bad value of attribute_list")
      set_persistent_variable__both(side, "attribute_list", new_list, allow_unsafe)
    end
  end
  
  set_persistent_variable__network(side, name, value, allow_unsafe)
  set_persistent_variable__stored (side, name, value)
end

-- Note: I'm well aware of how insecure this is against a user who knows programming.
-- You could even make an add-on that automatically gives people supporter status.
--   By the way, please don't do that.
-- If I had wanted more security, I could have implemented public-key cryptography in
--   pure Lua, so that I was the only one who could issue codes that work for each nick -
--   but no matter what I do, people can be fake supporters when they *host* a game
--   just by changing the add-on code. Given that gap, I didn't feel that securing the
--   other side (cheating player with a legitimate host) was worth the effort.
local update_supporter_status = function(side)
  local found_supporter = false
  local units = EoHS.get_units({ side=side, EoHS.is_on_the_map, EoHS.has_unit_variable("is_wizard") })
  for i,unit in ipairs(units) do
    local modifications = EoHS.force_subtag(unit, "modifications")
    local trait,idx = helper.get_child(modifications, "trait", "EoHS_supporter")
    if (type(unit.name) == "string") and string.match(EoHS.get_persistent_variable(side, "supporter_passwords") or "", EoHS.sha1(unit.name)) then
      found_supporter = true
      if not trait then
        table.insert(modifications, 1, {"trait",{
          id = "EoHS_supporter",
          name = _"magnanimous",
          description = EoHS.substitute(_"$1| has generously donated to help Eli keep developing Era of High Sorcery. Visit www.elidupree.com/EoHS to donate.", {unit.name}),
        }})
        EoHS.put_unit(unit)
      end
    else
      if trait then
        table.remove(modifications, idx)
        EoHS.put_unit(unit)
      end
    end
  end
  EoHS.set_side_variable(side, "is_supporter", found_supporter)
end
EoHS.is_valid_supporter_password = function(side, password)
  local hash_to_match = EoHS.get_side_variable(side, "original_nick_hash")
  if hash_to_match and (hash_to_match == password) then
    return true
  end
  return false
end
EoHS.add_supporter_password = function(side, password)
  local password_list = EoHS.get_persistent_variable(side, "supporter_passwords") or ""
  password_list = password_list..password..","
  update_supporter_status(side)
end

local load_persistent_variables = function(side, original)
  local fetch = function(name)
    local value = get_persistent_variable__network(side, name)
    set_persistent_variable__stored(side, name, value)
    return value
  end
  local attribute_list = fetch("attribute_list")
  
  for key in EoHS.comma_separated_values(attribute_list) do
    fetch(key)
  end
  
  local identity = get_persistent_variable__stored(side, "identity")
  if not (identity and (string.len(identity) == string.len("0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33"))) then
    local uniqueness_source = EoHS.random("0..32767")..EoHS.random("0..32767")..EoHS.random("0..32767")..EoHS.random("0..32767")
    if type(nick) == "string" then uniqueness_source = uniqueness_source..nick end
    identity = EoHS.sha1(uniqueness_source)
    set_persistent_variable__both(side, "identity", identity)
  end
  if original then EoHS.set_side_variable(wesnoth.current.side, "original_identity", identity) end
  update_supporter_status(side)
end

local side_persistent_variables_are_up_to_date = function(side)
  local result = get_persistent_variable__network(side, "identity") == get_persistent_variable__stored(side, "identity")
  EoHS.err(EoHS.inspect(result))
  return result
end

EoHS.update_side_persistent_variables = function(side, original)
  if not side_persistent_variables_are_up_to_date(side) then
    load_persistent_variables(side)
  end
end

EoHS.update_all_persistent_variables = function(original)
  for side in ipairs(wesnoth.sides) do
    EoHS.update_side_persistent_variables(side, original)
  end
end

EoHS.get_persistent_variable = function(side, name)
  return get_persistent_variable__stored(side, name)
end

EoHS.set_persistent_variable = function(side, name, value)
  --EoHS.update_side_persistent_variables(side)
  if side_persistent_variables_are_up_to_date(side) then
    set_persistent_variable__both(side, name, value)
  else
    EoHS.err("EoHS.set_persistent_variable received out-of-date side")
  end
end

-- We check both nick and ID so that:
-- You don't score twice for defeating, e.g., Elvish_Pillager and Elvish_Pillager2
--   if Elvish_Pillager sometimes uses the latter nick after getting disconnected,
-- And you don't score twice for defeating Elvish_Pillager twice if Elvish_Pillager
--   plays on two different devices.
-- You can score twice if both of those happen, but there's not much I can do about that.
local add_to_side_nick_and_id_list = function(side, nick, id, nick_list_name, id_list_name)
  nick = string.gsub(nick, ",", "")
  local nick_list = EoHS.get_persistent_variable(side, nick_list_name) or ","
  local   id_list = EoHS.get_persistent_variable(side,   id_list_name) or ","
  if (not string.match(nick_list, ","..EoHS.lua_pattern_escape(nick)..",")) and (not string.match(id_list, id)) then
    nick_list = nick_list..nick..","
      id_list =   id_list..  id..","
    EoHS.set_persistent_variable(side, nick_list_name, nick_list)
    EoHS.set_persistent_variable(side,   id_list_name,   id_list)
    return true
  end
  return false
end

local score_victory_andor_introduction = function(side1, side2, sides_alive, sides_new)
  local id1 = get_persistent_variable__stored(side1, "identity")
  local id2 = get_persistent_variable__stored(side2, "identity")
  local vars1 = EoHS.get_side_variables(side1)
  local vars2 = EoHS.get_side_variables(side2)
  if id1 ~= id2 then
    if (not vars1.was_ever_ai) and (not vars2.was_ever_ai) and (id1 == vars1.original_identity) and (id2 == vars2.original_identity) then
      if wesnoth.is_enemy(side1, side2) and sides_alive[side1] and not sides_alive[side2] then
        add_to_side_nick_and_id_list(side1, vars2.original_nick, id2,   "defeated_nicks",   "defeated_identities")
      end
      if sides_new[side2] then
        add_to_side_nick_and_id_list(side1, vars2.original_nick, id2, "introduced_nicks", "introduced_identities")
      end
    end
  end
end

EoHS.score_victories_and_introductions = function()
  if not EoHS.get_variable("debug_mode") then
    local units = EoHS.get_units({ canrecruit=true, EoHS.is_on_the_map })
    local sides_alive = {}
    local sides_new = {}
    for i,unit in ipairs(units) do sides_alive[unit.side] = true end
    for side in ipairs(wesnoth.sides) do if not EoHS.get_persistent_variable(side, "introduced_nicks") then sides_new[side] = true end end
    for side1 in ipairs(wesnoth.sides) do
      for side2 in ipairs(wesnoth.sides) do
        score_victory_andor_introduction(side1, side2, sides_alive, sides_new)
      end
    end
  end
end

local count_nick_list = function(nick_list)
  if not nick_list then return 0 end
  local result = 0
  for victory in EoHS.comma_separated_values(nick_list) do result = result + 1 end
  return result
end

EoHS.num_players_defeated = function(side)
  return count_nick_list(EoHS.get_persistent_variable(side, "defeated_nicks"))
end

EoHS.num_newbies_introduced = function(side)
  return count_nick_list(EoHS.get_persistent_variable(side, "introduced_nicks"))
end

-- Basically idempotent; should be called every so often, but mainly at the beginning
-- and end of each game. Games don't usually take more than eight hours.
EoHS.players_are_playing_right_now = function()
  local time = os.time()
  EoHS.update_all_persistent_variables() -- TODO delete
  local hours = 60*60
  local days = 24*hours
  for side in ipairs(wesnoth.sides) do
    EoHS.if_side_is_local(side, function()
      local reference_time_played = EoHS.get_persistent_variable(side, "reference_time_played")
      if reference_time_played then
        -- Without this hack, Wesnoth will apply floating-point rounding to it
        reference_time_played = tonumber(string.match(reference_time_played, "large_number_storing_hack_(.+)"))
        local time_since_reference_point = os.difftime(time, reference_time_played)
        local num_days_played_continuously = EoHS.get_persistent_variable(side, "num_days_played_continuously") or 0
        local time_since_last_day_end = time_since_reference_point - num_days_played_continuously*days
        if time_since_last_day_end > 8*hours then
          set_persistent_variable__both(side, "total_days_played", EoHS.get_persistent_variable(side, "total_days_played") + 1, true)
          if time_since_last_day_end > 1*days then
            set_persistent_variable__both(side, "reference_time_played", "large_number_storing_hack_"..time, true)
            set_persistent_variable__both(side, "num_days_played_continuously", 0, true)
          else
            set_persistent_variable__both(side, "num_days_played_continuously", num_days_played_continuously + 1, true)
          end
        end
      else
        set_persistent_variable__both(side, "reference_time_played", "large_number_storing_hack_"..time, true)
        set_persistent_variable__both(side, "total_days_played", 1, true)
      end
    end)
  end
end

>>)}
