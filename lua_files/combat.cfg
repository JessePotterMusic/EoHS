{EOHS_LUA_FILE (<<-- combat.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

-- You can't save and load during an attack.
-- Thus, we can conveniently keep some attack context information in Lua rather than committing it to WML variables.
-- By storing everything we can in the combat_context variables, we can ensure that none of it is left around to
--   spuriously affect other combats or actions.

local set_combat_event
local end_combat
do
  local combat_context
  set_combat_event = function(name, func)
    EoHS.set_simple_event(name, function()
      if not combat_context then combat_context = {} end
      combat_context.simple = {
        attacker = { unit=EoHS.at_beginning_of_event_get_autostored_unit(       "unit"), attack=wesnoth.get_variable(       "weapon") }, --wesnoth.current.event_context.weapon        didn't work
        defender = { unit=EoHS.at_beginning_of_event_get_autostored_unit("second_unit"), attack=wesnoth.get_variable("second_weapon") }, --wesnoth.current.event_context.second_weapon didn't work
      }
      
      if not combat_context.persistent then
        combat_context.persistent = {
          attacker = { experience_wesnoth_will_give = combat_context.simple.defender.unit.level, original_hitpoints = combat_context.simple.attacker.unit.hitpoints },
          defender = { experience_wesnoth_will_give = combat_context.simple.attacker.unit.level, original_hitpoints = combat_context.simple.defender.unit.hitpoints },
        }
      end
      local fleshed_out_combat_context
      local fleshed_out_combat_context_ignoring_unhittable
      local is_in_this_combat_event = true
      combat_context.get_fleshed_out = function()
        EoHS.assert(is_in_this_combat_event, "getting combat context outside of the combat it was made for")
        if not fleshed_out_combat_context then fleshed_out_combat_context = EoHS.game_action_simulations.fleshed_out_attack_context(combat_context.simple) end
        return fleshed_out_combat_context
      end
      combat_context.get_fleshed_out_ignoring_unhittable = function()
        EoHS.assert(is_in_this_combat_event, "getting combat context outside of the combat it was made for")
        if not fleshed_out_combat_context_ignoring_unhittable then
          local modified_combat_context = EoHS.deep_copy(combat_context.simple)
          EoHS.set_unit_variable(modified_combat_context.attacker.unit, "unhittable_instance_id")
          EoHS.set_unit_variable(modified_combat_context.defender.unit, "unhittable_instance_id")
          fleshed_out_combat_context_ignoring_unhittable = EoHS.game_action_simulations.fleshed_out_attack_context(modified_combat_context)
        end
        return fleshed_out_combat_context_ignoring_unhittable
      end
      func(combat_context)
      is_in_this_combat_event = false
      if combat_context then combat_context.simple = nil end
    end)
  end
  end_combat = function()
    combat_context = nil
  end
end

local terminate_combat_uid = 304599999
local terminate_combat = function(context, last_swinger_role, last_victim_role, was_hit)
  EoHS.assert(was_hit ~= nil, "You must specify whether a unit was hit when terminating combat")
  if context.persistent.combat_terminated then return end
  context.persistent.combat_terminated = true
  -- For SOME reason, drains, poison, slow, and petrify aren't applied until after the events.
  -- So if we terminate combat, we have to apply them manually.
  -- I believe the visual effects will appear, but the actual effects will not, so I don't need to do any graphics stuff here.
  -- (TODO verify)
  local victim = context.simple[last_victim_role].unit
  if was_hit then
    local swinger_stats = context.get_fleshed_out()[last_swinger_role]
      
    if swinger_stats.slows     then EoHS.set_subtag_attribute(victim, "status.slowed"   , true) end
    if swinger_stats.poisons   then EoHS.set_subtag_attribute(victim, "status.poisoned" , true) end
    if swinger_stats.petrifies then EoHS.set_subtag_attribute(victim, "status.petrified", true) end
    if swinger_stats.drains    then
      local swinger = context.simple[last_swinger_role].unit
      swinger.hitpoints = swinger.hitpoints + math.max(0, swinger_stats.next_drains_damage)
      EoHS.put_unit(swinger)
    end
  end
  EoHS.set_unit_variable(victim, "real_underlying_id", victim.underlying_id)
  victim.underlying_id = terminate_combat_uid
  EoHS.put_unit(victim, {allow_unknown_id = true})
end
local stop_swinging = function(context, last_swinger_role, last_victim_role, stopping_swinger_role, stopping_victim_role, was_hit)
  if context.persistent.combat_terminated or pc[stopping_swinger_role].stopped_swinging then return end
  
  if context.persistent[stopping_victim_role].stopped_swinging then
    terminate_combat(last_swinger_role, last_victim_role, was_hit)
  else
    context.persistent[stopping_swinger_role].stopped_swinging = true
    -- After a battle starts, it is literally impossible for one side's number of remaining strikes to be reduced without ending the combat entirely.
    -- The best we can do is to remove all their attacks, which essentially makes them swing a null attack with zero chance to hit.
    -- To make this look right, we also have to override their opponent's defense animation with an empty animation.
    local swinger = context.simple[stopping_swinger_role].unit
    local  victim = context.simple[ stopping_victim_role].unit
    
    table.insert(EoHS.force_subtag(swinger, "modifications"), { "object", {
      id = "EoHS_stop_swinging_object", { "effect", { apply_to = "remove_attacks" }},
    }})
    EoHS.remove_subtags(swinger, "attack")
    
    table.insert(EoHS.force_subtag(victim, "modifications"), { "object", {
      id = "EoHS_stop_swinging_object",
      { "effect", { apply_to = "new_animation", { "defend", {
          base_score = 100,
          -- no duration (this doesn't actually force combat to take no time even if both sides have it, and I think it might default to this much anyway...)
          start_time = 0, { "frame", { duration = 0 }}
      }}, }},
    }})
    
    EoHS.put_unit(swinger)
    EoHS.put_unit(victim)
  end
end

local prepare_for_swing = function(context, swinger_role, victim_role)
  local victim = context.simple[victim_role].unit
  
  -- Attacks against Mage Shields, internally, always miss.
  -- So we have to roll our own numbers and make them have a chance to *pretend* to hit.
  if EoHS.get_unit_variable(victim, "mage_shields") then
    local swinger = context.simple[swinger_role].unit
    local chance_to_hit = context.get_fleshed_out_ignoring_unhittable()[swinger_role].chance_to_hit
    local roll = EoHS.random("0..99")
    EoHS.debug({roll, chance_to_hit})
    local hits = roll < chance_to_hit
    EoHS.set_unit_variable(victim, "mage_shield_gets_hit_next_swing", hits or nil)
    
    local unhittable_instance_id = EoHS.get_variable("next_unhittable_instance_id") or 1
    EoHS.set_variable("next_unhittable_instance_id", unhittable_instance_id + 1)
    
    EoHS.set_unit_variable(victim, "unhittable_instance_id", unhittable_instance_id)
    -- TODO don't keep stacking these on for every attack
    for attack in helper.child_range(swinger, "attack") do
      table.insert(EoHS.force_subtag(attack, "specials"), {"chance_to_hit",{
        id = "EoHS_cant_hit_unhittable_units",
        multiply = 0,
        {"filter_opponent",{ EoHS.has_unit_variables{ unhittable_instance_id=unhittable_instance_id } }},
      }})
    end
    EoHS.put_unit(swinger)
    EoHS.put_unit(victim)
  end
end
local prepare_for_swings = function(context)
  -- Between berserk, firststrike, and scenario events, it would be a lot harder to know which thing comes next.
  -- Good thing it doesn't matter if this is done extra times.
  prepare_for_swing(context, "attacker", "defender")
  prepare_for_swing(context, "defender", "attacker")
end

EoHS.unit_gained_experience = function(unit, amount, artificially)
  if EoHS.get_unit_variable(unit, "is_summon") then
    local summoner = EoHS.get_unit(EoHS.get_unit_variable(unit, "summoner_id"))
    if summoner then
      local transfered_experience = math.floor(amount * EoHS.get_wizard_setting(summoner, "summon_experience_transfer") / 100)
          unit.experience =     unit.experience - transfered_experience
      summoner.experience = summoner.experience + transfered_experience
      EoHS.put_unit(summoner)
      EoHS.unit_gained_experience(summoner, transfered_experience, true)
    end
  end
  if artificially then
    if unit.experience >= unit.max_experience then
      if not EoHS.units_to_advance[unit.x..","..unit.y] then
        EoHS.units_to_advance[unit.x..","..unit.y] = true
        table.insert(EoHS.units_to_advance, {x=unit.x,y=unit.y})
      end
    end
  end
end

local misses_in_combat = function(context, swinger_role, victim_role)
  if context.persistent[swinger_role].stopped_swinging then return end
  
  local victim = context.simple[victim_role].unit
  if EoHS.get_unit_variable(victim, "mage_shield_gets_hit_next_swing") then
    EoHS.set_unit_variable(victim, "mage_shield_gets_hit_next_swing")
    EoHS.lose_a_mage_shield(victim)
    if not EoHS.get_unit_variable(victim, "mage_shields") then
      EoHS.set_unit_variable(victim, "unhittable_instance_id")
    end
    EoHS.put_unit(victim)
    wesnoth.float_label(victim.x, victim.y, "<span color='#8080ff'>".._"blocked!".."</span>") -- TODO: use defense animation instead
  end
  prepare_for_swings(context)
end
local hits_in_combat = function(context, swinger_role, victim_role)
  local victim = context.simple[victim_role].unit
  local swinger = context.simple[swinger_role].unit
  -- The exact condition under which the game considers a kill to have occurred,
  -- UNLESS the reason the victim has <=0 hitpoints is that a scenario event just reduced them.
  -- That's unlikely and I can't think of a way to fully secure against it. 
  if victim.hitpoints <= 0 then
    context.persistent[victim_role].experience_wesnoth_will_give = 0
    context.persistent[swinger_role].experience_wesnoth_will_give = EoHS.kill_experience(victim.level)
    context.persistent.combat_terminated = true
  end
  if victim_role == "defender" and (victim.canrecruit or EoHS.get_unit_variable(victim, "is_wizard")) then
    local max_damage = math.ceil(victim.max_hitpoints / 4)
    local min_hitpoints = context.persistent[victim_role].original_hitpoints - max_damage
    if (min_hitpoints > 0) and (victim.hitpoints < min_hitpoints) then
      wesnoth.float_label(victim.x, victim.y, "<span color='#86aa0e'>"..EoHS.substitute(_"capped at $1|", {max_damage}).."</span>")
      victim.hitpoints = min_hitpoints
      EoHS.put_unit(victim)
      terminate_combat(context, swinger_role, victim_role, true)
    end
  end
  if swinger_role == "attacker" then
    local swinger_has_mud_touch = false
    for i,special in ipairs(EoHS.get_subtags(context.simple[swinger_role].attack, "specials.dummy")) do
      if special.id == "EoHS_mud_touch" then
        swinger_has_mud_touch = true
      end
    end
    if swinger_has_mud_touch then
      local mud_touch_victim
      local is_mount
      if EoHS.get_unit_variable(victim, "is_wizard") then
        mud_touch_victim = EoHS.get_unit_variable(victim, "mount")
        is_mount = true
      else
        mud_touch_victim = victim
      end
      if mud_touch_victim and (mud_touch_victim.type ~= "Mudcrawler") and (mud_touch_victim.type ~= "Giant Mudcrawler") then
        EoHS.set_unit_variable(swinger, "touch_enchantment")
        EoHS.update_all_type_adjustments(swinger) -- TODO should dummy abilities really be type adjustments? Seems like overkill when nothing else changes
        EoHS.put_unit(swinger)
        EoHS.set_unit_variable(mud_touch_victim, "mud_touched", true)
        EoHS.update_all_type_adjustments(mud_touch_victim)
        if is_mount then EoHS.update_all_type_adjustments(victim) end
        EoHS.put_unit(victim) -- NOT mud_touch_victim
        wesnoth.float_label(victim.x, victim.y, "<span color='#805028'>".._"Transmogrified!".."</span>")
        -- TODO also an EoHS message?
        terminate_combat(context, swinger_role, victim_role, true)
      end
    end
  end
  EoHS.update_mount_hitpoints(victim)
end

local w111 = wesnoth.compare_versions(wesnoth.game_config.version, ">=", "1.11.0")
EoHS.attack_disabling_special = function(contents)
  if w111 then
    return { "disable", contents }
  else
    contents.swarm_attacks_min = 0
    contents.swarm_attacks_max = 0
    contents.apply_to = "both"
    return { "swarm", contents }
  end
end

set_combat_event("attack", function(context)
  EoHS.standardize_units()
  -- For this one event, standardization might have changed the attacks:
  for i,role in ipairs({"attacker","defender"}) do
    if context.simple[role].attack and context.simple[role].attack.name then
      for i,subtag in ipairs(context.simple[role].unit) do
        if (subtag[1]=="attack") and (subtag[2].name==context.simple[role].attack.name) then
          context.simple[role].attack = subtag[2]
        end
      end
    end
  end
  EoHS.update_and_share_persistent_variables_of_current_side()
  
  -- In 1.10, we can't use [disable] specials, so we set the attack's swings to zero instead.
  -- The main difference is that this allows you to initiate a bogus attack in order to gain XP.
  -- So, we prevent that.
  -- In 1.11, we might still be dealing with a unit that was created and then attacked,
  --   before EoHS could get to it to give it the disable special. Prevent those attacks too.
  local specials = context.get_fleshed_out().attacker.active_specials
  if specials then for i,special in ipairs(specials) do
    if (w111 and (special[1] == "disable")) or ((not w111) and (special[1] == "swarm") and (special[2].swarm_attacks_min == 0) and (special[2].swarm_attacks_max == 0)) then
      terminate_combat(context, "attacker", "defender", false)
      context.persistent.bogus = true
      return
    end
  end end
  
  local attacker = context.simple.attacker.unit
  if EoHS.get_unit_variable(attacker, "ogre_fury") then
    EoHS.set_unit_variable(attacker, "ogre_fury_attacked_this_turn", true)
    EoHS.put_unit(attacker)
  end
  prepare_for_swings(context)
end)

set_combat_event("attacker_hits"  , function(context)   hits_in_combat(context, "attacker", "defender") end)
set_combat_event("defender_hits"  , function(context)   hits_in_combat(context, "defender", "attacker") end)
set_combat_event("attacker_misses", function(context) misses_in_combat(context, "attacker", "defender") end)
set_combat_event("defender_misses", function(context) misses_in_combat(context, "defender", "attacker") end)

set_combat_event("attack_end", function(context)
  local terminate_combat_unit = EoHS.get_unit(terminate_combat_uid)
  if terminate_combat_unit then
    terminate_combat_unit.underlying_id = EoHS.get_unit_variable(terminate_combat_unit, "real_underlying_id")
    EoHS.set_unit_variable(terminate_combat_unit, "real_underlying_id")
    EoHS.put_unit(terminate_combat_unit, {allow_unknown_id = true})
  end
  if not context.persistent.bogus then
    for i,role in ipairs({"attacker","defender"}) do
      local opponent_role = (i == 1) and "defender" or "attacker"
      local unit = context.simple[role].unit
      local opponent = context.simple[opponent_role].unit
      -- If we reverted a kill, don't give kill XP
      local correct_experience = (unit.hitpoints <= 0) and 0 or ((opponent.hitpoints <= 0) and EoHS.kill_experience(opponent.level) or opponent.level)
      unit.experience = unit.experience - context.persistent[role].experience_wesnoth_will_give + correct_experience
      EoHS.unit_gained_experience(unit, correct_experience, false)
      if context.persistent[role].stopped_swinging then
        local modifications = EoHS.get_subtag(unit, "modifications")
        local i = 1
        EoHS.remove_subtags(modifications, "object", "EoHS_stop_swinging_object")
        -- Just in case: A scenario event could theoretically have given the unit an extra attack in between.
        -- We need to make sure attacks are regenerated.
        EoHS.remove_subtags(unit, "attack")
      end
      EoHS.remove_subtags(unit, "attack.specials.chance_to_hit", "EoHS_cant_hit_unhittable_units")
      EoHS.set_unit_variable(unit, "unhittable_instance_id")
      EoHS.put_unit(unit)
    end
  end
  EoHS.standardize_units()
  end_combat()
end)

>>)}
