{EOHS_LUA_FILE (<<-- combat.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS

-- You can't save and load during an attack.
-- Thus, we can conveniently keep some attack context information in Lua rather than committing it to WML variables.
-- By storing everything we can in the combat_context variables, we can ensure that none of it is left around to
--   spuriously affect other combats or actions.

local get_fleshed_out_combat_context
local get_persistent_combat_context
local get_simple_combat_context
local set_combat_event
local is_in_combat_event = false
do
  local simple_combat_context
  local persistent_combat_context
  local fleshed_out_combat_context
  set_combat_event = function(name, func)
    EoHS.set_simple_event(name, function()
      simple_combat_context = {
        attacker = { unit=EoHS.at_beginning_of_event_get_autostored_unit(       "unit"), attack=wesnoth.current.event_context.weapon        },
        defender = { unit=EoHS.at_beginning_of_event_get_autostored_unit("second_unit"), attack=wesnoth.current.event_context.second_weapon },
      }
      fleshed_out_combat_context = nil
      is_in_combat_event = true
      func()
      is_in_combat_event = false
      fleshed_out_combat_context = nil
      simple_combat_context = nil
    end)
  end
  begin_combat = function()
    persistent_combat_context = {
      attacker = { experience_wesnoth_will_give = simple_combat_context.defender.unit.level },
      defender = { experience_wesnoth_will_give = simple_combat_context.attacker.unit.level },
    }
  end
  get_fleshed_out_combat_context = function()
    EoHS.assert(is_in_combat_event, "getting combat context outside of combat")
    if not fleshed_out_combat_context then combat_context = EoHS.game_action_simulations.fleshed_out_attack_context(simple_combat_context) end
    return fleshed_out_combat_context
  end
  get_simple_combat_context = function()
    EoHS.assert(is_in_combat_event, "getting simple combat context outside of combat")
    return simple_combat_context
  end
  get_persistent_combat_context = function()
    EoHS.assert(is_in_combat_event, "getting persistent combat context outside of combat")
    return persistent_combat_context
  end
end

local terminate_combat_uid = 304599999
local terminate_combat = function(last_swinger_role, last_victim_role, was_hit)
  local pc = get_persistent_combat_context()
  if pc.combat_terminated then return end
  pc.combat_terminated = true
  -- For SOME reason, drains, poison, slow, and petrify aren't applied until after the events.
  -- So if we terminate combat, we have to apply them manually.
  -- I believe the visual effects will appear, but the actual effects will not, so I don't need to do any graphics stuff here.
  -- (TODO verify)
  local victim = get_simple_combat_context()[last_victim_role].unit
  if was_hit then
    local swinger = get_fleshed_out_combat_context()[last_swinger_role]
      
    if swinger.slows     then EoHS.set_subtag_attribute(victim, "status.slowed"   , true) end
    if swinger.poisons   then EoHS.set_subtag_attribute(victim, "status.poisoned" , true) end
    if swinger.petrifies then EoHS.set_subtag_attribute(victim, "status.petrified", true) end
    if swinger.drains    then
      swinger.unit.hitpoints = swinger.unit.hitpoints + math.max(0, swinger.next_drains_damage)
      EoHS.put_unit(swinger.unit)
    end
  end
  EoHS.set_unit_variable(victim, "real_underlying_id", victim.underlying_id)
  victim.underlying_id = terminate_combat_uid
  EoHS.put_unit(victim)
end
local stop_swinging = function(last_swinger_role, last_victim_role, stopping_swinger_role, stopping_victim_role)
  local pc = get_persistent_combat_context()
  if pc.combat_terminated or pc[stopping_swinger_role].stopped_swinging then return end
  
  if pc[stopping_victim_role].stopped_swinging then
    terminate_combat(last_swinger_role, last_victim_role)
  else
    pc[stopping_swinger_role].stopped_swinging = true
    -- After a battle starts, it is literally impossible for one side's number of remaining strikes to be reduced without ending the combat entirely.
    -- The best we can do is to remove all their attacks, which essentially makes them swing a null attack with zero chance to hit.
    -- To make this look right, we also have to override their opponent's defense animation with an empty animation.
    local swinger = get_simple_combat_context()[stopping_swinger_role].unit
    local  victim = get_simple_combat_context()[ stopping_victim_role].unit
    
    table.insert(EoHS.force_subtag(swinger, "modifications"), { "object", {
      id = "EoHS_stop_swinging_object", { "effect", { apply_to = "remove_attacks" }},
    }})
    local i = 1; while swinger[i] do if swinger[i][1] == "attack" then table.remove(swinger, i) else i = i + 1 end end
    
    table.insert(EoHS.force_subtag(victim, "modifications"), { "object", {
      id = "EoHS_stop_swinging_object",
      { "effect", { apply_to = "new_animation", { "defend", {
          base_score = 100,
          -- no duration (this doesn't actually force combat to take no time even if both sides have it, and I think it might default to this much anyway...)
          start_time = 0, { "frame", { duration = 0 }}
      }}, }},
    }})
    
    EoHS.put_unit(swinger)
    EoHS.put_unit(victim)
  end
end

local prepare_for_swing = function(swinger_role, victim_role)
  -- Attacks against Mage Shields, internally, always miss.
  -- So we have to roll our own numbers and make them have a chance to *pretend* to hit.
  if EoHS.get_unit_variable(victim, "mage_shield") then
    -- TODO how to make the fake attack context that ignores the mage shield...?
    local hits = EoHS.random("0..99") < TODO.chance_to_hit
    
  end
end
local prepare_for_swings = function()
  -- Between berserk, firststrike, and scenario events, it would be a lot harder to know which thing comes next.
  -- Good thing it doesn't matter if this is done extra times.
  prepare_for_swing("attacker", "defender")
  prepare_for_swing("defender", "attacker")
end

local lose_a_shield = function(unit)
  local shields = EoHS.get_unit_variable(unit, "mage_shields")
  if shields <= 1 then
    EoHS.set_unit_variable(unit, "mage_shields")
    EoHS.set_unit_variable(unit, "unhittable")
  else
    EoHS.set_unit_variable(unit, "mage_shields", shields - 1)
  end
  EoHS.update_unit_graphics(unit)
end

local misses_in_combat = function(swinger_role, victim_role)
  local pc = get_persistent_combat_context()
  if pc[swinger_role].stopped_swinging then return end
  
  if EoHS.get_unit_variable(get_simple_combat_context()[victim_role].unit, "mage_shield_gets_hit_next") then
    local shielded = get_fleshed_out_combat_context()[victim_role] -- doesn't need fleshed out after below TODO
    lose_a_shield(shielded.unit)
    EoHS.put_unit(shielded.unit)
    wesnoth.float_label(shielded.x, shielded.y, "<span color='#8080ff'>"..shielded.opponent.damage..(_" blocked!").."</span>") -- TODO: use defense animation instead
  end
  prepare_for_swings()
end
local hits_in_combat = function(swinger_role, victim_role)
  local pc = get_persistent_combat_context()
  local victim = EoHS.get_unit_variable(get_simple_combat_context()[victim_role].unit
  if victim.hitpoints <= 0 then
    pc[victim_role].experience_wesnoth_will_give = 0
    pc[swinger_role].experience_wesnoth_will_give = EoHS.kill_experience(victim.level)
    pc.combat_terminated = true
  end
end

set_combat_event("attack", function()
  EoHS.standardize_units()
  EoHS.update_and_share_persistent_variables_of_current_side()
  prepare_for_swings()
end)

set_combat_event("attacker_hits"  , function()   hits_in_combat("attacker", "defender") end)
set_combat_event("defender_hits"  , function()   hits_in_combat("defender", "attacker") end)
set_combat_event("attacker_misses", function() misses_in_combat("attacker", "defender") end)
set_combat_event("defender_misses", function() misses_in_combat("defender", "attacker") end)

set_combat_event("attack_end", function()
  local pc = get_persistent_combat_context()
  local terminate_combat_unit = EoHS.get_unit(terminate_combat_uid)
  if terminate_combat_unit then
    terminate_combat_unit.underlying_id = EoHS.get_unit_variable(victim, "real_underlying_id")
    EoHS.set_unit_variable(victim, "real_underlying_id")
    EoHS.put_unit(terminate_combat_unit)
  end
  for i,role in ipairs({"attacker","defender"}) do
    if pc[role].stopped_swinging then
      local unit = get_simple_combat_context()[role].unit
      local modifications = EoHS.get_subtag(unit, "modifications")
      local i = 1
      while modifications[i] do if modifications[i][2].id == "EoHS_stop_swinging_object" then table.remove(unit, i) else i = i + 1 end end
      -- Just in case: A scenario event could theoretically have given the unit an extra attack in between.
      -- We need to make sure attacks are regenerated.
      local i = 1
      while unit[i] do if unit[i][1] == "attack" then table.remove(unit, i) else i = i + 1 end end
      EoHS.put_unit(unit)
    end
  end
end)

>>)}
