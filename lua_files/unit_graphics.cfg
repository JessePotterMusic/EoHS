{EOHS_LUA_FILE (<<-- unit_graphics.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

--[[

A "unit_graphics" is a {
  underlays = image_aggregate,
  main_layer = image_layer,
  overlays = image_aggregate,
}

]]

EoHS.TC_image_mod = function(side, src_colors)
  wesnoth.fire("store_side", { side=side, variable="EoHS.LUA_TEMP", } )
  local color = wesnoth.get_variable("EoHS.LUA_TEMP.color")
  wesnoth.set_variable("EoHS.LUA_TEMP")
  return "~TC("..color..","..src_colors..")"
end

EoHS.unit_TC_image_mod = function(unit)
  local flag_rgb = EoHS.get_unit_type(unit.type).flag_rgb
  if flag_rgb then
    return EoHS.TC_image_mod(unit.side, flag_rgb)
  else
    return ""
  end
end

--[[EoHS.unit_image_mods = function(unit, include_EoHS_unit_graphics_override)
  local image_mods = ""
  local modifications = helper.get_child(unit, "modifications")
  for i,effect in ipairs(EoHS.get_unit_effects(unit, (not include_EoHS_unit_graphics_override) and {exclude_id = "EoHS_unit_graphics_override"})) do
    if effect.apply_to == "image_mod" then
      if effect.replace then
        -- Hack to appease the macro TEAM_COLOR_OVERRIDE, which currently (1.10.6) uses "RC()" when it should use "~RC()"
        if string.sub(effect.replace, 1, 1) ~= "~" then effect.replace = "~"..effect.replace end
        image_mods = effect.replace
      end
      if effect.add then
        -- Hack to appease the macro TEAM_COLOR_OVERRIDE, which currently (1.10.6) uses "RC()" when it should use "~RC()"
        if string.sub(effect.add, 1, 1) ~= "~" then effect.add = "~"..effect.add end
        image_mods = image_mods..effect.add
      end
    end
  end
  image_mods = image_mods..EoHS.unit_TC_image_mod(unit)
  return image_mods
end]]

do
  local wizard_casting_image_bases_table = {
    [      "Mage"] = {"units/human-magi/mage+female-attack-magic1.png"       , "units/human-magi/mage+female-attack-magic2.png"       },
    [  "Red Mage"] = {"units/human-magi/red-mage+female-attack-magic-1.png"  , "units/human-magi/red-mage+female-attack-magic-2.png"  },
    [ "Arch Mage"] = {"units/human-magi/arch-mage+female-attack-magic-1.png" , "units/human-magi/arch-mage+female-attack-magic-2.png" },
    ["Great Mage"] = {"units/human-magi/great-mage+female-attack-magic-1.png", "units/human-magi/great-mage+female-attack-magic-2.png"},
    [      "Lich"] = {"units/undead-necromancers/lich-magic-1.png"           , "units/undead-necromancers/lich-magic-3.png"           },
  }
  EoHS.wizard_casting_image_base = function(unit, frame_number)
    local image_base = wizard_casting_image_bases_table[unit.type][frame_number]
    if unit.gender ~= "female" then
      local result = string.gsub(image_base, "+female", "") -- strip gsub's extra return value
      return result
    end
    return image_base
  end
end

do
  local weapon_head_offsets_table = {
    ["units/undead-necromancers/lich.png"             ] = { x = 36-11, y = 36-22 },
    ["units/undead-necromancers/lich-magic-1.png"     ] = { x = 36-12, y = 36-25 },
    ["units/undead-necromancers/lich-magic-2.png"     ] = { x = 36-14, y = 36-26 },
    ["units/undead-necromancers/lich-magic-3.png"     ] = { x = 36-15, y = 36-28 },
    ["units/undead-necromancers/lich-defend.png"      ] = { x = 36-15, y = 36-24 },
    ["units/undead-necromancers/lich-idle-1.png"      ] = { x = 36-11, y = 36-23 },
    ["units/undead-necromancers/lich-idle-2.png"      ] = { x = 36-11, y = 36-23 },
    ["units/undead-necromancers/lich-idle-3.png"      ] = { x = 36-11, y = 36-23 },
    ["units/undead-necromancers/lich-melee-1.png"     ] = { x = 36- 7, y = 36-26 },
    ["units/undead-necromancers/lich-melee-2.png"     ] = { x = 36- 5, y = 36-26 },
    ["units/human-magi/mage.png"                      ] = { x = 36+15, y = 36-14 },
    ["units/human-magi/mage-attack-magic1.png"        ] = { x = 36+14, y = 36-16 },
    ["units/human-magi/mage-attack-magic2.png"        ] = { x = 36+ 9, y = 36-21 },
    ["units/human-magi/mage-attack-staff1.png"        ] = { x = 36+ 8, y = 36-24 },
    ["units/human-magi/mage-attack-staff2.png"        ] = { x = 36+27, y = 36+10 },
    ["units/human-magi/mage-defend.png"               ] = { x = 36+12, y = 36-15 },
    ["units/human-magi/red-mage.png"                  ] = { x = 36+14, y = 36-11 },
    ["units/human-magi/red-mage-attack-magic-1.png"   ] = { x = 36+13, y = 36-18 },
    ["units/human-magi/red-mage-attack-magic-2.png"   ] = { x = 36+11, y = 36-23 },
    ["units/human-magi/red-mage-attack-staff-1.png"   ] = { x = 36+10, y = 36-23 },
    ["units/human-magi/red-mage-attack-staff-2.png"   ] = { x = 36+28, y = 36+ 9 },
    ["units/human-magi/red-mage-defend.png"           ] = { x = 36+14, y = 36-17 },
    ["units/human-magi/arch-mage.png"                 ] = { x = 36+16, y = 36-18 },
    ["units/human-magi/arch-mage-attack-magic-1.png"  ] = { x = 36+17, y = 36-21 },
    ["units/human-magi/arch-mage-attack-magic-2.png"  ] = { x = 36+18, y = 36-24 },
    ["units/human-magi/arch-mage-attack-staff-1.png"  ] = { x = 36+ 6, y = 36-30 },
    ["units/human-magi/arch-mage-attack-staff-2.png"  ] = { x = 36+30, y = 36+10 },
    ["units/human-magi/arch-mage-defend.png"          ] = { x = 36+13, y = 36-19 },
    ["units/human-magi/great-mage.png"                ] = { x = 36+17, y = 36-26 },
    ["units/human-magi/great-mage-attack-magic-1.png" ] = { x = 36+17, y = 36-28 },
    ["units/human-magi/great-mage-attack-magic-2.png" ] = { x = 36+18, y = 36-31 },
    ["units/human-magi/great-mage-attack-staff-1.png" ] = { x = 36+ 3, y = 36-33 },
    ["units/human-magi/great-mage-attack-staff-2.png" ] = { x = 36+32, y = 36+10 },
    ["units/human-magi/great-mage-defend.png"         ] = { x = 36+12, y = 36-27 },
    ["units/undead/wraith-s.png"                      ] = { x = 36+ 8, y = 36+ 5 },
    ["units/undead/wraith-s-1.png"                    ] = { x = 36+ 8, y = 36+ 5 },
    ["units/undead/wraith-s-2.png"                    ] = { x = 36+ 8, y = 36+ 5 },
    ["units/undead/wraith-s-3.png"                    ] = { x = 36+ 7, y = 36+ 4 },
    ["units/undead/wraith-s-4.png"                    ] = { x = 36+ 7, y = 36+ 5 },
    ["units/undead/wraith-s-defend-1.png"             ] = { x = 36+ 7, y = 36+ 3 },
    ["units/undead/wraith-s-defend-2.png"             ] = { x = 36+ 6, y = 36+ 2 },
    ["units/undead/wraith-s-attack-1.png"             ] = { x = 36+ 6, y = 36+ 1 },
    ["units/undead/wraith-s-attack-2.png"             ] = { x = 36+ 0, y = 36+10 },
    ["units/undead/wraith-s-attack-3.png"             ] = { x = 36+14, y = 36- 6 },
    ["units/undead/wraith-s-attack-4.png"             ] = { x = 36+14, y = 36- 6 },
    ["units/undead/wraith-s-attack-5.png"             ] = { x = 36+15, y = 36- 7 },
  }
  EoHS.weapon_head_offset = function(image_layer_or_unit_graphics)
    if image_layer_or_unit_graphics.main_layer then image_layer_or_unit_graphics = image_layer_or_unit_graphics.main_layer end
  -- EoHS.err("w")
    local relevant_image_name = string.gsub(EoHS.get_image_base(image_layer_or_unit_graphics), "+female", "")
    local result = EoHS.deep_copy(weapon_head_offsets_table[relevant_image_name])
    if not result then
      if string.find(relevant_image_name, "spectre") then result = { x=55, y=23 }
      else return EoHS.image_layer_offset(image_layer_or_unit_graphics) end
    end
    result = EoHS.offset_relative_to_base_image(result, image_layer_or_unit_graphics)
    return result
  end
end

EoHS.rider_mountpoint_offset = function(image_layer_or_unit_graphics)
  if image_layer_or_unit_graphics.main_layer then image_layer_or_unit_graphics = image_layer_or_unit_graphics.main_layer end
  -- EoHS.err("g")
  local relevant_image_name = string.gsub(EoHS.get_image_base(image_layer_or_unit_graphics), "+female", "")
  local result
      if string.match(relevant_image_name, "deathknight-crossbow") then result = { x = 36- 5, y = 36+12 }
  elseif string.match(relevant_image_name, "deathknight"         ) then result = { x = 36- 4, y = 36+ 4 }
  elseif string.match(relevant_image_name,           "great-mage") then result = { x = 36, y = 43 }
  elseif string.match(relevant_image_name,            "arch-mage") then result = { x = 36, y = 41 }
  elseif string.match(relevant_image_name,             "red-mage") then result = { x = 33, y = 41 }
  elseif string.match(relevant_image_name,                 "mage") then result = { x = 34, y = 42 }
  elseif string.match(relevant_image_name,                 "lich") then result = { x = 36+ 2, y = 36+ 4 }
  end
  if not result then
    return EoHS.image_layer_offset(image_layer_or_unit_graphics)
  end
  result = EoHS.offset_relative_to_base_image(result, image_layer_or_unit_graphics)
  return result
end

-- TODO: refine these by actually tweaking them while looking at them in-game
do
  local mount_mountpoints_table = {
    ["units/monsters/water-serpent.png"            ] = { x=30, y=47 },
    ["units/monsters/water-serpent-n.png"          ] = { x=35, y=41 },
    ["units/monsters/gryphon.png"                  ] = { x =  41, y =  34 },
    ["units/monsters/gryphon-flying-1.png"         ] = { x =  65, y = 60- 5 },
    ["units/monsters/gryphon-flying-2.png"         ] = { x =  65, y = 60- 8 },
    ["units/monsters/gryphon-flying-3.png"         ] = { x =  65, y = 60-10 },
    ["units/monsters/gryphon-flying-4.png"         ] = { x =  65, y = 60-14 },
    ["units/monsters/gryphon-flying-5.png"         ] = { x =  65, y = 60-12 },
    ["units/monsters/gryphon-flying-6.png"         ] = { x =  65, y = 60- 9 },
    ["units/monsters/gryphon-flying-7.png"         ] = { x =  65, y = 60- 6 },
    ["units/monsters/gryphon-flying-8.png"         ] = { x =  65, y = 60- 3 },
    ["units/monsters/fire-dragon.png"              ] = { x = 114, y =  71 },
    ["units/undead-skeletal/chocobone.png"         ] = { x = 36- 5, y = 36- 2 },
    ["units/undead-skeletal/chocobone-defend-2.png"] = { x = 36-14, y = 36 },
    ["units/undead-skeletal/chocobone-defend-1.png"] = { x = 36-12, y = 36- 2 },
    ["units/undead-skeletal/chocobone-attack-1.png"] = { x = 36- 7, y = 36 },
    ["units/undead-skeletal/chocobone-attack-2.png"] = { x = 36- 8, y = 36 },
    ["units/undead-skeletal/chocobone-attack-3.png"] = { x = 36- 3, y = 36- 1 },
    ["units/undead-skeletal/chocobone-attack-4.png"] = { x = 36- 8, y = 36 },
  }
  local wolf_aux = {
    ["units/monsters/wolf.png"                    ] = { x = 36- 1, y = 36- 7 },
    ["units/monsters/wolf-water.png"              ] = { x = 36- 1, y = 36- 7 },
    ["units/monsters/wolf-moving.png"             ] = { x = 36+ 0, y = 36- 5 },
    ["units/monsters/wolf-attack.png"             ] = { x = 36+ 5, y = 36- 9 },
    ["units/monsters/wolf-defend-1.png"           ] = { x = 36- 3, y = 36+ 0 },
    ["units/monsters/wolf-defend-2.png"           ] = { x = 36- 1, y = 36- 4 },
  }
  for k,v in pairs(wolf_aux) do
    local gwolf_name = string.gsub(k, "wolf", "wolf-great")
    local dwolf_name = string.gsub(k, "wolf", "direwolf")
    
    mount_mountpoints_table[k] = EoHS.deep_copy(v)
    
    mount_mountpoints_table[gwolf_name] = EoHS.deep_copy(v)
    mount_mountpoints_table[gwolf_name].y = v.y - 5
    
    mount_mountpoints_table[dwolf_name] = EoHS.deep_copy(v)
    mount_mountpoints_table[dwolf_name].y = v.y - 6
  end
  
  EoHS.mount_mountpoint_offset = function(image_layer_or_unit_graphics)
    if image_layer_or_unit_graphics.main_layer then image_layer_or_unit_graphics = image_layer_or_unit_graphics.main_layer end
  -- EoHS.err("s")
    local relevant_image_name = EoHS.get_image_base(image_layer_or_unit_graphics)
    local result = EoHS.deep_copy(mount_mountpoints_table[relevant_image_name])
    if not result then
      if string.find(relevant_image_name, "mudcrawler") then result = { x=36- 1, y=36- 7 }
      elseif string.find(relevant_image_name, "water%-serpent%-n") then result = EoHS.deep_copy(mount_mountpoints_table["units/monsters/water-serpent-n.png"])
      elseif string.find(relevant_image_name, "water%-serpent")    then result = EoHS.deep_copy(mount_mountpoints_table["units/monsters/water-serpent.png"  ])
      else return EoHS.image_layer_offset(image_layer_or_unit_graphics) end
    end
    result = EoHS.offset_relative_to_base_image(result, image_layer_or_unit_graphics)
    return result
  end
end

EoHS.unit_graphics_aggregate = function(unit_graphics)
  return EoHS.image_aggregates_combined(unit_graphics.underlays, unit_graphics.main_layer_eviscerated or unit_graphics.main_layer, unit_graphics.overlays)
end
EoHS.translate_unit_graphics = function(unit_graphics, offset)
  unit_graphics.underlays  = EoHS.image_aggregate_translated(unit_graphics.underlays , offset)
  unit_graphics.main_layer = EoHS.image_aggregate_translated(unit_graphics.main_layer, offset)
  unit_graphics.overlays   = EoHS.image_aggregate_translated(unit_graphics.overlays  , offset)
  unit_graphics.main_layer_eviscerated = unit_graphics.main_layer_eviscerated and EoHS.image_aggregate_translated(unit_graphics.main_layer_eviscerated, offset)
end

EoHS.simple_unit_graphics = function(main_layer) return { underlays = {}, main_layer = main_layer, overlays = {} } end

EoHS.unit_graphics_ignoring_mount = function(unit, main_layer)
  local variables = EoHS.get_unit_variables(unit) or {}
  local result = EoHS.simple_unit_graphics(main_layer)
  local underlay = function(...)
    result.underlays = EoHS.image_aggregate_destructive_combine(result.underlays, ...)
  end
  local overlay = function(...)
    result.overlays = EoHS.image_aggregate_destructive_combine(result.overlays, ...)
  end
  
  local weapon_head_offset = EoHS.weapon_head_offset(main_layer)

  if variables.dark_pact then
    local dark_layer = EoHS.full_image_layer_copy(main_layer)
    dark_layer.image_modded = dark_layer.image_modded.."~O(0.5)~CS(-255,-255,-255)"
    
    underlay(EoHS.image_aggregate_translated(dark_layer, {x= 2}))
    underlay(EoHS.image_aggregate_translated(dark_layer, {x=-2}))
    underlay(EoHS.image_aggregate_translated(dark_layer, {y= 2}))
    underlay(EoHS.image_aggregate_translated(dark_layer, {y=-2}))
  end
  if variables.rampage then
    local rampage_layer = EoHS.full_image_layer_copy(main_layer)
    rampage_layer.image_modded = rampage_layer.image_modded.."~O(0.5)~CS(255,255,-255)~CS(0,-127,0)~BL(3)"
    overlay(rampage_layer)
  end
  if variables.curse_of_anxiety then
    overlay{ image_modded = "projectiles/wailprojectile-ne-3.png~O(0.8)"          , offset = { x =  11, y = -9 } }
    overlay{ image_modded = "projectiles/wailprojectile-ne-3.png~O(0.8)~FL(horiz)", offset = { x = -11, y = -9 } }
  end
  if variables.lightning_paralysis then
    overlay("projectiles/gaze.png")
  end
  local num_swords = 0
  -- TODO swords
  if num_swords >= 1 then
    overlay("items/sword.png")
  end
  if num_swords >= 2 then
    overlay("items/sword.png~FL(horiz)")
  end
  if variables.dispelling_touch then
    overlay{ image_modded = "halo/elven/ice-halo5.png", offset = EoHS.deep_copy(weapon_head_offset) }
  end
  if variables.reanimating_touch then
    overlay{ image_modded = "projectiles/darkmissile-ne.png~CROP(16,16,40,40)", offset = EoHS.deep_copy(weapon_head_offset) }
  end
  if variables.mud_touch then
    overlay{ image_modded = "projectiles/mud-glob.png~CROP(26,25,19,19)", offset = EoHS.deep_copy(weapon_head_offset) }
  end
  if variables.regeneration then
    overlay("halo/elven/nature-halo6.png")
  end
  if variables.just_teleported_ally then
    overlay("footsteps/teleport-in.png~O(0.5)")
  end
  if variables.just_teleported_enemy then
    overlay("footsteps/teleport-in.png~O(0.5)~CS(40,150,-80)")
  end
  
  if not (variables.is_summon and (unit.type == "Death Knight")) then -- chocoknights have their mods added elsewhere
    result.main_layer = EoHS.image_aggregate_modded(result.main_layer, unit.image_mods) -- unit.image_mods exists because this is actually a graphics_influencing_data, not a unit
  end

  return result
end

EoHS.mount_underlays_and_overlays_cache = {}

EoHS.mounted_unit_graphics = function(mount_graphics, rider_graphics)
  local mount_mountpoint_offset = EoHS.mount_mountpoint_offset(mount_graphics)
  local rider_mountpoint_offset = EoHS.rider_mountpoint_offset(rider_graphics)
  local rider_offset = EoHS.offset_translated(mount_mountpoint_offset, EoHS.offset_negated(rider_mountpoint_offset))
  
  local result = EoHS.deep_copy(rider_graphics)
  EoHS.translate_unit_graphics(result, rider_offset)
  
  local mount_image_aggregate = EoHS.unit_graphics_aggregate(mount_graphics)
  -- Flatten so that cropping doesn't create an excessive amount of layers.
  -- local mount_image_modded = EoHS.collapse_image_aggregate(EoHS.unit_graphics_aggregate(mount_graphics), "image_layer")
  local mount_image_base = EoHS.get_image_base(mount_graphics.main_layer)
  
  local underlay_overlay = function(lays_func)
    local cached = EoHS.mount_underlays_and_overlays_cache[mount_image_base]
    if not cached then
      local under, over = lays_func()
      EoHS.mount_underlays_and_overlays_cache[mount_image_base] = { under, over }
      cached = EoHS.mount_underlays_and_overlays_cache[mount_image_base]
      
      -- EoHS.err("Lays: "..EoHS.inspect(lays))
    end
    result.underlays = EoHS.image_aggregates_combined(cached[1], result.underlays)
    result.overlays = EoHS.image_aggregate_destructive_combine(result.overlays, cached[2])
  end
  
  -- EoHS.err("l")
  local l = function(c)
    c.relative_to_base_image = mount_image_base
    return c
  end
  if mount_image_base == "units/monsters/fire-dragon.png" then
    underlay_overlay(function()
      local top = EoHS.image_aggregate_cropped(mount_image_aggregate, l{ y2 = 108 })
      return mount_image_aggregate, EoHS.image_aggregate_sampled(top,
        { x1 = mount_mountpoint_offset.x, y1 = mount_mountpoint_offset.y, },
        l{ x=108, y1=53, y2=55, },
        l{ x=109, y1=53, y2=57, },
        l{ x=110, y1=54, y2=58, },
        l{ x=111, y1=55, y2=60, },
        l{ x=112, y1=56, y2=61, },
        l{ x=113, y1=57, y2=67, },
        l{ x=114, y1=58, y2=68, },
        l{ x=115, y1=58, y2=69, },
        l{ x=116, y1=59, },
        l{ x=117, y1=60, },
        l{ x=118, y1=61, },
        l{ x=119, y1=62, },
        l{ x1=120, x2=122, y1=63, },
        l{ x1=123, y1=64, },
        l{ x1=125, y1=49, }--[[,
        l{ x=108, y1=71, y2=75, },
        l{ x=109, y1=70, },
        l{ x=110, y1=71, },
        l{ x1=111, y1=72, }]])
    end)
  elseif string.find(mount_image_base, "water%-serpent%-attack") then
    -- Riding during a lunge would be unrealistic AND I can't draw it nicely. Temporarily appear to dismount.
    if string.find(mount_image_base, "water%-serpent%-attack%-s%-") then
      underlay_overlay(function() return {}, mount_image_aggregate end)
    else
      underlay_overlay(function() return mount_image_aggregate, {} end)
    end
  elseif mount_image_base == "units/monsters/water-serpent-n.png" then
    underlay_overlay(function()
      return EoHS.image_aggregate_cropped(mount_image_aggregate, {y2 = 45}), EoHS.image_aggregate_sampled(mount_image_aggregate,
        { x1 = mount_mountpoint_offset.x, y1 = mount_mountpoint_offset.y },
        l{ x1 = 36, },
        l{ y1 = 42, x2 = 23 },
        l{ y1 = 43, x1 = 22, x2 = 25, },
        l{ y1 = 44, x1 = 26, x2 = 28, },
        l{ y1 = 45, x1 = 29, x2 = 33, },
        l{ y1 = 46, x1 = 34, })
    end)
  elseif mount_image_base == "units/monsters/water-serpent.png" then
    underlay_overlay(function()
      local left, right = EoHS.image_aggregate_split(mount_image_aggregate, { x1 = mount_mountpoint_offset.x })
      local top, bot = EoHS.image_aggregate_split(right, l{ y1 = 48 })
      local under, over = EoHS.image_aggregate_split(top, l{ x1 = 30, y1 = 47, x2 = 37 },
        l{ y1 = 47, x1 = 42, },
        l{ y1 = 46, x1 = 44, },
        l{ x1 = 45, },
        l{ x1 = 38, y2 = 39, })
      return EoHS.image_aggregates_combined(left, under), EoHS.image_aggregates_combined(bot, over)
    end)
  elseif string.find(mount_image_base, "chocobone") then
    underlay_overlay(function()
      return EoHS.image_aggregate_split(mount_image_aggregate, { x1 = mount_mountpoint_offset.x, y1 = mount_mountpoint_offset.y }, { x1 = 6 })
    end)
  else
    underlay_overlay(function()
      return EoHS.image_aggregate_split(mount_image_aggregate, { x1 = mount_mountpoint_offset.x, y1 = mount_mountpoint_offset.y })
    end)
  end
  
  return result
end

EoHS.unit_default_main_layer = function(unit, anim)
  return EoHS.get_unit_variable(unit, "is_casting_a_spell") and EoHS.wizard_casting_image_base(unit, 2) or unit.image
end

EoHS.mount_default_main_layer = function(unit, anim)
  if anim then
    if unit.type == "Water Serpent" then
      if anim.direction and string.match(anim.direction, "n") then
        return "units/monsters/water-serpent-n.png"
      end
    end
    if EoHS.is_attack_anim(anim) or EoHS.is_movement_anim(anim) then
          if unit.type ==       "Wolf" then return "units/monsters/wolf-moving.png"
      elseif unit.type == "Great Wolf" then return "units/monsters/wolf-great-moving.png"
      elseif unit.type ==   "Direwolf" then return "units/monsters/direwolf-moving.png"
      elseif unit.type ==    "Gryphon" then return "units/monsters/gryphon-flying-4.png"
      elseif unit.type ==  "Chocobone" then return "units/undead-skeletal/chocobone-attack-1.png"
      end
    end
  end
  -- TODO: combine defense anims
  return unit.image--.."~O(0.5)"
end

EoHS.unit_graphics = function(palettes_and_ranges, unit, main_layer, mount_layer, anim)
  local variables = EoHS.get_unit_variables(unit) or {}
  if variables.is_mounted or (variables.is_summon and (unit.type == "Death Knight")) then
    if not main_layer then main_layer = EoHS.unit_default_main_layer(unit, anim) end
    if not mount_layer then 
      if (variables.is_summon and (unit.type == "Death Knight")) then
           mount_layer = EoHS.mount_default_main_layer({type="Chocobone",image="units/undead-skeletal/chocobone.png"}, anim)
      else mount_layer = EoHS.mount_default_main_layer(EoHS.get_subtag(variables, "mount"), anim) end
    end
  end

  if (variables.is_summon and (unit.type == "Death Knight")) then
    main_layer = EoHS.collapse_image_aggregate(EoHS.image_aggregate_modded(EoHS.unit_graphics_aggregate(EoHS.mounted_unit_graphics(EoHS.simple_unit_graphics(mount_layer), EoHS.simple_unit_graphics(main_layer))), unit.image_mods), "image_layer")
  end
  local graphics_ignoring_mount = EoHS.unit_graphics_ignoring_mount(unit, main_layer)
  local result
  if variables.is_mounted then
    result = EoHS.mounted_unit_graphics(EoHS.simple_unit_graphics(mount_layer), graphics_ignoring_mount)
  else
    result = graphics_ignoring_mount
  end
  
  local shields = variables.mage_shields
  if shields and shields > 0 then
    local extents = EoHS.image_aggregate_extents(EoHS.unit_graphics_aggregate(result))
    local size = math.ceil(math.max(extents.size.x, extents.size.y) * 160 / 72)
    table.insert(unit_image_layers, {
      image_name = "halo/elven/elven-shield-halo-100pct.png~SCALE("..size..","..size..")~O("..((shields + 1) / 3)..")",
      offsx = prelim_image_info.offsx,
      offsy = prelim_image_info.offsy,
    })
  end
  
  if variables.is_wizard then
    local image_aggregate = EoHS.dressed_up_unit_image_aggregate(palettes_and_ranges, result.main_layer, EoHS.get_subtag(variables, "skillset.dress_up_options"))
    result.main_layer_eviscerated = image_aggregate --EoHS.image_aggregate_translated(image_aggregate, EoHS.image_layer_offset(result.main_layer))
  end

  return result
end

local convert_square_bracket_progressive_string_syntax = function(pstring)
  pstring = string.gsub(pstring, "%[.-%]", function(group) return string.gsub(group, ",", "[") end)
  return string.gsub(pstring, "([^,]+)", function(block)
    local group_lists = {}
    for group in string.gmatch(block, "%[(.-)%]") do
      local group_list = {}
      for part in string.gmatch(group, "([^[]+)") do
        local repeated,times = string.match(part, "(.+)%*(%d+)")
        local first,last = string.match(part, "(%d+)~(%d+)")
        if repeated then for j=1,times do table.insert(group_list, repeated) end
        elseif first then
          local m,n = tonumber(first),tonumber(last)
          local pad_length = math.min(string.len(first),string.len(last))
          for j=m,n,((m<n) and 1 or -1) do
            local element_str = ""..j
            table.insert(group_list, string.rep("0",math.max(0,pad_length-string.len(element_str)))..element_str)
          end
        else table.insert(group_list, part) end
      end
      table.insert(group_lists, group_list)
    end
    if not group_lists[1] then return block end
    local image_list
    for image_num in ipairs(group_lists[1]) do
      local group_num = 0
      image_list = (image_list and image_list.."," or "")..string.gsub(block, "%[.-%]", function()
        group_num = group_num + 1
        return group_lists[group_num][image_num]
      end)
    end
    return image_list
  end)
end

local add_animation = function(palettes_and_ranges, animations_added, animation_source, frame_graphics_func, animation_fixer_func, squish_idle_anims)
  local new_animation = EoHS.deep_copy(animation_source)
  local function fix_frames(table)
    for i,tag in ipairs(table) do
      if tag[1] == "frame" then
        local frame = tag[2]
        frame.primary = false
        frame.auto_vflip = false
        frame.image = string.gsub(convert_square_bracket_progressive_string_syntax(frame.image), "([^:,]+)([^,]*)", function(s,dur)
          return EoHS.collapse_image_aggregate(EoHS.unit_graphics_aggregate(frame_graphics_func(s, new_animation)), "image_modded")..dur
        end)
      end
      if tag[1] == "if" or tag[1] == "else" then fix_frames(tag[2]) end
    end
  end
  if squish_idle_anims and EoHS.is_idle_anim(new_animation) then
    new_animation[2].start_time = 0
    for i,subtag in ipairs(new_animation[2]) do new_animation[2][i] = nil end
  else
    fix_frames(new_animation[2])
  end
  -- always higher priority than the original animation
  new_animation[2].base_score = (new_animation[2].base_score or 0) + 1
  --table.insert(new_animation, {"filter",{}})
  if animation_fixer_func then animation_fixer_func(new_animation) end
  table.insert(animations_added, new_animation)
end

local add_animations = function(palettes_and_ranges, animations_added, animations_source, frame_graphics_func, animation_fixer_func, squish_idle_anims)
  for i,potential_anim_tag in ipairs(animations_source) do
    -- Hack - assume an animation is anything with a frame in it, TODO better
    local function search_for_frames(tag)
      if (tag[1]=="female") or (tag[1]=="variation") then return false end
      if string.match(tag[1], "frame") then return true end
      for i,subtag in ipairs(tag[2]) do if search_for_frames(subtag) then return true end end
      return false
    end
    if search_for_frames(potential_anim_tag) then
      add_animation(palettes_and_ranges, animations_added, potential_anim_tag, frame_graphics_func, animation_fixer_func, squish_idle_anims)
    end
  end
end

EoHS.is_attack_anim   = function(anim) return (anim[1] ==   "attack_anim") or (anim[2].apply_to and string.match(anim[2].apply_to,   "attack")) end
EoHS.is_defend_anim   = function(anim) return (anim[1] ==        "defend") or (anim[2].apply_to and string.match(anim[2].apply_to,   "defend")) end
EoHS.is_movement_anim = function(anim) return (anim[1] == "movement_anim") or (anim[2].apply_to and string.match(anim[2].apply_to, "movement")) end
EoHS.is_idle_anim     = function(anim) return (anim[1] ==     "idle_anim") or (anim[2].apply_to and string.match(anim[2].apply_to,   "idling")) end

EoHS.unit_thumbnail = function(unit, size)
  return EoHS.get_unit_variable(unit, "thumbnail_image")
end

-- Isolate the unit information used to generate graphics.
-- This is a semantic process that accomplishes two things:
-- One, it lets the code check whether a unit has changed enough to need new graphics,
--   so we don't have to recompute all the graphics stuff constantly.
-- Two, earlier code had an issue where that check became inconsistent with the actual
--   graphics code - we sometimes got false-negatives where a unit didn't generate
--   graphics even when it had, say, some obscure buff that I forgot to include in the
--   "do we need to generate graphics at all" check and is also usually used on units
--   that will have graphics generated anyway, masking the bug.
--   This solves that: If the buff isn't included in this data, then it won't show up
--   at all, so I'll catch the bug when I write the buff graphics in the first place.
EoHS.graphics_influencing_data = function(unit)
  local result = {}
  local graphics_altered_by_EoHS = false
  local record = function(attr)
    result[attr] = unit[attr]
  end
  record("type")
  record("gender")
  record("variation")
  record("side")
  record("image")
  local variables = EoHS.get_unit_variables(unit)
  if variables then
    local result_variables = EoHS.force_unit_variables(result)
    local record_variable = function(attr)
      if variables[attr] then graphics_altered_by_EoHS = true end
      result_variables[attr] = variables[attr]
    end
    record_variable("is_wizard")
    record_variable("is_mounted")
    record_variable("is_summon")
    record_variable("is_casting_a_spell")
    record_variable("just_teleported_ally")
    record_variable("just_teleported_enemy")
    local mount = EoHS.get_subtag(variables, "mount")
    if mount then
      graphics_altered_by_EoHS = true
      table.insert(result_variables, {"mount", EoHS.graphics_influencing_data(mount) }) -- TODO can record less info about the mount? Although, will any of it change?
    end
    local animations = EoHS.get_subtag(variables, "animations")
    if animations then
      graphics_altered_by_EoHS = true
      table.insert(result_variables, {"animations", animations }) -- TODO can record less info about the mount? Although, will any of it change?
    end
    local dress_up_options = EoHS.get_subtag(variables, "skillset.dress_up_options")
    if dress_up_options then
      graphics_altered_by_EoHS = true
      table.insert(result_variables, {"skillset", {{"dress_up_options", dress_up_options }}})
    end
  end
  
  -- Most of this function EoHS.graphics_influencing_data doesn't do any processing, just records data.
  -- One of its purposes, after all, is to save time - record everything and check if it's the same
  --   in order to avoid having to do the bigger labor of processing.
  -- However: The main cost here is iterating through the effects at all, and since we have to do that,
  --   we might as well only do it once, here.
  local w111 = wesnoth.compare_versions(wesnoth.game_config.version, ">=", "1.11.0")
  local ellipse = EoHS.get_unit_type(unit.type).ellipse or (w111 and (unit.canrecruit and "misc/ellipse-leader" or ((not unit.zoc) and "misc/ellipse-nozoc"))) or "misc/ellipse"
  local image_mods = ""
  for i,effect in ipairs(EoHS.get_unit_effects(unit, {exclude_id = "EoHS_unit_graphics_override"})) do
    if effect.apply_to == "ellipse" then ellipse = effect.ellipse end
    if effect.apply_to == "image_mod" then
      if effect.replace then
        -- Hack to appease the macro TEAM_COLOR_OVERRIDE, which currently (1.10.7) uses "RC()" when it should use "~RC()"
        if string.sub(effect.replace, 1, 1) ~= "~" then effect.replace = "~"..effect.replace end
        image_mods = effect.replace
      end
      if effect.add then
        -- Hack to appease the macro TEAM_COLOR_OVERRIDE, which currently (1.10.7) uses "RC()" when it should use "~RC()"
        if string.sub(effect.add, 1, 1) ~= "~" then effect.add = "~"..effect.add end
        image_mods = image_mods..effect.add
      end
    end
  end
  image_mods = image_mods..EoHS.unit_TC_image_mod(unit)
  result.ellipse = ellipse
  result.image_mods = image_mods
  
  result.graphics_altered_by_EoHS = graphics_altered_by_EoHS
  return result
end

EoHS.update_unit_graphics = function(unit)
  local data = EoHS.graphics_influencing_data(unit)
  local variables = EoHS.force_unit_variables(unit)
  local old_data,index = EoHS.get_subtag(variables, "graphics_influencing_data")
  if old_data then
    if EoHS.tags_are_identical(old_data, data) then return false end
    variables[index][2] = data
  else
    table.insert(variables, { "graphics_influencing_data", data })
  end

  local modifications = EoHS.get_subtag(unit, "modifications")
  EoHS.remove_subtags(modifications, "object", "EoHS_unit_graphics_override")
  
  local object, thumbnail = EoHS.generate_unit_graphics(data)
  variables.thumbnail_image = thumbnail
  if object then
    if not modifications then
      modifications = {}
      table.insert(unit, { "modifications", modifications })
    end
    table.insert(modifications, object)
  end
  --EoHS.err(EoHS.inspect(unit_graphics_override_object_contents))
  return true
end

EoHS.generate_unit_graphics = function(data)
  local add_ellipse = function(image_aggregate)
    return EoHS.image_aggregates_combined(
      data.ellipse.."-top.png"..EoHS.TC_image_mod(data.side, "ellipse_red"),
      image_aggregate,
      data.ellipse.."-bottom.png"..EoHS.TC_image_mod(data.side, "ellipse_red"))
  end

  if not data.graphics_altered_by_EoHS then
    return nil, EoHS.collapse_image_aggregate(EoHS.image_aggregate_cropped(
      add_ellipse(data.image..data.image_mods), { size={x=58,y=58}, offset={x=0,y=0} }), "image_modded")
  end

  local unit_graphics_override_object_contents = { id = "EoHS_unit_graphics_override" }
  local animations_added = { apply_to = "new_animation" }
  local palettes_and_ranges = {}
  local thumbnail
  local variables = EoHS.get_unit_variables(data) or {}
  
  local default_unit_graphics = EoHS.unit_graphics(palettes_and_ranges, data, EoHS.unit_default_main_layer(data))
  local default_image_aggregate = EoHS.unit_graphics_aggregate(default_unit_graphics)
  -- EoHS.err(EoHS.inspect(default_unit_graphics))
  -- EoHS.err(EoHS.inspect(default_image_aggregate))
  local default_frame_prototype = EoHS.make_image_aggregate_frame(default_image_aggregate)
  local default_frame = function(frame_contents)
    for k,v in pairs(default_frame_prototype) do
      frame_contents[k] = v
    end
    return frame_contents
  end
  
  do
    local offset = EoHS.image_layer_offset(default_unit_graphics.main_layer)
  
    local ellipse = data.ellipse
    local ellipsed_image_aggregate = add_ellipse(default_image_aggregate)
      
    thumbnail = EoHS.collapse_image_aggregate(EoHS.image_aggregate_cropped(
      EoHS.image_aggregate_translated(ellipsed_image_aggregate,
        {x=-offset.x,y=-offset.y}), { size={x=58,y=58}, offset={x=0,y=0} }), "image_modded")
  end

  local fiat_anims = EoHS.get_subtag(variables, "animations")
  local  unit_frame_graphics_func = function(      layer, anim) return EoHS.unit_graphics(palettes_and_ranges, data, layer,         nil, anim) end
  local mount_frame_graphics_func = function(mount_layer, anim) return EoHS.unit_graphics(palettes_and_ranges, data,   nil, mount_layer, anim) end
  if fiat_anims then for i,fiat_anim in ipairs(fiat_anims) do
    add_animation(palettes_and_ranges, animations_added, fiat_anim, unit_frame_graphics_func)
  end end
  add_animations(palettes_and_ranges, animations_added, EoHS.unit_type_considering_variations(data), unit_frame_graphics_func, nil, variables.is_wizard)
  
  if variables.is_mounted then
    local mount = EoHS.get_subtag(variables, "mount")
    add_animations(palettes_and_ranges, animations_added, EoHS.unit_type_considering_variations(mount), mount_frame_graphics_func,
      function(animation)
        if EoHS.is_attack_anim(animation) then
          EoHS.restrict_contained_filter(animation[2], "filter_attack",        { special = "granted_by_mount" })
        end
        if EoHS.is_defend_anim(animation) then
          EoHS.restrict_contained_filter(animation[2], "filter_second_attack", { special = "granted_by_mount" })
        end
      end
    )
  end
  
  if (variables.is_summon and (data.type == "Death Knight")) then
    add_animations(palettes_and_ranges, animations_added, EoHS.get_unit_type("Chocobone"), mount_frame_graphics_func,
      function(animation)
        if EoHS.is_attack_anim(animation) then
          EoHS.restrict_contained_filter(animation[2], "filter_attack",        { name = "spear" })
        end
        if EoHS.is_defend_anim(animation) then
          EoHS.restrict_contained_filter(animation[2], "filter_second_attack", { name = "spear" })
        end
      end
    )
  end
  
  local sidebar_image_aggregate
  local extents = EoHS.image_aggregate_extents(default_image_aggregate)
  if (extents.size.x == 72) and (extents.size.y == 72) then
    sidebar_image_aggregate = default_image_aggregate
  else
    local character_offset = EoHS.image_layer_offset(default_unit_graphics.main_layer)
    sidebar_image_aggregate = EoHS.image_aggregate_cropped(
      EoHS.image_aggregate_translated(default_image_aggregate,
        EoHS.offset_negated(character_offset)), { size={x=72,y=72}, offset={x=0,y=0} })
    
    local has_unrestricted_standing_anim = false
    for i,anim in ipairs(animations_added) do
      -- Hack: Counting directional standing_anims, because that works for the water serpent.
      -- Theoretically a unit could have a directional standing_anim but not for all directions,
      -- which would break this.
      if (anim[1] == "standing_anim") and (helper.get_child(anim[2], "filter") == nil) then
        has_unrestricted_standing_anim = true
        break
      end
    end
    
    if not has_unrestricted_standing_anim then
      table.insert(animations_added, { "standing_anim", {
        start_time = -50,
        { "frame", default_frame{ duration = 50 } },
      }})
    end
  end
  table.insert(unit_graphics_override_object_contents, { "effect", {
    apply_to = "image_mod",
    replace = EoHS.collapse_image_aggregate(sidebar_image_aggregate, "override_mod"),
  }})

  if variables.is_wizard then
    local w = EoHS.image_layer_offset(default_unit_graphics.main_layer)
    local casting_graphics = {
      EoHS.unit_graphics(palettes_and_ranges, data, EoHS.wizard_casting_image_base(data, 1)),
      EoHS.unit_graphics(palettes_and_ranges, data, EoHS.wizard_casting_image_base(data, 2)),
    }
    local casting_frame_prototypes = {
      EoHS.make_image_aggregate_frame(EoHS.unit_graphics_aggregate(casting_graphics[1])),
      EoHS.make_image_aggregate_frame(EoHS.unit_graphics_aggregate(casting_graphics[2])),
    }
    local casting_frame = function(frame_contents)
      for k,v in pairs(casting_frame_prototypes[frame_contents[1]]) do
        frame_contents[k] = v
      end
      frame_contents[1] = nil
      return frame_contents
    end
    table.insert(animations_added, { "animation", { apply_to = "EoHS_start_casting",
      { "frame", default_frame{ duration = 200 } },
      { "frame", casting_frame{ 1, duration = 200 } },
      { "frame", casting_frame{ 2, duration = 200 } },
    }})
    table.insert(animations_added, { "animation", { apply_to = "EoHS_stop_casting",
      { "frame", casting_frame{ 2, duration = 200 } },
      { "frame", casting_frame{ 1, duration = 200 } },
      { "frame", default_frame{ duration = 200 } },
    }})

    local fireball_missile_frame = function(number, duration, min, max)
      return { "missile_frame", {
        offset = ""..min.."~"..max, duration = duration,
        directional_x = ""..math.floor(w.x*(1-min)).."~"..math.floor(w.x*(1-max)),
        y = ""..math.floor(w.y*(1-min)).."~"..math.floor(w.y*(1-max)),
        image = "projectiles/fireball-n"..number..".png", image_diagonal = "projectiles/fireball-nw"..number..".png",
      }}
    end
    local fireball_impact_frame = function(number)
      return { "missile_frame", {
        offset = "1.0", duration = 60,
        halo = "projectiles/fireball-impact-"..number..".png",
        auto_vflip = false,
      }}
    end
    local fireball_fail_frame = function(number)
      return { "missile_frame", {
        duration = 100,
        image = "projectiles/fireball-fail-"..number..".png",
        auto_vflip = false,
      }}
    end
    table.insert(animations_added, { "attack_anim", { start_time = -575, 
      { "filter_attack", { name = "EoHS_evocation_skill_ranged_attack", }},
      
      start_time = -575,
      { "frame", default_frame{    duration =  50,                    } },
      { "frame", casting_frame{ 1, duration = 100, sound = "fire.wav" } },
      { "frame", casting_frame{ 2, duration = 150,                    } },
      { "frame", casting_frame{ 1, duration =  75,                    } },
      { "frame", default_frame{    duration =  75,                    } },

      missile_start_time = -350,
      { "if", { hits = "yes",
        fireball_missile_frame("-1", 40, 0.0, 0.1),
        fireball_missile_frame("-2", 100, 0.1, 0.3),
        fireball_missile_frame("", 125, 0.3, 0.6),
        fireball_missile_frame("-2", 55, 0.7, 0.8),
        fireball_missile_frame("-1", 30, 0.8, 0.9),
        fireball_impact_frame(1),
        fireball_impact_frame(2),
        fireball_impact_frame(3),
        fireball_impact_frame(4),
        fireball_impact_frame(5),
        fireball_impact_frame(6),
        fireball_impact_frame(7),
        fireball_impact_frame(8),
        fireball_impact_frame(9),
        fireball_impact_frame(10),
        fireball_impact_frame(11),
        fireball_impact_frame(12),
        fireball_impact_frame(13),
        fireball_impact_frame(14),
        fireball_impact_frame(15),
        fireball_impact_frame(16),
      }},
      { "else", { hits = "no",
        missile_offset = "0.0~0.20,0.20~0.35,0.35~0.40,0.4~0.45",
        missile_directional_x = ""..(w.x*(1-0.0)).."~"..(w.x*(1-0.20))..","..(w.x*(1-0.20)).."~"..(w.x*(1-0.35))..","..(w.x*(1-0.35)).."~"..(w.x*(1-0.40))..","..(w.x*(1-0.4)).."~"..(w.x*(1-0.45)),
        missile_y = ""..(w.y*(1-0.0)).."~"..(w.y*(1-0.20))..","..(w.y*(1-0.20)).."~"..(w.y*(1-0.35))..","..(w.y*(1-0.35)).."~"..(w.y*(1-0.40))..","..(w.y*(1-0.4)).."~"..(w.y*(1-0.45)),
        fireball_fail_frame(1),
        fireball_fail_frame(2),
        fireball_fail_frame(3),
        fireball_fail_frame(4),
        fireball_fail_frame(5),
        fireball_fail_frame(6),
        fireball_fail_frame(7),
      }}
    }})
    
    local cast2_weapon_offs = EoHS.weapon_head_offset(casting_graphics[2])
    local faeriefire_frame = function(halo_number, castframe_number)
      return { "frame", casting_frame{ castframe_number, duration = 75, halo = "halo/elven/faerie-fire-halo"..halo_number..".png", primary = false, auto_vflip = false, halo_x = cast2_weapon_offs.x, halo_y = cast2_weapon_offs.y }}
    end
    table.insert(animations_added, { "attack_anim", { start_time = -450,
      { "filter_attack", { name = "EoHS_nature_magic_skill_ranged_attack", }},
      
      start_time = -450,
      faeriefire_frame(1, 1),
      faeriefire_frame(2, 2),
      faeriefire_frame(3, 2),
      faeriefire_frame(4, 2),
      faeriefire_frame(5, 2),
      faeriefire_frame(6, 2),
      faeriefire_frame(7, 1),
      
      sound_start_time = -450,
      { "if", { hits = "yes", { "sound_frame", { duration = 0, sound = "magic-faeriefire.ogg" }} }},
      { "else", { hits = "no", { "sound_frame", { duration = 0, sound = "magic-faeriefire-miss.ogg" }} }},
      
      missile_start_time = -500,
      missile_directional_x = ""..w.x.."~0",
      missile_y = ""..w.y.."~0",
      missile_halo_start_time = -500,
      missile_halo_layer = 10,
      missile_halo_directional_x = ""..w.x.."~0",
      missile_halo_y = ""..w.y.."~0",
      missile_halo_offset = "0~1",
      { "missile_frame",      { duration = 150, image = "projectiles/icemissile-n-1.png", image_diagonal = "projectiles/icemissile-ne-1.png", }},
      { "missile_halo_frame", { duration =  75, image = "halo/elven/ice-halo1.png", }},
      { "missile_halo_frame", { duration =  75, image = "halo/elven/ice-halo2.png", }},
      { "missile_frame",      { duration = 150, image = "projectiles/icemissile-n-2.png", image_diagonal = "projectiles/icemissile-ne-2.png", }},
      { "missile_halo_frame", { duration =  75, image = "halo/elven/ice-halo3.png", }},
      { "missile_halo_frame", { duration =  75, image = "halo/elven/ice-halo4.png", }},
      { "missile_frame",      { duration = 150, image = "projectiles/icemissile-n-3.png", image_diagonal = "projectiles/icemissile-ne-3.png", }},
      { "missile_halo_frame", { duration =  50, image = "halo/elven/ice-halo5.png", }},
      { "missile_halo_frame", { duration =  50, image = "halo/elven/ice-halo1.png", }},
      { "missile_halo_frame", { duration =  50, image = "halo/elven/ice-halo2.png", }},
      { "missile_frame",      { duration =  50, image = "projectiles/icemissile-n-4.png", image_diagonal = "projectiles/icemissile-ne-4.png", }},
      { "missile_halo_frame", { duration =  50, image = "halo/elven/ice-halo6.png", }},
      { "missile_frame",      { duration =  75, image = "projectiles/icemissile-n-5.png", image_diagonal = "projectiles/icemissile-ne-5.png", }},
      { "missile_halo_frame", { duration =  75, image = "halo/elven/ice-halo7.png", }},
      { "missile_frame",      { duration =  50, image = "projectiles/icemissile-n-6.png", image_diagonal = "projectiles/icemissile-ne-6.png", }},
      { "missile_halo_frame", { duration =  50, image = "halo/elven/ice-halo8.png", }},
      { "missile_frame",      { duration =  50, image = "projectiles/icemissile-n-7.png", image_diagonal = "projectiles/icemissile-ne-7.png", }},
      { "missile_halo_frame", { duration =  50, image = "halo/elven/ice-halo9.png", }},
    }})

    table.insert(animations_added, { "attack_anim", { start_time = -300,
      { "filter_attack", { name = "EoHS_necromancy_skill_ranged_attack", }},
      
      start_time = -300,
      { "frame", casting_frame{ 1, duration = 75 } },
      { "frame", casting_frame{ 2, duration = 75 } },
      { "frame", casting_frame{ 2, duration = 75, halo = "halo/undead/black-magic-1.png", halo_x = w.x, halo_y = w.y, }},
      { "frame", casting_frame{ 2, duration = 75, halo = "halo/undead/black-magic-2.png", halo_x = w.x, halo_y = w.y, }},
      { "frame", casting_frame{ 2, duration = 75, halo = "halo/undead/black-magic-3.png", halo_x = w.x, halo_y = w.y, }},
      { "frame", casting_frame{ 2, duration = 75, halo = "halo/undead/black-magic-4.png", halo_x = w.x, halo_y = w.y, }},
      { "frame", casting_frame{ 2, duration = 50, halo = "halo/undead/black-magic-5.png", halo_x = w.x, halo_y = w.y, }},
      { "frame", casting_frame{ 2, duration = 50, }},
      { "frame", casting_frame{ 1, duration = 50, }},
      
      sound_start_time = -75,
      { "if", { hits = "yes", { "sound_frame", { duration = 0, sound = "magic-dark.ogg" }} }},
      { "else", { hits = "no", { "sound_frame", { duration = 0, sound = "magic-dark-miss.ogg" }} }},

      missile_start_time = -100,
      missile_directional_x = ""..w.x.."~0",
      missile_y = ""..w.y.."~0",
      { "missile_frame", {
        duration = 200,
        image = "projectiles/darkmissile-n.png",
        image_diagonal = "projectiles/darkmissile-ne.png",
      }},
    }})
  end

  if animations_added[1] then table.insert(unit_graphics_override_object_contents, { "effect", animations_added }) end
  if palettes_and_ranges[1] then table.insert(unit_graphics_override_object_contents, EoHS.palettes_and_ranges_effect(palettes_and_ranges)) end
    
  return (unit_graphics_override_object_contents[1] and { "object", unit_graphics_override_object_contents }), thumbnail
end


>>)}

