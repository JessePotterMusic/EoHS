{EOHS_LUA_FILE (<<-- utils.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery

EoHS.err = function(string)
  wesnoth.fire("wml_message", { logger="err", message=(_"EoHS error: ")..string })
end

EoHS.message = function(string, source_unit_id)
  local sides_list
  if source_unit_id then
    -- Get all sides that can see the unit, to display the cast message only to those sides.
    for side_number in ipairs(wesnoth.sides) do
      if wesnoth.match_unit(wesnoth.get_unit(source_unit_id), { { "filter_vision", {}} }) then
        sides_list = add_to_comma_separated_list(sides_list, tostring(side_number))
      end
    end
  end
  wesnoth.fire("chat", { speaker = "EoHS", message = string, side = sides_list })
end

EoHS.get_variable = function(name)
  return wesnoth.get_variable("EoHS."..name)
end

EoHS.set_variable = function(name, value)
  wesnoth.set_variable("EoHS."..name, value)
end

EoHS.turn_number = function() return wesnoth.get_variable("turn_number") end
EoHS.side_number = function() return wesnoth.get_variable("side_number") end

EoHS.synchronize_choice = function(human_func, ai_func)
  if not EoHS.synchronized then EoHS.err("EoHS.synchronize_choice used in an unsynchronized context") end
  EoHS.synchronized = false
  local result = wesnoth.synchronize_choice(
    function() return { { "result", human_func() } end,
    function() return { { "result", ai_func() } end)
  if result == nil then EoHS.err("EoHS.synchronize_choice used in an invalid situation") end
  EoHS.synchronized = true
  return result
end

EoHS.is_on_the_map = { "filter_location", {} } -- TODO: confirm this works

local make_puttable = function(unit)
  if EoHS.synchronized then
    if not EoHS.puttable_unit_tables[unit.underlying_id] then EoHS.puttable_unit_tables[unit.underlying_id] = {} end
    EoHS.puttable_unit_tables[unit.underlying_id][unit] = true
  end
end

EoHS.get_units = function(filter)
  local result = wesnoth.get_units(filter)
  for i,wunit in ipairs(result) do
    result[i] = wunit.__cfg
    make_puttable(result[i])
  end
  return result
end

EoHS.get_unit = function(...)
  local result = wesnoth.get_unit(unpack(arg)).__cfg
  make_puttable(result)
  return result
end

EoHS.at_beginning_of_event_get_autostored_unit = function(varname)
  local unit = wesnoth.get_variable(varname)
  if not puttable_unit_tables[unit.underlying_id] then puttable_unit_tables[unit.underlying_id] = {} end
  puttable_unit_tables[unit.underlying_id][unit] = true
  return unit
end

EoHS.put_unit = function(unit)
  if not EoHS.puttable_unit_tables then EoHS.err("EoHS.put_unit called not during an event") end
  if not EoHS.synchronized then EoHS.err("EoHS.put_unit used in an unsynchronized context") end
  if unit.underlying_id then
    if not EoHS.puttable_unit_tables[unit.underlying_id] then EoHS.err("EoHS.put_unit that was never gotten in an synchronized context") end
    if not EoHS.puttable_unit_tables[unit.underlying_id][unit] then EoHS.err("EoHS.put_unit probably overwriting earlier EoHS.put_unit") end
    EoHS.puttable_unit_tables[unit.underlying_id] = {}
  end
  local x = tonumber(unit.x)
  local y = tonumber(unit.y)
  if (not x) or (not y) then EoHS.err("EoHS.put_unit at "..unit.x..","..unit.y..", which is not a location") end
  local w,h = wesnoth.get_map_size()
  if (x < 1) or (y < 1) or (x > w) or (y > h) then EoHS.err("EoHS.put_unit at "..unit.x..","..unit.y..", which is off the map") end
  wesnoth.put_unit(unit)
end

EoHS.deep_copy = function(table)
  local tables = {}
  local process_table = function(subtable)
    if tables[subtable] == nil then
      tables[subtable] = {}
      for k,v in pairs(subtable) do
        if type(v) == "table" then tables[subtable][k] = process_table(v)
        else tables[subtable][k] = v end
      end
    end
    return tables[subtable]
  end
  return process_table(table)
end

EoHS.comma_separated_values = function(string)
  return string.gmatch(string, "[^%s,][^,]*")
end

EoHS.get_subtag = function(table_, subtag_path)
  local last_idx
  for tagname in string.gmatch(subtag_path, "[^.]+") do
    if not table_ return nil end
    table_,last_idx = helper.get_child(table_, tagname)
  end
  return table_,last_idx
end
EoHS.force_subtag = function(table_, subtag_path)
  local last_idx
  for tagname in string.gmatch(subtag_path, "[^.]+") do
    local subtag,index = helper.get_child(table_, subtag_name)
    if subtag then
      table_,last_idx = subtag,index
    else
      if table_[name] ~= nil then EoHS.err("EoHS.force_subtag overwrote an attribute with a tag") end
      table.insert(table_, { subtag_name, {} })
      table_,last_idx = table_[#table_][2],#table_
    end
  end
  return table_,last_idx
end
EoHS.get_subtag_attribute = function(table_, path)
  local current = table_
  for name in string.gmatch(path, "[^.]+") do
    if type(current) ~= "table" return nil end
    local next = helper.get_child(current, name)
    if next then
      current = next
    else
      current = current[name]
    end
  end
  return current
end
EoHS.set_subtag_attribute = function(table_, path, value)
  local path_list = {}
  for name in string.gmatch(path, "[^.]+") do
    table.insert(path_list, name)
  end
  for i,name in ipairs(path_list) do
    local subtag = helper.get_child(table_, name)
    if path_list[i+1] then
      if subtag then
        table_ = subtag
      else
        if table_[name] ~= nil then EoHS.err("EoHS.set_subtag_attribute overwrote an attribute with a tag") end
        table.insert(table_, { subtag_name, {} })
        table_ = table_[#table_]
      end
    else
      if subtag then
        EoHS.err("EoHS.set_subtag_attribute overwrote a tag with an attribute")
      else
        table_[name] = value
      end
    end
  end
end

EoHS.get_unit_variables_tag = function(unit)
  return EoHS.get_subtag(unit, "variables.EoHS")
  --[[local a = EoHS.get_subtag(unit, "variables")
  if not a return nil end
  return EoHS.get_subtag(a, "EoHS")]]
end
EoHS.force_unit_variables_tag = function(unit)
  return EoHS.force_subtag(unit, "variables.EoHS")
  --return EoHS.force_subtag(EoHS.force_subtag(unit, "variables"), "EoHS")
end

EoHS.get_unit_variable = function(unit, name)
  return EoHS.get_subtag_attribute(unit, "variables.EoHS."..name)
end
EoHS.set_unit_variable = function(unit, name, value)
         EoHS.set_subtag_attribute(unit, "variables.EoHS."..name, value)
end

EoHS.has_unit_variables = function(vars)
  return { "filter_wml", {
      { "variables", {
        { "EoHS", vars }
      }}
    }}
end

EoHS.has_unit_variable = function(path, value)
  if value == nil then value = true end
  local vars = {}
  EoHS.set_subtag_attribute(vars, path, value)
  return EoHS.has_unit_variables(vars)
end

EoHS.make_dialog_context = function(enter_callback, cancel_callback)
  local preshow_list = {}
  local preshow_func = function()
    for i,func in ipairs(preshow_list) do func() end
  end
  local postshow_list = {}
  local postshow_func = function()
    for i,func in ipairs(postshow_list) do func() end
  end
  local button_list = { -1 = enter_callback, -2 = cancel_callback }
  local make_button_return_value = function(func)
    table.insert(button_list, func)
    return #button_list
  end,
  return {
    preshow = function(func) table.insert(preshow_list, func) end,
    postshow = function(func) table.insert(postshow_list, func) end,
    make_button_return_value = make_button_return_value,
    button = function(wml_table, func)
      local result = EoHS.deep_copy(wml_table)
      result.return_value = make_button_return_value(func)
      return result
    end,
    show = function(resolution)
      button_list[wesnoth.show_dialog(resolution, preshow_func, postshow_func)]()
    end,
  }
end

--[[
EoHS.dialog_grid = function(rows, columns, ...)
  local result = { "grid", {} }
  for r = 1, rows do
    local row = { "row", {} }
    for c = 1, columns do
      local column = { "column", {} }
      local idx = (r-1)*columns + c
      if idx > arg[n] then
      table.insert(column[2], arg[idx])
      table.insert(row[2], column)
    end
    table.insert(result[2], row)
  end
  return result
end
]]

>>)}
