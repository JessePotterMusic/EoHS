{EOHS_LUA_FILE (<<-- utils.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery

EoHS.err = function(string)
  wesnoth.fire("wml_message", { logger="err", message=(_"EoHS error: ")..string })
end

EoHS.get_variable = function(name)
  return wesnoth.get_variable("EoHS."..name)
end

EoHS.set_variable = function(name, value)
  wesnoth.set_variable("EoHS."..name, value)
end

EoHS.turn_number = function() return wesnoth.get_variable("turn_number") end
EoHS.side_number = function() return wesnoth.get_variable("turn_number") end

EoHS.synchronize_choice = function(human_func, ai_func)
  local result = wesnoth.synchronize_choice(
    function() return { { "result", human_func() } end,
    function() return { { "result", ai_func() } end)
  if result == nil then
    EoHS.err("EoHS.synchronize_choice used in an invalid situation")
  end
  return result
end

EoHS.is_on_the_map = { "filter_location", {} } -- TODO: confirm this works

EoHS.get_units = function(filter)
  local result = wesnoth.get_units(filter)
  for i,wunit in ipairs(result) do
    local unit = wunit.__cfg
    result[i] = unit
    if not puttable_unit_tables[unit.underlying_id] then puttable_unit_tables[unit.underlying_id] = {} end
    puttable_unit_tables[unit.underlying_id][unit] = true
    local x = tonumber(unit.x)
    local y = tonumber(unit.y)
    if (not x) or (not y) then EoHS.err("EoHS.get_unit got a unit that was not on the map") end
  end
  return result
end

EoHS.get_unit = function(underlying_id)
  return EoHS.get_units({ {"filter_wml",{ underlying_id = underlying_id }} })
end

EoHS.at_beginning_of_event_get_autostored_unit = function(varname)
  local unit = wesnoth.get_variable(varname)
  if not puttable_unit_tables[unit.underlying_id] then puttable_unit_tables[unit.underlying_id] = {} end
  puttable_unit_tables[unit.underlying_id][unit] = true
  return unit
end

EoHS.put_unit = function(unit)
  if unit.underlying_id then
    if not puttable_unit_tables[unit.underlying_id] then EoHS.err("EoHS.put_unit that was never gotten...?") end
    if not puttable_unit_tables[unit.underlying_id][unit] then EoHS.err("EoHS.put_unit probably overwriting earlier EoHS.put_unit") end
    puttable_unit_tables[unit.underlying_id] = {}
  end
  local x = tonumber(unit.x)
  local y = tonumber(unit.y)
  if (not x) or (not y) then EoHS.err("EoHS.put_unit at "..unit.x..","..unit.y..", which is not a location") end
  local w,h = wesnoth.get_map_size()
  if (x < 1) or (y < 1) or (x > w) or (y > h) then EoHS.err("EoHS.put_unit at "..unit.x..","..unit.y..", which is off the map") end
  wesnoth.put_unit(unit)
end

EoHS.deep_copy = function(table)
  local tables = {}
  local process_table = function(subtable)
    if tables[subtable] == nil then
      tables[subtable] = {}
      for k,v in pairs(subtable) do
        if type(v) == "table" then tables[subtable][k] = process_table(v)
        else tables[subtable][k] = v end
      end
    end
    return tables[subtable]
  end
  return process_table(table)
end

EoHS.get_subtag = function(table_, subtag_path)
  local last_idx
  for tagname in string.gmatch(subtag_path, "[^.]+") do
    if not table_ return nil end
    table_,last_idx = helper.get_child(table_, tagname)
  end
  return table_,last_idx
end
EoHS.force_subtag = function(table_, subtag_path)
  local last_idx
  for tagname in string.gmatch(subtag_path, "[^.]+") doi
    local subtag,index = helper.get_child(table_, subtag_name)
    if subtag == nil then
      table.insert(table_, { subtag_name, {} })
      table_,last_idx = table_[#table_][2],#table_
    else
      table_,last_idx = subtag,index
    end
  end
  return table_,last_idx
end
EoHS.get_subtag_attribute = function(table_, path)
  local current = table_
  for name in string.gmatch(path, "[^.]+") do
    if type(current) ~= "table" return nil end
    local next = helper.get_child(current, name)
    if next then
      current = next
    else
      current = current[name]
    end
  end
  return current
end

EoHS.get_unit_variables_tag = function(unit)
  return EoHS.get_subtag(unit, "variables.EoHS")
  --[[local a = EoHS.get_subtag(unit, "variables")
  if not a return nil end
  return EoHS.get_subtag(a, "EoHS")]]
end
EoHS.force_unit_variables_tag = function(unit)
  return EoHS.force_subtag(unit, "variables.EoHS")
  --return EoHS.force_subtag(EoHS.force_subtag(unit, "variables"), "EoHS")
end

EoHS.get_unit_variable = function(unit, name)
  return EoHS.get_subtag_attribute(unit, "variables.EoHS."..name)
end
EoHS.set_unit_variable = function(unit, name, value)--TODO allow paths, tables
  EoHS.force_unit_variables_tag(unit)[name] = value
end

EoHS.has_unit_variables = function(vars)
  return { "filter_wml", {
      { "variables", {
        { "EoHS", vars }
      }}
    }}
end

EoHS.has_unit_variable = function(name, value)
  if value == nil then value = true end
  local vars = {}
  vars[name] = value
  return EoHS.has_unit_variables(vars)
end

EoHS.make_dialog_context = function(enter_callback, cancel_callback)
  local preshow_list = {}
  local preshow_func = function()
    for i,func in ipairs(preshow_list) do func() end
  end
  local postshow_list = {}
  local postshow_func = function()
    for i,func in ipairs(postshow_list) do func() end
  end
  local button_list = { -1 = enter_callback, -2 = cancel_callback }
  local make_button_return_value = function(func)
    table.insert(button_list, func)
    return #button_list
  end,
  return {
    preshow = function(func) table.insert(preshow_list, func) end,
    postshow = function(func) table.insert(postshow_list, func) end,
    make_button_return_value = make_button_return_value,
    button = function(wml_table, func)
      local result = EoHS.deep_copy(wml_table)
      result.return_value = make_button_return_value(func)
      return result
    end,
    show = function(resolution)
      button_list[wesnoth.show_dialog(resolution, preshow_func, postshow_func)]()
    end,
  }
end

--[[
EoHS.dialog_grid = function(rows, columns, ...)
  local result = { "grid", {} }
  for r = 1, rows do
    local row = { "row", {} }
    for c = 1, columns do
      local column = { "column", {} }
      local idx = (r-1)*columns + c
      if idx > arg[n] then
      table.insert(column[2], arg[idx])
      table.insert(row[2], column)
    end
    table.insert(result[2], row)
  end
  return result
end
]]

>>)}
